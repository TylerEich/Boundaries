{"version":3,"file":"drawing/drawing.js","names":[],"mappings":"","sources":["drawing/drawing.js"],"sourcesContent":["/* jshint camelcase: false */\n\nangular.module('bndry.drawing', ['ngStorage', 'bndry.map', 'bndry.color', 'bndry.history'])\n  .service('DirectionsSvc', function($q, MapSvc) {\n    var self = this;\n    var directions = new MapSvc.DirectionsService();\n\n    self.route = function(locations) {\n      if (locations.length !== 2) {\n        console.error('Requires exactly 2 locations.');\n        return false;\n      }\n\n      var request = {\n        origin: locations[0],\n        destination: locations[1],\n        travelMode: MapSvc.TravelMode.DRIVING\n      };\n\n      var deferred = $q.defer();\n\n      function processRequest(tries) {\n        directions.route(request,\n          // Success handler\n\n          function(result, status) {\n            if (status === MapSvc.DirectionsStatus.OK) {\n              var overviewPath = result.routes[0].overview_path;\n\n              // Resolve with path\n              deferred.resolve(overviewPath);\n            } else if (status ===\n              MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n              tries++;\n              // Try again\n              processRequest(tries);\n            } else {\n              deferred.reject();\n            }\n          },\n          // Error handler\n\n          function() {\n            if (tries < 3) {\n              // Try again\n              tries++;\n              processRequest(tries);\n            } else {\n              deferred.reject();\n            }\n          });\n      }\n\n      processRequest(0);\n\n      return deferred.promise;\n    };\n  })\n  .service('DrawingSvc', function($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc) {\n    var self = this;\n\n    function splice(itemArray, index = 0, removeLength = 0, newItems = []) {\n      var args = [index, removeLength].concat(newItems);\n      \n      return Array.prototype.splice.apply(itemArray, args);\n    }\n    function splicePassThru(itemArray) {\n      var args = [itemArray].concat(arguments);\n      splice.apply(null, args);\n      return itemArray;\n    }\n    function change(object, changes) {\n      for (var key in changes) {\n        if (changes.hasOwnProperty(key)) {\n          object[key] = changes[key];\n        }\n      }\n    }\n    \n    /* DrawingSvc hierarchy:\n     | - drawings\n       | - nodes\n       | - path\n    */\n    \n    /*\n    *** PRIVATE METHODS ***\n    */\n    // Path functions\n    function makePoint(latLng) {\n      console.assert(\n        'lat' in latLng &&\n        'lng' in latLng &&\n        typeof latLng.lat === 'number' &&\n        typeof latLng.lat === 'number',\n        \n        'latLng is not formatted properly'\n      );\n      return new MapSvc.LatLng(latLng.lat, latLng.lng);\n    }\n    function makePaths(locations, rigid = false) {\n      console.assert(\n        Array.isArray(locations),\n        \n        'locations is not an Array'\n      );\n      \n      var promises = [];\n      for (var i = 0; i < locations.length - 1; i++) {\n        var start = locations[i],\n          end = locations[i + 1],\n          promise;\n        \n        if (rigid) {\n          promise = start.equals(end) ?\n            $q.when([start]) :\n            $q.when([start, end]);\n        } else {\n          promise = DirectionsSvc.route([start, end]);\n        }\n        promises.push(promise);\n      }\n      \n      return $q.all(promises);\n    }\n    function addPoints(path, index, points) {\n      return splice(path, index, 0, points);\n    }\n    function removePoints(path, index, removeLength) {\n      return splice(path, index, removeLength);\n    }\n\n    // Node functions\n    function arrayify(nodes) {\n      if (!Array.isArray(nodes)) {\n        return [nodes];\n      } else {\n        return nodes;\n      }\n    }\n    function addNodes(nodes, index, nodesToAdd) {\n      splice(nodes, index, 0, nodesToAdd);\n    }\n    var addNode = addNodes;\n    \n    function removeNodes(nodes, index, removeLength = 1) {\n      var removed = splice(nodes, index, removeLength);\n      for (var i = 0; i < removed.length; i++) {\n        removed[i]._marker.setMap(null);\n      }\n    }\n    var removeNode = removeNodes;\n    \n    function changeNode(node, changes) {\n      console.assert(\n        typeof node === 'object' &&\n        typeof changes === 'object',\n        \n        'Invalid parameters'\n      )\n      change(node, changes);\n      for (var key in changes) {\n        switch (key) {\n        case 'lat':\n        case 'lng':\n          node._marker.setPosition(makePoint(node));\n          break;\n        }\n      }\n    }\n    function duplicateNode(drawing, node) {\n      return makeNode(drawing.colorIndex, makePoint(node), node.index);\n    }\n    function shiftIndexOfNodes(nodes, index, shifts) {\n      var nodeArray = arrayify(nodes),\n        shift = 0,\n        i = 0;\n      \n      if (Array.isArray(shifts)) {\n        for (i = 0; (i + index) < nodeArray.length && i < shifts.length; i++) {\n          shift += shifts[i];\n          nodeArray[index + i].index += shift;\n        }\n      } else {\n        shift = shifts;\n      }\n      for (i += index; i < nodeArray.length; i++) {\n        nodeArray[i].index += shift;\n      }\n    }\n    \n    function setIndexOfNodes(nodes, index, value) {\n      var nodeArray = arrayify(nodes);\n      for (var i = index; i < nodeArray.length; i++) {\n        nodeArray[i].index = value;\n      }\n    }\n    function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n      var nodeBefore = nodes[index - 1], indexForNode = 0;\n      \n      if (nodeBefore) {\n        indexForNode = nodeBefore.index;\n      }\n      setIndexOfNodes(nodesToAdd, 0, indexForNode);\n    }\n    \n    function rangeOfPathAroundNodes(nodes, start, end) {\n      var range = {\n        start: null,\n        end: null,\n        length: null,\n        nodeStart: null,\n        nodeEnd: null,\n        nodeLength: null,\n        lastNode: false,\n        firstNode: false\n      };\n      \n      var nodeRange = nodes.slice(start, end),\n        firstNodeInRange = nodeRange[0],\n        lastNodeInRange = nodeRange[nodeRange.length - 1],\n        nodeBeforeRange = nodes[start - 1],\n        nodeAfterRange = nodes[end];\n      \n      if (!nodeBeforeRange) {\n        range.firstNode = true;\n      }\n      if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n        range.start = nodeBeforeRange.index;\n        range.nodeStart = start;\n      } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n        range.start = firstNodeInRange.index;\n        range.nodeStart = start + 1;\n      } else {\n        range.start = 0;\n        range.nodeStart = 0;\n      }\n      \n      if (!nodeAfterRange) {\n        range.lastNode = true;\n      }\n      if (nodeAfterRange && nodeAfterRange.index !== null) {\n        range.end = nodeAfterRange.index;\n        range.nodeEnd = end;\n      } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n        range.end = lastNodeInRange.index;\n        range.nodeEnd = end - 1;\n      } else {\n        range.end = range.start;\n        range.nodeEnd = range.nodeStart;\n      }\n      \n      range.nodeLength = range.nodeEnd - range.nodeStart;\n      range.length = range.end - range.start;\n      return range;\n    }\n    function rangeOfPathAroundNode(nodes, index) {\n      return rangeOfPathAroundNodes(nodes, index, index);\n    }\n    function makePathsAroundNodes(nodes, start, end, rigid) {\n      var points = [],\n        nodeRange = nodes.slice(start, end),\n        nodeBefore = nodes[start - 1],\n        nodeAfter = nodes[end],\n        node;\n      \n      if (nodeBefore) {\n        points.push(makePoint(nodeBefore));\n      }\n      for (node of nodeRange) {\n        points.push(makePoint(node));\n      }\n      if (nodeAfter) {\n        points.push(makePoint(nodeAfter));\n      }\n      \n      if (points.length < 2) {\n        points.push(points[0]); // Duplicate first point; makePaths needs at least two points\n      }\n      \n      return makePaths(points, rigid);\n    }\n    function makePathsAroundNode(nodes, index, rigid) {\n      return makePathsAroundNodes(nodes, index, index, rigid);\n    }\n    \n\n    function alignNodesWithPath(path, nodes) {\n      var latLng;\n      \n      for (var node of nodes) {\n        latLng = path[node.index];\n        console.assert(\n          latLng,\n  \n          'latLng is not defined'\n        );\n        changeNode(node, {\n          lat: latLng.lat(),\n          lng: latLng.lng()\n        });\n      }\n    }\n    function processPaths(paths) {\n      \n    }\n    \n    function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n      var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n\n      if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n        return;\n      }\n      var path = drawing._poly.getPath().getArray(),\n        pathRemoveLength = range.length;\n      \n      // Special case to remove last point if lastNode\n      if (range.lastNode) {\n        pathRemoveLength++;\n      }\n      \n      removePoints(path, range.start, pathRemoveLength);\n      \n      shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n      removeNodes(drawing.nodes, index, nodeRemoveLength);\n      \n      drawing._poly.setPath(path);\n    }\n    function addNodesAndTheirPathsToDrawing(drawing, index, newNodes, newPaths = null) {\n      setInitialIndexOfNodes(drawing.nodes, index, newNodes);\n      addNodes(drawing.nodes, index, newNodes);\n            \n      var promise = $q.when();\n      if (newPaths) {\n        promise = promise.then(\n          (newPaths) => newPaths\n        );\n      } else {\n        promise = promise.then(\n          makePathsAroundNodes.bind(null, drawing.nodes, index, index + newNodes.length, drawing.rigid)\n        );\n      }\n      \n      promise = promise.then(\n        function(drawing, index, newNodes, newPaths) {\n          var polyPath = drawing._poly.getPath().getArray(),\n            nodes = drawing.nodes;\n            \n          var shifts = [];\n          var path, lastPoint, i,\n            pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length),\n            pathIndex = pathRange.start;\n            \n          for (path of newPaths) {\n            lastPoint = path.pop();\n            \n            // Adds new path\n            addPoints(polyPath, pathIndex, path);\n            \n            pathIndex += path.length;\n            shifts.push(path.length);\n          }\n          \n          var alignLength = newPaths.length;\n          shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n          \n          if (pathRange.lastNode && lastPoint) { // If lastNode is involved, put lastPoint back\n            polyPath.push(lastPoint);\n            alignLength++;\n          }\n          \n          var nodesToAlign = nodes.slice(index, index + alignLength);\n          alignNodesWithPath(polyPath, nodesToAlign);\n          // console.table(nodes);\n          // console.info(polyPath);\n          // console.info(`Length of polyPath: ${polyPath.length}`);\n          \n          drawing._poly.setPath(polyPath);\n          return polyPath;\n        }.bind(null, drawing, index, newNodes)\n      );\n      return promise;\n    }\n    function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength, nodesToAdd = [], pathsToAdd = null) {      \n      var polyPath = drawing._poly.getPath().getArray();\n      nodesToAdd = arrayify(nodesToAdd);\n      \n      // First, remove nodes and add new ones\n      var promise = $q.when();\n      promise = promise.then(\n        function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n          removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n          return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n        }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd)\n      );\n      // queue(promise);\n      return promise;\n    }\n    \n    /*\n    *** PUBLIC API ***\n    */\n    var internalQueue = $q.when();\n    function queue(promise) { // Keeps path operations in correct order\n      internalQueue = internalQueue.then(promise => promise); // Return promise\n    }\n    \n    function makeNode(colorIndex, latLng, index = null) {\n      var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n\n      return {\n        lat: latLng.lat(),\n        lng: latLng.lng(),\n        index: index,\n        _marker: marker\n      };\n    }\n    self.makeNode = makeNode;\n    \n    // Drawing functions\n    function makeDrawing(colorIndex, rigid, fill = false) {\n      var poly;\n\n      if (fill) {\n        poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n      } else {\n        poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n      }\n      return {\n        colorIndex: colorIndex,\n        rigid: rigid,\n        fill: fill,\n        _poly: poly,\n        nodes: []\n      };\n    }\n    self.makeDrawing = makeDrawing;\n    \n    function addDrawings(drawings, index, drawingsToAdd) {\n      splice(drawings, index, 0, drawingsToAdd);\n    }\n    self.addDrawings = self.addDrawing = addDrawings;\n    \n    function addNodesToDrawing(drawing, index, nodesToAdd = [], pathsToAdd = null) {\n      return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n    }\n    self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n    \n    function removeDrawings(drawings, index, removeLength) {\n      var removedDrawings = splice(drawings, index, removeLength);\n      for (var i = 0; i < removedDrawings.length; i++) {\n        var removedDrawing = removedDrawings[i];\n        removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n        removedDrawing._poly.setMap(null);\n      }\n    }\n    self.removeDrawings = self.removeDrawing = removeDrawings;\n    \n    function removeNodesFromDrawing(drawing, index, removeLength, pathsToAdd = null) {\n      return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n    }\n    self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n    \n    function changeNodeOfDrawing(drawing, index, changes, pathsToAdd = null) {\n      var node = drawing.nodes[index];\n      changeNode(node, changes);\n      return spliceNodesIntoDrawing(drawing, index, 1, duplicateNode(drawing, node), pathsToAdd);\n    }\n    self.changeNodeOfDrawing = changeNodeOfDrawing;\n    \n    // function changePathOfDrawing(drawing, index, pathsToAdd, range) {\n    //   if (range.firstNode && range.lastNode) {\n    //     return;\n    //   }\n    //\n    //   var nodes = drawing.nodes;\n    //\n    //   var promise,\n    //     path = drawing._poly.getPath().getArray(),\n    //     pathIndex = range.start,\n    //     pathRemoveLength = range.end - range.start;\n    //\n    //   if (pathsToAdd === null) {\n    //     promise = makePathsAroundNodes(nodes, index, drawing.rigid);\n    //   } else {\n    //     var deferred = $q.defer();\n    //     deferred.resolve(pathsToAdd);\n    //     promise = deferred.promise;\n    //   }\n    //\n    //   promise.then(function(pathsToAdd) {\n    //     removePoints(path, pathIndex, pathRemoveLength);\n    //     shiftIndexOfNodes(nodes, range.nodeStart, -pathRemoveLength);\n    //\n    //     var shifts = [],\n    //       nodeLocations = [],\n    //       pathLength,\n    //       i, j;\n    //     for (i = 0; i < pathsToAdd.length; i++) {\n    //       if (i < pathsToAdd.length - 1) {\n    //         nodeLocations.push(pathsToAdd[i].pop());\n    //         pathLength = pathsToAdd[i].length;\n    //       } else {\n    //         pathLength = pathsToAdd.length - 1;\n    //       }\n    //       shifts.push(pathLength);\n    //     }\n    //     var combinedPath = Array.prototype.concat.apply([], pathsToAdd);\n    //     addPoints(path, pathIndex, combinedPath);\n    //     shiftIndexOfNodes(nodes, range.indexOfAffectedNode + 1, shifts);\n    //\n    //     for (i = range.indexOfAffectedNode, j = 0; j < nodeLocations.length; i++, j++) {\n    //       changeNode(nodes[i], {\n    //         lat: nodeLocations[j].lat(),\n    //         lng: nodeLocations[j].lng()\n    //       });\n    //     }\n    //     // for (i = 1; i < path.length; i++) {\n    //     //   if (path[i - 1].equals(path[i])) {\n    //     //     console.warn(`Point ${i - 1} and ${i} are the same`, path[i]);\n    //     //   }\n    //     // }\n    //     // console.info(path);\n    //\n    //\n    //     drawing._poly.setPath(path);\n    //   });\n    // }\n    \n    function changeDrawing(drawing, changes) {\n      change(drawing, changes);\n      \n      for (var key in changes) {\n        switch (key) {\n        case 'colorIndex':\n        case 'fill':\n          var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n          drawing._poly.setOptions(options);\n          break;\n        case 'rigid':\n          \n          break;\n        }\n      }\n    }\n\n    function drawingsToGeoJson(drawings) {\n      var storableDrawings = [];\n\n      for (var i = 0; i < drawings.length; i++) {\n        var drawing = drawings[i];\n        var storableDrawing = {};\n        \n        for (var key in drawing) {\n          if (key === '_poly') {\n            storableDrawing.path = MapSvc.geometry.encoding.encodePath(drawing._poly.getPath());\n          } else if (key === 'nodes') {\n            var storableNodes = [];\n            \n            for (var j = 0; j < drawing.nodes.length; j++) {\n              var node = drawing.nodes[j];\n              var storableNode = {};\n              for (var nodeKey in node) {\n                if (key[0] !== '_' && key[0] !== '$' && node.hasOwnProperty(nodeKey)) {\n                  storableNode[nodeKey] = node[nodeKey];\n                }\n              }\n              \n              storableNodes[i] = storableNode;\n            }\n          } else if (drawing.hasOwnProperty(key)) {\n            storableDrawing[key] = drawing[key];\n          }\n        }\n        \n        return storableDrawing;\n      }\n\n      $localStorage.drawings = storableDrawings;\n    }\n    function geoJsonToDrawings(drawings) {\n      var storedDrawings = $localStorage.drawings || {};\n      for (var i = 0; i < storedDrawings.length; i++) {\n        var storedDrawing = storedDrawings[i];\n        var path = MapSvc.geometry.encoding.decodePath(storedDrawing.path);\n        var drawing = self.makeDrawing(storedDrawing.colorIndex, storedDrawing.rigid,\n          storedDrawing.fill, path);\n          \n        for (var j = 0; j < storedDrawing.nodes.length; j++) {\n          var storedNode = storedDrawing[j];\n          var latLng = new MapSvc.LatLng(storedNode.lat, storedNode.lng);\n          var node = self.makeNode(storedDrawing.colorIndex, latLng);\n          \n          drawing.nodes.push(node);\n        }\n        \n        self.drawings.push(drawing);\n      }\n      \n    }\n    \n    function rgbaColorToString(rgba) {\n      return `rgba(${Math.round(rgba.r*255)},${Math.round(rgba.g*255)},${Math.round(rgba.b*255)},${rgba.a})`;\n    }\n\n    function shiftIndices(array, index, shift) {\n      for (var i = index; i < array.length; i++) {\n        array[i].index += shift;\n      }\n    }\n    \n    function makeIcon(colorIndex) {\n      var color = ColorSvc.colors[colorIndex];\n      return {\n        path: MapSvc.SymbolPath.CIRCLE,\n        scale: 10,\n        strokeColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n        strokeOpacity: 1,\n        strokeWeight: 2.5\n      };\n    }\n    function makeMarkerOptions(colorIndex, latLng) {\n      return {\n        clickable: true,\n        crossOnDrag: false,\n        cursor: 'pointer',\n        draggable: true,\n        flat: true,\n        icon: makeIcon(colorIndex),\n        map: MapSvc.map,\n        position: latLng\n      };\n    }\n    function makePolyOptions(colorIndex, fill) {\n      var value = {\n        clickable: true,\n        draggable: false,\n        editable: false,\n        map: MapSvc.map\n      };\n\n      var color = ColorSvc.colors[colorIndex];\n      \n      if (fill) {\n        value.fillColor = rgbaColorToString(color);\n        value.strokeWeight = 0;\n      } else {\n        value.strokeColor = rgbaColorToString(color);\n        value.strokeWeight = color.weight;\n      }\n\n      return value;\n    }\n    \n    self.forceCreateNewDrawing = false;\n    self.shouldCreateNewDrawing = () => {\n      if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n        return true;\n      }\n      var latestDrawing = self.drawings[self.drawings.length - 1];\n      return (latestDrawing && latestDrawing.colorIndex !== ColorSvc.activeColorIndex());\n    };\n    self.drawings;\n  })\n// Controllers\n.controller('DrawingCtrl', function($scope, $localStorage, DrawingSvc, ColorSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n    \n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n  \n  var activeDrawingIndex = -1;\n  // $scope.$storage = DrawingSvc.loadDrawings();\n\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n\n    // TODO: actual variable values\n    var rigid = false,\n      fill = false;\n\n    if (DrawingSvc.shouldCreateNewDrawing()) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex++;\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex, newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n    \n    var drawing = drawings[activeDrawingIndex];\n    var newNode = DrawingSvc.makeNode(colorIndex, param.latLng);\n    DrawingSvc.addNodeToDrawing(drawing, drawing.nodes.length, newNode);\n    \n    return;\n    \n    // HistorySvc.add({\n    //   undo: function(drawing, nodeIndex, didCreateNewDrawing) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1);\n    //     if (didCreateNewDrawing) {\n    //       DrawingSvc.spliceDrawing(drawingIndex, 1);\n    //     }\n    //   }.bind(null, lastDrawingIndex, newNodeIndex, shouldCreateNewDrawing()),\n    //   redo: function(drawingIndex, nodeIndex, newNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 0, newNode);\n    //   }.bind(null, lastDrawingIndex, newNodeIndex, newNode)\n    // });\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0],\n      drawing = drawings[drawingIndex],\n      originalNode = drawing.nodes[nodeIndex],\n      latLng = event.latLng;\n    \n    DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, {\n      lat: latLng.lat(),\n      lng: latLng.lng()\n    });\n    \n    // HistorySvc.add({\n    //   undo: function(drawingIndex, nodeIndex, originalNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1, originalNode);\n    //   }.bind(null, drawingIndex, nodeIndex, originalNode),\n    //   redo: function(drawingIndex, nodeIndex, newNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1, newNode);\n    //   }.bind(null, drawingIndex, nodeIndex, newNode)\n    // });\n  }\n  $scope.$on('map:click', addNode);\n  $scope.$on('action:clear', function($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex = -1;\n  });\n\n  $scope.marker = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {\n    click: function($params) {\n\n    }\n  };\n});\n"],"sourceRoot":"/source/"}