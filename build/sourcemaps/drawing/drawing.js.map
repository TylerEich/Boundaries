{"version":3,"file":"drawing/drawing.js","names":[],"mappings":"","sources":["drawing/drawing.js"],"sourcesContent":["/* jshint camelcase: false */\n\nangular.module('bndry.drawing', ['ngStorage', 'bndry.map', 'bndry.color', 'bndry.shape', 'bndry.history'])\n.service('DirectionsSvc', function($q, MapSvc) {\n  var self = this;\n  var directions = new MapSvc.DirectionsService();\n\n  self.route = function(locations) {\n    if (locations.length !== 2) {\n      console.error('Requires exactly 2 locations.');\n      return false;\n    }\n\n    var request = {\n      origin: locations[0],\n      destination: locations[1],\n      travelMode: MapSvc.TravelMode.DRIVING\n    };\n\n    var deferred = $q.defer();\n\n    function processRequest(tries) {\n      directions.route(request,\n        // Success handler\n\n        function(result, status) {\n          if (status === MapSvc.DirectionsStatus.OK) {\n            var overviewPath = result.routes[0].overview_path;\n\n            // Resolve with path\n            deferred.resolve(overviewPath);\n          } else if (status ===\n            MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n            tries++;\n            // Try again\n            processRequest(tries);\n          } else {\n            deferred.reject();\n          }\n        },\n        // Error handler\n\n        function() {\n          if (tries < 3) {\n            // Try again\n            tries++;\n            processRequest(tries);\n          } else {\n            deferred.reject();\n          }\n        });\n    }\n\n    processRequest(0);\n\n    return deferred.promise;\n  };\n})\n.service('DrawingSvc', function($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc, ShapeSvc) {\n  var self = this;\n\n\n\n  function splice(itemArray, index = 0, removeLength = 0, newItems = []) {\n    var args = [index, removeLength].concat(newItems);\n    \n    return Array.prototype.splice.apply(itemArray, args);\n  }\n  \n  function change(object, changes) {\n    for (var key in changes) {\n      if (changes.hasOwnProperty(key)) {\n        object[key] = changes[key];\n      }\n    }\n  }\n  \n  function arrayify(items) {\n    if (!Array.isArray(items)) {\n      return [items];\n    } else {\n      return items;\n    }\n  }\n  \n  \n  \n  /*\n  *** PRIVATE METHODS ***\n  */\n  // Path functions\n  function makePoint(latLng) {\n    console.assert(\n      'lat' in latLng &&\n      'lng' in latLng &&\n      typeof latLng.lat === 'number' &&\n      typeof latLng.lat === 'number',\n      \n      'latLng is not formatted properly'\n    );\n    return new MapSvc.LatLng(latLng.lat, latLng.lng);\n  }\n  \n  function addPoints(path, index, points) {\n    return splice(path, index, 0, points);\n  }\n  \n  function removePoints(path, index, removeLength) {\n    return splice(path, index, removeLength);\n  }\n\n\n\n  function makePaths(locations, rigid = false) {\n    console.assert(\n      Array.isArray(locations),\n      \n      'locations is not an Array'\n    );\n    \n    var promises = [];\n    for (var i = 0; i < locations.length - 1; i++) {\n      var start = locations[i],\n        end = locations[i + 1],\n        promise;\n      \n      if (rigid) {\n        promise = start.equals(end) ?\n          $q.when([start]) :\n          $q.when([start, end]);\n      } else {\n        promise = DirectionsSvc.route([start, end]);\n      }\n      promises.push(promise);\n    }\n    \n    return $q.all(promises);\n  }\n\n\n\n  // Node functions\n  function addNodes(nodes, index, nodesToAdd) {\n    nodesToAdd = arrayify(nodesToAdd);\n    for (var node of nodesToAdd) {\n      node._marker.setMap(MapSvc.map);\n    }\n    \n    return splice(nodes, index, 0, nodesToAdd);\n  }\n  var addNode = addNodes;\n  \n  function removeNodes(nodes, index, removeLength = 1) {\n    var removed = splice(nodes, index, removeLength);\n    for (var node of removed) {\n      node._marker.setMap(null);\n    }\n    \n    return removed;\n  }\n  var removeNode = removeNodes;\n  \n  function changeNode(node, changes) {\n    console.assert(\n      typeof node === 'object' &&\n      typeof changes === 'object',\n      \n      'Invalid parameters'\n    );\n    change(node, changes);\n    for (var key in changes) {\n      switch (key) {\n      case 'lat':\n      case 'lng':\n        node._marker.setPosition(makePoint(node));\n        break;\n      }\n    }\n  }\n  \n  function duplicateNode(drawing, node) {\n    return makeNode(drawing.colorIndex, makePoint(node), node.index);\n  }\n  \n  \n  \n  function shiftIndexOfNodes(nodes, index, shifts) {\n    var nodeArray = arrayify(nodes),\n      shift = 0,\n      i = 0;\n    \n    if (Array.isArray(shifts)) {\n      for (i = 0; (i + index) < nodeArray.length && i < shifts.length; i++) {\n        shift += shifts[i];\n        nodeArray[index + i].index += shift;\n      }\n    } else {\n      shift = shifts;\n    }\n    for (i += index; i < nodeArray.length; i++) {\n      nodeArray[i].index += shift;\n    }\n  }\n  \n  function setIndexOfNodes(nodes, index, value) {\n    var nodeArray = arrayify(nodes);\n    for (var i = index; i < nodeArray.length; i++) {\n      nodeArray[i].index = value;\n    }\n  }\n  \n  function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n    var nodeBefore = nodes[index - 1], indexForNode = 0;\n    \n    if (nodeBefore) {\n      indexForNode = nodeBefore.index;\n    }\n    setIndexOfNodes(nodesToAdd, 0, indexForNode);\n  }\n  \n  \n  \n  function rangeOfPathAroundNodes(nodes, start, end) {\n    var range = {\n      start: null,\n      end: null,\n      length: null,\n      nodeStart: null,\n      nodeEnd: null,\n      nodeLength: null,\n      lastNode: false,\n      firstNode: false\n    };\n    \n    var nodeRange = nodes.slice(start, end),\n      firstNodeInRange = nodeRange[0],\n      lastNodeInRange = nodeRange[nodeRange.length - 1],\n      nodeBeforeRange = nodes[start - 1],\n      nodeAfterRange = nodes[end];\n    \n    if (!nodeBeforeRange) {\n      range.firstNode = true;\n    }\n    if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n      range.start = nodeBeforeRange.index;\n      range.nodeStart = start;\n    } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n      range.start = firstNodeInRange.index;\n      range.nodeStart = start + 1;\n    } else {\n      range.start = 0;\n      range.nodeStart = 0;\n    }\n    \n    if (!nodeAfterRange) {\n      range.lastNode = true;\n    }\n    if (nodeAfterRange && nodeAfterRange.index !== null) {\n      range.end = nodeAfterRange.index;\n      range.nodeEnd = end;\n    } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n      range.end = lastNodeInRange.index;\n      range.nodeEnd = end - 1;\n    } else {\n      range.end = range.start;\n      range.nodeEnd = range.nodeStart;\n    }\n    \n    range.nodeLength = range.nodeEnd - range.nodeStart;\n    range.length = range.end - range.start;\n    \n    return range;\n  }\n  \n  function rangeOfPathAroundNode(nodes, index) {\n    return rangeOfPathAroundNodes(nodes, index, index);\n  }\n  \n  \n  \n  function makePathsAroundNodes(nodes, start, end, rigid) {\n    var points = [],\n      nodeRange = nodes.slice(start, end),\n      nodeBefore = nodes[start - 1],\n      nodeAfter = nodes[end],\n      node;\n    \n    if (nodeBefore) {\n      points.push(makePoint(nodeBefore));\n    }\n    for (node of nodeRange) {\n      points.push(makePoint(node));\n    }\n    if (nodeAfter) {\n      points.push(makePoint(nodeAfter));\n    }\n    \n    if (points.length < 2) {\n      points.push(points[0]); // Duplicate first point; makePaths needs at least two points\n    }\n    \n    return makePaths(points, rigid);\n  }\n  \n  function makePathsAroundNode(nodes, index, rigid) {\n    return makePathsAroundNodes(nodes, index, index, rigid);\n  }\n  \n\n  \n  function alignNodesWithPath(path, nodes) {\n    var latLng;\n    \n    for (var node of nodes) {\n      latLng = path[node.index];\n      console.assert(\n        latLng,\n\n        'latLng is not defined'\n      );\n      changeNode(node, {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      });\n    }\n  }\n  \n  \n  \n  function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n    var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n\n    if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n      return;\n    }\n    var path = drawing._poly.getPath().getArray(),\n      pathRemoveLength = range.length;\n\n    // Special case to remove last point if lastNode\n    if (range.lastNode) {\n      pathRemoveLength++;\n    }\n\n    removePoints(path, range.start, pathRemoveLength);\n\n    shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n    var removedNodes = removeNodes(drawing.nodes, index, nodeRemoveLength);\n    \n    drawing._poly.setPath(path);\n\n    $rootScope.$broadcast('drawing:change');\n    \n    return removedNodes;\n  }\n  \n  function addNodesAndTheirPathsToDrawing(drawing, index, newNodes, newPaths) {\n    var polyPath = drawing._poly.getPath().getArray(),\n      nodes = drawing.nodes;\n      \n    var shifts = [];\n    var path, lastPoint, i,\n      pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length),\n      pathIndex = pathRange.start;\n      \n    for (path of newPaths) {\n      lastPoint = path.pop();\n      \n      // Adds new path\n      addPoints(polyPath, pathIndex, path);\n      \n      pathIndex += path.length;\n      shifts.push(path.length);\n    }\n    \n    var alignLength = newPaths.length;\n    shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n    \n    if (pathRange.lastNode && lastPoint) { // If lastNode is involved, put lastPoint back\n      polyPath.push(lastPoint);\n      alignLength++;\n    }\n    \n    var nodesToAlign = nodes.slice(index, index + alignLength);\n    alignNodesWithPath(polyPath, nodesToAlign);\n    \n    drawing._poly.setPath(polyPath);\n    \n    $rootScope.$broadcast('drawing:change');\n    \n    return polyPath;\n  }\n  \n  \n  \n  function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength, nodesToAdd = [], pathsToAdd = null) {\n    return queue(\n      function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n        var removedNodes = removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n        \n        if (nodesToAdd === null) {\n          nodesToAdd = removedNodes;\n        } else {\n          nodesToAdd = arrayify(nodesToAdd);\n        }\n        \n        setInitialIndexOfNodes(drawing.nodes, index, nodesToAdd);\n        addNodes(drawing.nodes, index, nodesToAdd);\n      \n        var promise;\n        if (pathsToAdd) {\n          promise = $q.when(pathsToAdd);\n        } else {\n          promise = makePathsAroundNodes.bind(null, drawing.nodes, index, index + nodesToAdd.length, drawing.rigid)();\n        }\n        \n        return promise.then(\n          function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n            return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n          }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd)\n        );\n      }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd)\n    );\n  }\n  \n  \n  \n  /*\n  *** PUBLIC API ***\n  */\n  var internalQueue = $q.when();\n  function queue(steps = []) { // Keeps path operations in correct order\n    console.assert(\n      steps !== undefined,\n\n      'steps cannot be undefined'\n    );\n    \n    steps = arrayify(steps);\n    for (var step of steps) {\n      internalQueue = internalQueue.then(step);\n    }\n    \n    return internalQueue;\n  }\n  self.queue = queue;\n  \n  \n  \n  // Drawing functions\n  function makeDrawing(colorIndex, rigid, fill = false) {\n    var poly;\n\n    if (fill) {\n      poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n    } else {\n      poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n    }\n    return {\n      colorIndex: colorIndex,\n      rigid: rigid,\n      fill: fill,\n      _poly: poly,\n      nodes: []\n    };\n  }\n  self.makeDrawing = makeDrawing;\n  \n  function addDrawings(drawings, index, drawingsToAdd) {\n    return queue(\n      splice.bind(null, drawings, index, 0, drawingsToAdd)\n    );\n  }\n  self.addDrawings = self.addDrawing = addDrawings;\n  \n  function removeDrawings(drawings, index, removeLength) {\n    return queue(\n      function(drawings, index, removeLength) {\n        var removedDrawings = splice(drawings, index, removeLength);\n        for (var i = 0; i < removedDrawings.length; i++) {\n          var removedDrawing = removedDrawings[i];\n          removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n          removedDrawing._poly.setMap(null);\n        }\n      }.bind(null, drawings, index, removeLength)\n    );\n  }\n  self.removeDrawings = self.removeDrawing = removeDrawings;\n  \n  function changeDrawing(drawing, changes) {\n    change(drawing, changes);\n    \n    for (var key in changes) {\n      switch (key) {\n      case 'colorIndex':\n      case 'fill':\n        var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n        drawing._poly.setOptions(options);\n        break;\n      case 'rigid':\n        \n        break;\n      }\n    }\n    \n    $rootScope.$broadcast('drawing:change');\n  }\n  \n  \n  \n  function makeNode(colorIndex, latLng, index = null) {\n    var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n\n    return {\n      lat: latLng.lat(),\n      lng: latLng.lng(),\n      index: index,\n      _marker: marker\n    };\n  }\n  self.makeNode = makeNode;\n  \n  function addNodesToDrawing(drawing, index, nodesToAdd = [], pathsToAdd = null) {\n    return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n  }\n  self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n  \n  function removeNodesFromDrawing(drawing, index, removeLength, pathsToAdd = null) {\n    return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n  }\n  self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n  \n  function changeNodeOfDrawing(drawing, index, changes, pathsToAdd = null) {\n    queue(\n      function(drawing, index, changes) {\n        changeNode(drawing.nodes[index], changes);\n      }.bind(null, drawing, index, changes)\n    );\n    \n    return spliceNodesIntoDrawing.bind(null, drawing, index, 1, null, pathsToAdd)(); \n  }\n  self.changeNodeOfDrawing = changeNodeOfDrawing;\n  \n\n\n  function makeIcon(colorIndex) {\n    var color = ColorSvc.colors[colorIndex];\n    return {\n      path: MapSvc.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n  }\n  \n  function makeMarkerOptions(colorIndex, latLng) {\n    return {\n      clickable: true,\n      crossOnDrag: false,\n      cursor: 'pointer',\n      draggable: true,\n      flat: true,\n      icon: makeIcon(colorIndex),\n      map: MapSvc.map,\n      position: latLng\n    };\n  }\n  \n  function makePolyOptions(colorIndex, fill) {\n    var value = {\n      clickable: !fill,\n      draggable: false,\n      editable: false,\n      map: MapSvc.map\n    };\n\n    var color = angular.copy(ColorSvc.colors[colorIndex]);\n    color.a = 0.5;\n    \n    if (fill) {\n      value.fillColor = rgbaColorToString(color);\n      value.fillOpacity = 1;\n      value.strokeWeight = 0;\n    } else {\n      value.strokeColor = rgbaColorToString(color);\n      value.strokeWeight = color.weight;\n    }\n\n    return value;\n  }\n  \n  \n  \n  function drawingsToGeoJson(drawings) {\n    var geoJson = {\n      type: 'FeatureCollection'\n    };\n\n    geoJson.features = drawings.map(\n      (drawing) => {\n        var feature = {\n          type: 'Feature'\n        };\n        \n        var polyPath = drawing._poly.getPath().getArray();          \n        var coordinates = polyPath.map(\n          (latLng) => {\n            return [\n              latLng.lng(),\n              latLng.lat()\n            ];\n          }\n        );\n        \n        feature.geometry = {\n          type: drawing.fill ? 'Polygon' : 'LineString',\n          coordinates: drawing.fill ? [coordinates] : coordinates\n        };\n        \n        var {colorIndex, rigid, fill, nodes} = drawing;\n        feature.properties = {colorIndex, rigid, fill};\n        feature.properties.nodes = nodes.map(\n          (node) => {\n            var {lat, lng, index} = node;\n            return {lat, lng, index};\n          }\n        );\n        return feature;\n      }\n    );\n    \n    return JSON.stringify(geoJson);\n  }\n  self.drawingsToGeoJson = drawingsToGeoJson;\n  \n  function geoJsonToDrawings(geoJsonString) {\n    console.assert(\n      typeof geoJsonString === 'string',\n\n      'geoJson must be a string'\n    );\n    \n    var drawings = [];\n    var geoJson = JSON.parse(geoJsonString);\n    var drawings = geoJson.features.map(\n      (feature, i) => {\n        var {colorIndex, rigid, fill, nodes} = feature.properties;\n        var drawing = makeDrawing(colorIndex, rigid, fill);\n        addDrawings(drawings, i, drawing);\n        \n        var nodesToAdd = nodes.map(\n          (node) => {\n            var latLng = new MapSvc.LatLng(node.lat, node.lng);\n            return makeNode.bind(null, drawing.colorIndex, latLng, node.index)();\n          }\n        );\n        \n        var coordinates;\n        if (fill) {\n          coordinates = feature.geometry.coordinates[0];\n        } else {\n          coordinates = feature.geometry.coordinates;\n        }\n        var polyPath = coordinates.map(\n          (coordinate) => new MapSvc.LatLng(coordinate[1], coordinate[0])\n        );\n        \n        var pathsToAdd = [];\n        for (var i = 0; i < nodesToAdd.length - 1; i++) {\n          var nodeAt = nodesToAdd[i],\n            nodeAfter = nodesToAdd[i + 1],\n            pathChunk = polyPath.slice(nodeAt.index, nodeAfter.index + 1);\n          \n          pathsToAdd.push(pathChunk);\n        }\n        \n        console.log(pathsToAdd);\n        \n        addNodesToDrawing.bind(null, drawing, 0, nodesToAdd, pathsToAdd)();\n        \n        return drawing;\n      }\n    );\n    \n    return drawings;\n  }\n  self.geoJsonToDrawings = geoJsonToDrawings;\n  \n  \n  \n  function rgbaColorToString(rgba) {\n    return `rgba(${Math.round(rgba.r*255)},${Math.round(rgba.g*255)},${Math.round(rgba.b*255)},${rgba.a})`;\n  }\n  \n  \n  \n  self.forceCreateNewDrawing = false;\n  \n  self.shouldCreateNewDrawing = () => {\n    if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n      return true;\n    }\n    var latestDrawing = self.drawings[self.drawings.length - 1];\n    var value = (latestDrawing &&\n      (latestDrawing.colorIndex !== ColorSvc.activeColorIndex() ||\n      latestDrawing.rigid !== ShapeSvc.rigid() ||\n      latestDrawing.fill !== ShapeSvc.fill()));\n    return value;\n  };\n  \n  self.drawings;\n})\n// Controllers\n.controller('DrawingCtrl', function($scope, $localStorage, $timeout, DrawingSvc, ColorSvc, ShapeSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n  \n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n  \n  // Load last saved drawings from geoJson in localStorage\n  var storedDrawings = DrawingSvc.geoJsonToDrawings(\n    localStorage.geoJson || DrawingSvc.drawingsToGeoJson(drawings)\n  );\n  for (var storedDrawing of storedDrawings) {\n    drawings.push(storedDrawing);\n  }\n  \n  var activeDrawingIndex = drawings.length - 1;\n  var queue = DrawingSvc.queue;\n  // $scope.$storage = DrawingSvc.loadDrawings();\n\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n    \n    var rigid = ShapeSvc.rigid(),\n      fill = ShapeSvc.fill();\n\n    if (DrawingSvc.shouldCreateNewDrawing()) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex++;\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex, newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n\n    queue(\n      ((activeDrawingIndex, colorIndex, latLng) => {\n        var drawing = drawings[activeDrawingIndex];\n        var newNode = DrawingSvc.makeNode(colorIndex, latLng);\n        \n        DrawingSvc.addNodeToDrawing(drawing, drawing.nodes.length, newNode);\n      }).bind(null, activeDrawingIndex, colorIndex, param.latLng)\n    );\n\n    // HistorySvc.add({\n    //   undo: function(drawing, nodeIndex, didCreateNewDrawing) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1);\n    //     if (didCreateNewDrawing) {\n    //       DrawingSvc.spliceDrawing(drawingIndex, 1);\n    //     }\n    //   }.bind(null, lastDrawingIndex, newNodeIndex, shouldCreateNewDrawing()),\n    //   redo: function(drawingIndex, nodeIndex, newNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 0, newNode);\n    //   }.bind(null, lastDrawingIndex, newNodeIndex, newNode)\n    // });\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0],\n      drawing = drawings[drawingIndex],\n      originalNode = drawing.nodes[nodeIndex],\n      latLng = event.latLng;\n    \n    DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, {\n      lat: latLng.lat(),\n      lng: latLng.lng()\n    });\n    \n    // HistorySvc.add({\n    //   undo: function(drawingIndex, nodeIndex, originalNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1, originalNode);\n    //   }.bind(null, drawingIndex, nodeIndex, originalNode),\n    //   redo: function(drawingIndex, nodeIndex, newNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1, newNode);\n    //   }.bind(null, drawingIndex, nodeIndex, newNode)\n    // });\n  }\n  $scope.$on('map:click', addNode);\n  $scope.$on('action:clear', function($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex = -1;\n  });\n  $scope.$on('drawing:change', () => {\n    localStorage.geoJson = DrawingSvc.drawingsToGeoJson(drawings);\n  });\n  \n  $scope.marker = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    }\n  };\n});\n"],"sourceRoot":"/source/"}