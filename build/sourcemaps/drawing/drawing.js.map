{"version":3,"file":"drawing/drawing.js","names":[],"mappings":"","sources":["drawing/drawing.js"],"sourcesContent":["/* jshint camelcase: false */\n\nangular.module('bndry.drawing', ['ngStorage', 'bndry.map', 'bndry.color', 'bndry.history'])\n  .service('DirectionsSvc', function($q, MapSvc) {\n    var self = this;\n    var directions = new MapSvc.DirectionsService();\n\n    self.route = function(locations) {\n      if (locations.length !== 2) {\n        console.error('Requires exactly 2 locations.');\n        return false;\n      }\n\n      var request = {\n        origin: locations[0],\n        destination: locations[1],\n        travelMode: MapSvc.TravelMode.DRIVING\n      };\n\n      var deferred = $q.defer();\n\n      function processRequest(tries) {\n        directions.route(request,\n          // Success handler\n\n          function(result, status) {\n            if (status === MapSvc.DirectionsStatus.OK) {\n              var overviewPath = result.routes[0].overview_path;\n\n              // Resolve with path\n              deferred.resolve(overviewPath);\n            } else if (status ===\n              MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n              tries++;\n              // Try again\n              processRequest(tries);\n            } else {\n              deferred.reject();\n            }\n          },\n          // Error handler\n\n          function() {\n            if (tries < 3) {\n              // Try again\n              tries++;\n              processRequest(tries);\n            } else {\n              deferred.reject();\n            }\n          });\n      }\n\n      processRequest(0);\n\n      return deferred.promise;\n    };\n  })\n  .service('DrawingSvc', function($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc) {\n    var self = this;\n\n    function splice(itemArray, index = 0, removeLength = 0, newItems = []) {\n      var args = [index, removeLength].concat(newItems);\n      \n      return Array.prototype.splice.apply(itemArray, args);\n    }\n    function splicePassThru(itemArray) {\n      var args = [itemArray].concat(arguments);\n      splice.apply(null, args);\n      return itemArray;\n    }\n    function change(object, changes) {\n      for (var key in changes) {\n        if (changes.hasOwnProperty(key)) {\n          object[key] = changes[key];\n        }\n      }\n    }\n    function arrayify(items) {\n      if (!Array.isArray(items)) {\n        return [items];\n      } else {\n        return items;\n      }\n    }\n    /* DrawingSvc hierarchy:\n     | - drawings\n       | - nodes\n       | - path\n    */\n    \n    /*\n    *** PRIVATE METHODS ***\n    */\n    // Path functions\n    function makePoint(latLng) {\n      console.assert(\n        'lat' in latLng &&\n        'lng' in latLng &&\n        typeof latLng.lat === 'number' &&\n        typeof latLng.lat === 'number',\n        \n        'latLng is not formatted properly'\n      );\n      return new MapSvc.LatLng(latLng.lat, latLng.lng);\n    }\n    function makePaths(locations, rigid = false) {\n      console.assert(\n        Array.isArray(locations),\n        \n        'locations is not an Array'\n      );\n      \n      var promises = [];\n      for (var i = 0; i < locations.length - 1; i++) {\n        var start = locations[i],\n          end = locations[i + 1],\n          promise;\n        \n        if (rigid) {\n          promise = start.equals(end) ?\n            $q.when([start]) :\n            $q.when([start, end]);\n        } else {\n          promise = DirectionsSvc.route([start, end]);\n        }\n        promises.push(promise);\n      }\n      \n      return $q.all(promises);\n    }\n    function addPoints(path, index, points) {\n      return splice(path, index, 0, points);\n    }\n    function removePoints(path, index, removeLength) {\n      return splice(path, index, removeLength);\n    }\n\n    // Node functions\n    function addNodes(nodes, index, nodesToAdd) {\n      splice(nodes, index, 0, nodesToAdd);\n    }\n    var addNode = addNodes;\n    \n    function removeNodes(nodes, index, removeLength = 1) {\n      var removed = splice(nodes, index, removeLength);\n      for (var i = 0; i < removed.length; i++) {\n        removed[i]._marker.setMap(null);\n      }\n    }\n    var removeNode = removeNodes;\n    \n    function changeNode(node, changes) {\n      console.assert(\n        typeof node === 'object' &&\n        typeof changes === 'object',\n        \n        'Invalid parameters'\n      )\n      change(node, changes);\n      for (var key in changes) {\n        switch (key) {\n        case 'lat':\n        case 'lng':\n          node._marker.setPosition(makePoint(node));\n          break;\n        }\n      }\n    }\n    function duplicateNode(drawing, node) {\n      return makeNode(drawing.colorIndex, makePoint(node), node.index);\n    }\n    function shiftIndexOfNodes(nodes, index, shifts) {\n      var nodeArray = arrayify(nodes),\n        shift = 0,\n        i = 0;\n      \n      if (Array.isArray(shifts)) {\n        for (i = 0; (i + index) < nodeArray.length && i < shifts.length; i++) {\n          shift += shifts[i];\n          nodeArray[index + i].index += shift;\n        }\n      } else {\n        shift = shifts;\n      }\n      for (i += index; i < nodeArray.length; i++) {\n        nodeArray[i].index += shift;\n      }\n    }\n    \n    function setIndexOfNodes(nodes, index, value) {\n      var nodeArray = arrayify(nodes);\n      for (var i = index; i < nodeArray.length; i++) {\n        nodeArray[i].index = value;\n      }\n    }\n    function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n      var nodeBefore = nodes[index - 1], indexForNode = 0;\n      \n      if (nodeBefore) {\n        indexForNode = nodeBefore.index;\n      }\n      setIndexOfNodes(nodesToAdd, 0, indexForNode);\n    }\n    \n    function rangeOfPathAroundNodes(nodes, start, end) {\n      var range = {\n        start: null,\n        end: null,\n        length: null,\n        nodeStart: null,\n        nodeEnd: null,\n        nodeLength: null,\n        lastNode: false,\n        firstNode: false\n      };\n      \n      var nodeRange = nodes.slice(start, end),\n        firstNodeInRange = nodeRange[0],\n        lastNodeInRange = nodeRange[nodeRange.length - 1],\n        nodeBeforeRange = nodes[start - 1],\n        nodeAfterRange = nodes[end];\n      \n      if (!nodeBeforeRange) {\n        range.firstNode = true;\n      }\n      if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n        range.start = nodeBeforeRange.index;\n        range.nodeStart = start;\n      } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n        range.start = firstNodeInRange.index;\n        range.nodeStart = start + 1;\n      } else {\n        range.start = 0;\n        range.nodeStart = 0;\n      }\n      \n      if (!nodeAfterRange) {\n        range.lastNode = true;\n      }\n      if (nodeAfterRange && nodeAfterRange.index !== null) {\n        range.end = nodeAfterRange.index;\n        range.nodeEnd = end;\n      } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n        range.end = lastNodeInRange.index;\n        range.nodeEnd = end - 1;\n      } else {\n        range.end = range.start;\n        range.nodeEnd = range.nodeStart;\n      }\n      \n      range.nodeLength = range.nodeEnd - range.nodeStart;\n      range.length = range.end - range.start;\n      return range;\n    }\n    function rangeOfPathAroundNode(nodes, index) {\n      return rangeOfPathAroundNodes(nodes, index, index);\n    }\n    function makePathsAroundNodes(nodes, start, end, rigid) {\n      var points = [],\n        nodeRange = nodes.slice(start, end),\n        nodeBefore = nodes[start - 1],\n        nodeAfter = nodes[end],\n        node;\n      \n      if (nodeBefore) {\n        points.push(makePoint(nodeBefore));\n      }\n      for (node of nodeRange) {\n        points.push(makePoint(node));\n      }\n      if (nodeAfter) {\n        points.push(makePoint(nodeAfter));\n      }\n      \n      if (points.length < 2) {\n        points.push(points[0]); // Duplicate first point; makePaths needs at least two points\n      }\n      \n      return makePaths(points, rigid);\n    }\n    function makePathsAroundNode(nodes, index, rigid) {\n      return makePathsAroundNodes(nodes, index, index, rigid);\n    }\n    \n\n    function alignNodesWithPath(path, nodes) {\n      var latLng;\n      \n      for (var node of nodes) {\n        latLng = path[node.index];\n        console.assert(\n          latLng,\n  \n          'latLng is not defined'\n        );\n        changeNode(node, {\n          lat: latLng.lat(),\n          lng: latLng.lng()\n        });\n      }\n    }\n    function processPaths(paths) {\n      \n    }\n    \n    function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n      var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n\n      if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n        return;\n      }\n      var path = drawing._poly.getPath().getArray(),\n        pathRemoveLength = range.length;\n      \n      // Special case to remove last point if lastNode\n      if (range.lastNode) {\n        pathRemoveLength++;\n      }\n      \n      removePoints(path, range.start, pathRemoveLength);\n      \n      shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n      removeNodes(drawing.nodes, index, nodeRemoveLength);\n      \n      drawing._poly.setPath(path);\n    }\n    function addNodesAndTheirPathsToDrawing(drawing, index, newNodes, newPaths = null) {\n      setInitialIndexOfNodes(drawing.nodes, index, newNodes);\n      addNodes(drawing.nodes, index, newNodes);\n      \n      var steps = []\n      if (newPaths) {\n        steps.push(newPaths => newPaths);\n      } else {\n        steps.push(makePathsAroundNodes.bind(null, drawing.nodes, index, index + newNodes.length, drawing.rigid));\n      }\n      \n      steps.push(\n        function(drawing, index, newNodes, newPaths) {\n          var polyPath = drawing._poly.getPath().getArray(),\n            nodes = drawing.nodes;\n            \n          var shifts = [];\n          var path, lastPoint, i,\n            pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length),\n            pathIndex = pathRange.start;\n            \n          for (path of newPaths) {\n            lastPoint = path.pop();\n            \n            // Adds new path\n            addPoints(polyPath, pathIndex, path);\n            \n            pathIndex += path.length;\n            shifts.push(path.length);\n          }\n          \n          var alignLength = newPaths.length;\n          shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n          \n          if (pathRange.lastNode && lastPoint) { // If lastNode is involved, put lastPoint back\n            polyPath.push(lastPoint);\n            alignLength++;\n          }\n          \n          var nodesToAlign = nodes.slice(index, index + alignLength);\n          alignNodesWithPath(polyPath, nodesToAlign);\n          \n          drawing._poly.setPath(polyPath);\n          return polyPath;\n        }.bind(null, drawing, index, newNodes)\n      );\n      return queue(steps);\n    }\n    function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength, nodesToAdd = [], pathsToAdd = null) {      \n      var polyPath = drawing._poly.getPath().getArray();\n      nodesToAdd = arrayify(nodesToAdd);\n      \n      // First, remove nodes and add new ones\n      return queue(\n        function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n          removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n          return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n        }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd)\n      );\n    }\n    \n    /*\n    *** PUBLIC API ***\n    */\n    var internalQueue = $q.when();\n    function queue(steps) { // Keeps path operations in correct order\n      console.assert(\n        steps !== undefined,\n  \n        'steps cannot be undefined'\n      );\n      var internalQueue = arrayify(steps).reduce($q.when, internalQueue);\n      return internalQueue;\n    }\n    self.queue = queue;\n    \n    function makeNode(colorIndex, latLng, index = null) {\n      var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n\n      return {\n        lat: latLng.lat(),\n        lng: latLng.lng(),\n        index: index,\n        _marker: marker\n      };\n    }\n    self.makeNode = makeNode;\n    \n    // Drawing functions\n    function makeDrawing(colorIndex, rigid, fill = false) {\n      var poly;\n\n      if (fill) {\n        poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n      } else {\n        poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n      }\n      return {\n        colorIndex: colorIndex,\n        rigid: rigid,\n        fill: fill,\n        _poly: poly,\n        nodes: []\n      };\n    }\n    self.makeDrawing = makeDrawing;\n    \n    function addDrawings(drawings, index, drawingsToAdd) {\n      return queue(\n        splice.bind(null, drawings, index, 0, drawingsToAdd)\n      );\n    }\n    self.addDrawings = self.addDrawing = addDrawings;\n    \n    function addNodesToDrawing(drawing, index, nodesToAdd = [], pathsToAdd = null) {\n      return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n    }\n    self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n    \n    function removeDrawings(drawings, index, removeLength) {\n      return queue(\n        function(drawings, index, removeLength) {\n          var removedDrawings = splice(drawings, index, removeLength);\n          for (var i = 0; i < removedDrawings.length; i++) {\n            var removedDrawing = removedDrawings[i];\n            removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n            removedDrawing._poly.setMap(null);\n          }\n        }.bind(null, drawings, index, removeLength)\n      );\n    }\n    self.removeDrawings = self.removeDrawing = removeDrawings;\n    \n    function removeNodesFromDrawing(drawing, index, removeLength, pathsToAdd = null) {\n      return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n    }\n    self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n    \n    function changeNodeOfDrawing(drawing, index, changes, pathsToAdd = null) {\n      return queue(\n        function(drawing, index, changes, pathsToAdd) {\n          var node = drawing.nodes[index];\n          changeNode(node, changes);\n          return spliceNodesIntoDrawing(drawing, index, 1, duplicateNode(drawing, node), pathsToAdd);\n        }.bind(null, drawing, index, changes, pathsToAdd)\n      );\n    }\n    self.changeNodeOfDrawing = changeNodeOfDrawing;\n    \n    function changeDrawing(drawing, changes) {\n      change(drawing, changes);\n      \n      for (var key in changes) {\n        switch (key) {\n        case 'colorIndex':\n        case 'fill':\n          var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n          drawing._poly.setOptions(options);\n          break;\n        case 'rigid':\n          \n          break;\n        }\n      }\n    }\n\n    function drawingsToGeoJson(drawings) {\n      var geoJson = {\n        type: 'FeatureCollection'\n      };\n\n      geoJson.features = drawings.map(\n        (drawing) => {\n          var feature = {\n            type: 'Feature'\n          };\n          \n          var coordinates = drawing._poly.getPath().getArray().map(\n            (latLng) => {\n              return [\n                latLng.lat(),\n                latLng.lng()\n              ];\n            }\n          );\n          \n          feature.geometry = {\n            type: drawing.fill ? 'Polygon' : 'LineString',\n            coordinates: drawing.fill ? [coordinates] : coordinates\n          };\n          \n          var {colorIndex, rigid, fill, nodes} = drawing;\n          feature.properties = {colorIndex, rigid, fill};\n          feature.properties.nodes = nodes.map(\n            (node) => {\n              var {lat, lng, index} = node;\n              return {lat, lng, index};\n            }\n          );\n          return feature;\n        }\n      );\n      \n      return JSON.stringify(geoJson);\n    }\n    self.drawingsToGeoJson = drawingsToGeoJson;\n    function geoJsonToDrawings(geoJsonString) {\n      console.assert(\n        typeof geoJsonString === 'string',\n  \n        'geoJson must be a string'\n      );\n      \n      var drawings = [];\n      var geoJson = JSON.parse(geoJsonString);\n      geoJson.features.forEach(\n        (feature, i) => {\n          var {colorIndex, rigid, fill, nodes} = feature.properties;\n          var drawing = makeDrawing(colorIndex, rigid, fill);\n          addDrawings(drawings, i, drawing);\n          \n          var nodesToAdd = nodes.map(\n            (node) => {\n              var latLng = new MapSvc.LatLng(node.lat, node.lng);\n              return makeNode(node.colorIndex, latLng, node.index);\n            }\n          );\n          \n          var coordinates;\n          if (fill) {\n            coordinates = feature.geometry.coordinates[0];\n          } else {\n            coordinates = feature.geometry.coordinates;\n          }\n          pathToAdd = coordinates.map(\n            (coordinate) => new MapSvc.LatLng(coordinate[0], coordinate[1])\n          );\n          addNodesToDrawing(drawing, 0, nodesToAdd, pathToAdd);\n          \n          drawings.push(drawing);\n        }\n      );\n      \n      return drawings;\n    }\n    self.geoJsonToDrawings = geoJsonToDrawings;\n    \n    function rgbaColorToString(rgba) {\n      return `rgba(${Math.round(rgba.r*255)},${Math.round(rgba.g*255)},${Math.round(rgba.b*255)},${rgba.a})`;\n    }\n\n    function shiftIndices(array, index, shift) {\n      for (var i = index; i < array.length; i++) {\n        array[i].index += shift;\n      }\n    }\n    \n    function makeIcon(colorIndex) {\n      var color = ColorSvc.colors[colorIndex];\n      return {\n        path: MapSvc.SymbolPath.CIRCLE,\n        scale: 10,\n        strokeColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n        strokeOpacity: 1,\n        strokeWeight: 2.5\n      };\n    }\n    function makeMarkerOptions(colorIndex, latLng) {\n      return {\n        clickable: true,\n        crossOnDrag: false,\n        cursor: 'pointer',\n        draggable: true,\n        flat: true,\n        icon: makeIcon(colorIndex),\n        map: MapSvc.map,\n        position: latLng\n      };\n    }\n    function makePolyOptions(colorIndex, fill) {\n      var value = {\n        clickable: true,\n        draggable: false,\n        editable: false,\n        map: MapSvc.map\n      };\n\n      var color = ColorSvc.colors[colorIndex];\n      \n      if (fill) {\n        value.fillColor = rgbaColorToString(color);\n        value.strokeWeight = 0;\n      } else {\n        color.a = 0.5;\n        value.strokeColor = rgbaColorToString(color);\n        value.strokeWeight = color.weight;\n      }\n\n      return value;\n    }\n    \n    self.forceCreateNewDrawing = false;\n    self.shouldCreateNewDrawing = () => {\n      if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n        return true;\n      }\n      var latestDrawing = self.drawings[self.drawings.length - 1];\n      return (latestDrawing && latestDrawing.colorIndex !== ColorSvc.activeColorIndex());\n    };\n    self.drawings;\n  })\n// Controllers\n.controller('DrawingCtrl', function($scope, $localStorage, DrawingSvc, ColorSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n    \n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n  \n  var queue = DrawingSvc.queue;\n  var activeDrawingIndex = -1;\n  // $scope.$storage = DrawingSvc.loadDrawings();\n\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n    \n    // TODO: actual variable values\n    var rigid = false,\n      fill = false;\n\n    if (DrawingSvc.shouldCreateNewDrawing()) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex++;\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex, newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n\n    queue(\n      ((activeDrawingIndex, colorIndex, latLng) => {\n        var drawing = drawings[activeDrawingIndex];\n        var newNode = DrawingSvc.makeNode(colorIndex, latLng);\n        \n        DrawingSvc.addNodeToDrawing(drawing, drawing.nodes.length, newNode);\n      }).bind(null, activeDrawingIndex, colorIndex, param.latLng)\n    );\n\n    // if (DrawingSvc.shouldCreateNewDrawing()) {\n    //   var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n    //   activeDrawingIndex++;\n    //   DrawingSvc.addDrawing(drawings, activeDrawingIndex, newDrawing);\n    //   DrawingSvc.forceCreateNewDrawing = false;\n    // }\n    //\n    // var drawing = drawings[activeDrawingIndex];\n    // var newNode = DrawingSvc.makeNode(colorIndex, param.latLng);\n    // DrawingSvc.addNodeToDrawing(drawing, drawing.nodes.length, newNode);\n    //\n    // return;\n    \n    // HistorySvc.add({\n    //   undo: function(drawing, nodeIndex, didCreateNewDrawing) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1);\n    //     if (didCreateNewDrawing) {\n    //       DrawingSvc.spliceDrawing(drawingIndex, 1);\n    //     }\n    //   }.bind(null, lastDrawingIndex, newNodeIndex, shouldCreateNewDrawing()),\n    //   redo: function(drawingIndex, nodeIndex, newNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 0, newNode);\n    //   }.bind(null, lastDrawingIndex, newNodeIndex, newNode)\n    // });\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0],\n      drawing = drawings[drawingIndex],\n      originalNode = drawing.nodes[nodeIndex],\n      latLng = event.latLng;\n    \n    DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, {\n      lat: latLng.lat(),\n      lng: latLng.lng()\n    });\n    \n    // HistorySvc.add({\n    //   undo: function(drawingIndex, nodeIndex, originalNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1, originalNode);\n    //   }.bind(null, drawingIndex, nodeIndex, originalNode),\n    //   redo: function(drawingIndex, nodeIndex, newNode) {\n    //     DrawingSvc.spliceNode(drawingIndex, nodeIndex, 1, newNode);\n    //   }.bind(null, drawingIndex, nodeIndex, newNode)\n    // });\n  }\n  $scope.$on('map:click', addNode);\n  $scope.$on('action:clear', function($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex = -1;\n  });\n\n  $scope.marker = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {\n    click: function($params) {\n\n    }\n  };\n});\n"],"sourceRoot":"/source/"}