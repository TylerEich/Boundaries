/*
 Boundaries v1.0.0
 (c) 2013-2015 Tyler Eich https://github.com/TylerEich/Boundaries
 License: MIT
*/
{"version":3,"sources":["script.min.js","main.js","ng-modules.js","action/action.js","color/color.js","drawing/drawing.js","geo/geo.js","history/history.js","image/image.js","map/map.js","search/search.js","shape/shape.js","status/status.js"],"names":[],"mappings":"AAAA;;AAEA;;ACAA;ADGA;ACAA;ADEA;AACA,UCaA,qBAAA;EACA;ADZA,CCaA,CAAA,aACA,UAAA,GAAA,WAAA;EACA;IACA;IACA;MACA;MACA;;MAEA;MACA;MACA;;MAEA;QACA;QACA;QACA;UACA;UACA;UACA;UACA;QDbQ;;QCgBR;UACA;YACA;UDbU;QACF;MACF;;MCgBN;QACA;QACA;UACA;UACA;QDbQ;MACF;;MCgBN;QACA;MDbM;;MCgBN;QACA;UACA;UACA;;UAEA;YACA;YACA;UDbU;UCeV;YACA;UDbU;UCeV;YACA;YACA;cACA;YDbY;UACF;QACF;MACF;;MCgBN;QACA;QACA;;QAEA;;QAEA;UACA;UACA;QDbQ;QCeR;UACA;QDbQ;QCeR;UACA;YACA;UDbU;QACF;MACF;IACF;EACF;AACF,CCcA,CAAA,aACA,WAAA;EACA;IACA;IACA;IACA;MACA;MACA;QACA;;QAGA;MDfM;IACF;EACF;AACF,cCiBA,QAAA;EACA;IACA;IACA;MACA;QACA;MDhBM;IACF;EACF;AACF,eCkBA,UAAA,GAAA,8DAAA;EACA;;EAEA;IACA;IACA;EDjBE;ECmBF;EACA;IACA;EDjBE;;ECoBF;IACA;EDjBE;ECmBF;IACA;IACA;EDjBE;;ECoBF;IACA;MACA;IDjBI;MCmBJ;IDjBI;EACF;ECmBF;IACA;MACA;IDjBI;MCmBJ;IDjBI;EACF;AACF,CCkBA,CAAA;EAEA;IACA;EDlBE;EACA;AACF;;;AEzJA;EACA;IACA;;IAMA;MACA;IFyJI;;IEtJJ;MACA;MACA;MACA;MACA;MACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;MFyJM;IACF;;IEtJJ;MACA;;MAEA;MACA;MACA;QACA;QACA;MFyJM;QEvJN;UACA;YACA;YACA;;YAEA;cACA;cACA;YFyJY;UACF;QACF;MACF;IACF;;IEtJJ;MACA;MACA;MACA;IFyJI;EACF;;EEtJF;IACA;EFyJE;AACF;AGvNA,8DACA,UAAA,GAAA,uCAAA;EACA;IACA;IACA;EHwNE;;EGrNF;EACA;IACA;MACA;IHwNI;EACF;;EGrNF;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I;IQz6CJ;MAAA;MACA;;MR66CM;MQ16CN;QACA;MR46CM;MQ16CN;QACA;MR46CM;;MAEA;MQ16CN;QAAA;QACA;UACA;;UAEA;YACA;UR66CU;;UQ16CV;QR66CQ;MACF;;MQ16CN;;MR86CM;MQ36CN;QACA;MR66CM;IACF;;IAEA;IQ36CJ;IACA;IACA;MACA;MACA;MACA;;MAEA;QACA;MR66CM;;MQ16CN;MACA;MACA;;MR86CM;MQ36CN;QACA;QACA;MR66CM;QQ36CN;QACA;MR66CM;MQ36CN;;MAEA;;MR86CM;MQ36CN;QACA;MR66CM;IACF;;IQ16CJ;IACA;IACA;IACA;;IAEA;IACA;;IR86CI;IQ36CJ;;IAEA;IACA;IACA;;IAEA;ER66CE;EQ36CF;IACA;MACA;IR66CI;;IQ16CJ;IACA;MAAA;MACA;QACA;QACA;QACA;MR86CM;MQ56CN;IR86CI;IQ56CJ;MACA;MACA;MACA;MACA;MACA;MACA;IR86CI;;IAEA;IQ56CJ;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;;IAEA;MACA;MACA;MACA;IR86CI;EACF;AACF,CQ76CA,CAAA,cACA,SAAA,GAAA,uBAAA;EACA;IACA;IACA;ER66CE;;EQ16CF;IACA;IACA;MACA;IR66CI;IQ36CJ;IACA;MACA;IR66CI;;IQ16CJ;ER66CE;AACF,CQ56CA,CAAA;;AR86CA;;AStlDA;;AT0lDA;AACA,USxlDA,MAAA,GAAA,eAAA;EACA;IACA;MACA;MACA;MACA;MACA;MACA;ITylDI;EACF;;EStlDF;IACA;IAGA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;ITulDI;EACF;;ESplDF;IACA;MACA;ITulDI;EACF;;ESplDF;;EAEA;EACA;EACA;EACA;;EAEA;;EAEA;ATulDA,CStlDA,CAAA;;ATwlDA;AACA,aStlDA,OAAA,GAAA,oDAAA;ETulDE;ESrlDF;IACA;IACA;IACA;IACA;IACA;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;QSrlDN;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;QSrlDN;MTulDM;IACF;MSrlDJ;MACA;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;MACA;QACA;MTulDM;IACF;MSrlDJ;MACA;QACA;MTulDM;IACF;EACF;;ESplDF;IACA;IACA;;IAEA;IACA;IACA;ETulDE;ESrlDF;IACA;;IAEA;ETulDE;;EAEA;ESrlDF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;ITulDI;ISrlDJ;IACA;ETulDE;;ESplDF;;EAEA;IACA;ETulDE;ESrlDF;ATulDA,CStlDA,CAAA,cACA,aAAA,GAAA,qBAAA;EACA;EACA;ITslDI;IACA;IACA;IACA;;ISnlDJ;ETslDE;ESplDF;IACA;ETslDE;AACF,CSrlDA,CAAA;;ATulDA;;AUvwDA,uEACA,OAAA,GAAA,uBAAA;EACA;IACA;IACA;MACA;;MAEA;QACA;UACA;QVywDQ;;QUtwDR;UACA;YACA;YVywDY;UACF;QACF;UUvwDR;YACA;YVywDY;UACF;QACF;MACF;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACF;EACF;AACF,CUxwDA,CAAA,WACA,SAAA,GAAA,iBAAA;EACA;IACA;;IAEA;MACA;IVwwDI;MUtwDJ;QACA;MVwwDM;;MUrwDN;;MAEA;QACA;UACA;QVwwDQ;UUtwDR;QVwwDQ;UUtwDR;QVwwDQ;MACF;IACF;;IUrwDJ;EVwwDE;;EUrwDF;IACA;MACA;IVwwDI;;IUrwDJ;MACA;QACA;MVwwDM;QUtwDN;UACA;YVwwDY;YUtwDZ;UVwwDU;YUtwDV;UVwwDU;QACF;MACF;IACF;EACF;AACF,CUvwDA,CAAA,cACA,UAAA,GAAA,mDAAA;EACA;IVuwDI;IUrwDJ;MVuwDM;MUrwDN;MACA;IVuwDI;;IUpwDJ;IACA;;IAEA;MAGA;;MAEA;QVqwDQ;QUnwDR;QACA;MVqwDM;IACF;EACF;;EUlwDF;IACA;MACA;MACA;MACA;;MAEA;QACA;QACA;;QAEA;;QAEA;MVqwDM;MUnwDN;MACA;MACA;IVqwDI;;IUlwDJ;EVqwDE;EACA;;EUlwDF;IACA;MAEA;QACA;QACA;MVowDM;IACF;EACF;;EUjwDF;;EAKA;EACA;;EAEA;IACA;MACA;IViwDI;;IU9vDJ;EViwDE;;;EU7vDF;IACA;;IAIA;MACA;IV+vDI;MU7vDJ;MACA;IV+vDI;;IU5vDJ;MACA;QACA;QACA;MV+vDM;QU7vDN;MV+vDM;QU7vDN;MV+vDM;IACF;EACF;;EU5vDF;IACA;IACA;EV+vDE;;EU5vDF;AV+vDA,CU9vDA,CAAA;;ACpMA,sDACA,QAAA,GAAA,kBAAA;EACA;IACA;MACA;IXo8DI;MWl8DJ;IXo8DI;EACF;EWl8DF;IACA;MACA;IXo8DI;MWl8DJ;IXo8DI;EACF;AACF,CWn8DA,CAAA,cACA,SAAA,GAAA,4BAAA;EACA;AXm8DA,CWl8DA,CAAA,MACA,kBAAA;EACA;IACA;IACA;EXk8DE;AACF,CWj8DA,CAAA;AXk8DA;;AYz9DA,sEACA,SAAA,GAAA,cAAA;EACA;IACA;IACA;MACA;MACA;IZ29DI;IYz9DJ;IACA;MACA;;MAGA;QACA;MZ09DM;MYx9DN;QACA;QACA;UACA;UACA;QZ09DQ;MACF;MYx9DN;QACA;QACA;QACA;MZ09DM;;MYv9DN;QZ09DQ;MACF;MY19DN;QACA;MZ49DM;IACF;EACF;AACF,CY39DA,CAAA,cACA,UAAA,GAAA,+CAAA;EACA;EACA;;EAEA;IACA;EZ29DE;;EYx9DF;IACA;MACA;IZ29DI;IYz9DJ;MAEA;MAKA;;MAEA;QACA;QACA;MZs9DM;MYp9DN;QAAA;QACA;UAAA;UACA;YACA;YACA;UZw9DU;QACF;MACF;IACF;EACF;AACF,CYv9DA,CAAA","file":"script.min.js","sourcesContent":["\"use strict\";\n\n/* global FastClick */\n\nangular.module(\"bndry\", [\n// 'ngTouch',\n\"ngStorage\", \"ui.map\", \"ngAnimate\", \"bndry.action\", \"bndry.color\", \"bndry.drawing\", \"bndry.geo\", \"bndry.history\", \"bndry.image\", \"bndry.map\", \"bndry.shape\", \"bndry.search\", \"bndry.status\"\n// 'bndry.settings'\n]).config(function ($compileProvider) {\n  $compileProvider.debugInfoEnabled(false);\n}).directive(\"onActivate\", function ($parse) {\n  return {\n    restrict: \"A\",\n    link: function (scope, element, attr) {\n      var hasTouch = false;\n      var handler = $parse(attr.onActivate);\n\n      var promise;\n      var finished = 0;\n      var now, then;\n\n      function whichAnimationEvent() {\n        var t;\n        var el = document.createElement(\"fakeelement\");\n        var transitions = {\n          animation: \"animationend\",\n          OAnimation: \"oAnimationEnd\",\n          MozAnimation: \"animationend\",\n          WebkitAnimation: \"webkitAnimationEnd\"\n        };\n\n        for (t in transitions) {\n          if (el.style[t] !== undefined) {\n            return transitions[t];\n          }\n        }\n      }\n\n      function removeClassIfFinished(element, cName, total) {\n        finished++;\n        if (finished >= total) {\n          element.removeClass(cName);\n          finished = 0;\n        }\n      }\n\n      element.on(whichAnimationEvent(), function () {\n        removeClassIfFinished(element, \"pressed\", 2);\n      });\n\n      element.one(\"mousedown\", function () {\n        if (!hasTouch) {\n          finished = 0;\n          element.addClass(\"pressed\");\n\n          element.on(\"mousedown\", function () {\n            finished = 0;\n            element.addClass(\"pressed\");\n          });\n          element.on(\"mouseup\", function () {\n            removeClassIfFinished(element, \"pressed\", 2);\n          });\n          element.on(\"click\", function (event) {\n            console.log(\"Click!\", event);\n            scope.$evalAsync(function () {\n              handler(scope, { $event: event });\n            });\n          });\n        }\n      });\n\n      element.one(\"touchstart\", function (event) {\n        hasTouch = true;\n        finished = 0;\n\n        element.addClass(\"pressed\");\n\n        element.on(\"touchstart\", function () {\n          finished = 0;\n          element.addClass(\"pressed\");\n        });\n        element.on(\"touchend touchcancel\", function () {\n          removeClassIfFinished(element, \"pressed\", 2);\n        });\n        element.on(\"touchend\", function (event) {\n          scope.$evalAsync(function () {\n            handler(scope, { $event: event });\n          });\n        });\n      });\n    }\n  };\n}).directive(\"ngXlinkHref\", function () {\n  return {\n    priority: 99,\n    restrict: \"A\",\n    link: function (scope, element, attr) {\n      var attrName = \"xlink:href\";\n      attr.$observe(\"ngXlinkHref\", function (value) {\n        if (!value) return;\n\n        element.attr(attrName, value);\n      });\n    }\n  };\n}).directive(\"noScroll\", function () {\n  return {\n    restrict: \"A\",\n    link: function (scope, elem) {\n      elem.on(\"touchstart wheel\", function (e) {\n        e.preventDefault();\n      });\n    }\n  };\n}).controller(\"MasterCtrl\", function ($scope, $localStorage, $sce, ColorSvc, DrawingSvc) {\n  $scope.$storage = $localStorage;\n\n  $scope.fillActiveColor = function () {\n    var hex = ColorSvc.convert.rgba(ColorSvc.activeColor()).to.hex24();\n    return \"#\" + hex;\n  };\n  $scope.shouldCreateNewDrawing = DrawingSvc.shouldCreateNewDrawing;\n  $scope.toggleForceCreateNewDrawing = function () {\n    DrawingSvc.forceCreateNewDrawing = !DrawingSvc.forceCreateNewDrawing;\n  };\n\n  $scope.sprite = function () {\n    return $sce.trustAsResourceUrl(\"#\" + ($scope.$storage.rigid ? \"rigid\" : \"flex\") + \"-\" + ($scope.$storage.fill ? \"fill\" : \"nofill\"));\n  };\n  $scope.show = {\n    header: \"\",\n    footer: \"\"\n  };\n\n  $scope.setShowHeader = function (show) {\n    if ($scope.show.header === show) {\n      $scope.show.header = \"\";\n    } else {\n      $scope.show.header = show;\n    }\n  };\n  $scope.setShowFooter = function (show) {\n    if ($scope.show.footer === show) {\n      $scope.show.footer = \"\";\n    } else {\n      $scope.show.footer = show;\n    }\n  };\n}).run(function () {\n  window.addEventListener(\"orientationchange\", function () {\n    window.scrollTo(0, 0);\n  });\n  // FastClick.attach(document.body);\n});\n\n\n(function () {\n  function initNgModules(element) {\n    var elements = [element], moduleElements = [], modules = [], names = [\"ng:module\", \"ng-module\", \"x-ng-module\", \"data-ng-module\", \"ng:modules\", \"ng-modules\", \"x-ng-modules\", \"data-ng-modules\"], NG_MODULE_CLASS_REGEXP = /\\sng[:\\-]module[s](:\\s*([\\w\\d_]+);?)?\\s/;\n\n    function append(element) {\n      element && elements.push(element);\n    }\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      names[i] = true;\n      append(document.getElementById(name));\n      name = name.replace(\":\", \"\\\\:\");\n      if (element.querySelectorAll) {\n        var elements2;\n        elements2 = element.querySelectorAll(\".\" + name);\n        for (var j = 0; j < elements2.length; j++) append(elements2[j]);\n\n        elements2 = element.querySelectorAll(\".\" + name + \"\\\\:\");\n        for (var j = 0; j < elements2.length; j++) append(elements2[j]);\n\n        elements2 = element.querySelectorAll(\"[\" + name + \"]\");\n        for (var j = 0; j < elements2.length; j++) append(elements2[j]);\n      }\n    }\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n\n      var className = \" \" + element.className + \" \";\n      var match = NG_MODULE_CLASS_REGEXP.exec(className);\n      if (match) {\n        moduleElements.push(element);\n        modules.push((match[2] || \"\").replace(/\\s+/g, \",\"));\n      } else {\n        if (element.attributes) {\n          for (var attrName in element.attributes) {\n            if (attrName == \"length\") continue;\n            var attr = { name: attrName, value: element.attributes[attrName].nodeValue };\n\n            if (names[attr.name]) {\n              moduleElements.push(element);\n              modules.push(attr.value);\n            }\n          }\n        }\n      }\n    }\n\n    for (var i = 0; i < moduleElements.length; i++) {\n      var moduleElement = moduleElements[i];\n      var module = modules[i].replace(/ /g, \"\").split(\",\");\n      angular.bootstrap(moduleElement, module);\n    }\n  }\n\n  angular.element(document).ready(function () {\n    initNgModules(document);\n  });\n})();\nangular.module(\"bndry.action\", [\"bndry.history\"]).controller(\"ActionCtrl\", function ($rootScope, $scope, HistorySvc) {\n  $scope.clear = function () {\n    $rootScope.$broadcast(\"action:clear\");\n    HistorySvc.clear();\n  };\n\n  $scope.hasUndo = HistorySvc.hasUndo;\n  $scope.undo = function () {\n    if (HistorySvc.hasUndo()) {\n      HistorySvc.undo();\n    }\n  };\n\n  $scope.hasRedo = HistorySvc.hasRedo;\n  $scope.redo = function () {\n    if (HistorySvc.hasRedo()) {\n      HistorySvc.redo();\n    }\n  };\n});\n\n/* jshint bitwise: false */\n\nangular.module(\"bndry.color\", [\"ngStorage\"])\n\n/*\nColor Service\n \nConverts color notations to various formats\nSupported formats: rgba, hsla, hex24, hex32\n*/\n.service(\"ColorSvc\", function ($localStorage) {\n  var _rgba = {};\n  var self = this;\n\n  function rgbaToInt(r, g, b, a) {\n    r = Math.round(r * 255);\n    g = Math.round(g * 255);\n    b = Math.round(b * 255);\n    a = Math.round(a * 255);\n\n    /*\n    Bitwise black magic (given r = 0x12, g = 0x34, b = 56, a = 78):\n    (r << 24) => 0x12000000\n    (g << 16) => 0x00340000\n    (b << 8)  => 0x00005600\n    (a)       => 0x00000078\n    \n    All OR'ed => 0x12345678\n    \n    `>>> 0` converts to unsigned 32-bit int\n    */\n    return (r << 24 | g << 16 | b << 8 | a) >>> 0;\n  }\n  function hueToRgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n\n  this.convert = {\n    rgba: function (rgba) {\n      _rgba = rgbaToInt(rgba.r, rgba.g, rgba.b, rgba.a);\n\n      return self;\n    },\n    hsla: function (hsla) {\n      var r, g, b;\n      var h = hsla.h;\n      var s = hsla.s;\n      var l = hsla.l;\n      var a = hsla.a;\n\n\n      if (s == 0) {\n        r = g = b = l; // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hueToRgb(p, q, h + 1 / 3);\n        g = hueToRgb(p, q, h);\n        b = hueToRgb(p, q, h - 1 / 3);\n      }\n\n      _rgba = rgbaToInt(r, g, b, a);\n\n      return self;\n    },\n    hex24: function (hex24) {\n      self.convert.hex32(hex24 + \"FF\");\n\n      return self;\n    },\n    hex32: function (hex32) {\n      _rgba = parseInt(hex32, 16) >>> 0; // `>>> 0` => unsigned 32-bit int\n\n      return self;\n    }\n  };\n  this.to = {\n    rgba: function () {\n      var r = (_rgba >> 24 & 255) / 255, g = (_rgba >> 16 & 255) / 255, b = (_rgba >> 8 & 255) / 255, a = (_rgba & 255) / 255;\n\n      _rgba = 0;\n\n      return { r: r, g: g, b: b, a: a };\n    },\n    hsla: function () {\n      var _self$to$rgba = self.to.rgba();\n\n      var r = _self$to$rgba.r;\n      var g = _self$to$rgba.g;\n      var b = _self$to$rgba.b;\n      var a = _self$to$rgba.a;\n\n\n      var max = Math.max(r, g, b), min = Math.min(r, g, b);\n      var h, s, l = (max + min) / 2;\n\n      if (max === min) {\n        h = s = 0; // achromatic\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);break;\n          case g:\n            h = (b - r) / d + 2;break;\n          case b:\n            h = (r - g) / d + 4;break;\n        }\n        h /= 6;\n      }\n\n      return { h: h, s: s, l: l, a: a };\n    },\n    hex24: function () {\n      return self.to.hex32().substring(0, 6);\n    },\n    hex32: function () {\n      var hex = _rgba.toString(16);\n      _rgba = 0;\n\n      return (\"00000000\" + hex).slice(-8); // Pad output with leading zero\n    }\n  };\n\n  // HOTFIX until proper interface arrives\n  delete $localStorage.colors;\n\n  $localStorage.$default({\n    colors: [{\n      name: \"Red\",\n      label: \"Do not work either side\",\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: \"Green\",\n      label: \"Work ONLY the inner side\",\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: \"Blue\",\n      label: \"Work both sides\",\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }],\n    activeColorIndex: 1\n  });\n  self.colors = $localStorage.colors;\n  self.activeColorIndex = function () {\n    return $localStorage.activeColorIndex;\n  };\n  self.setActiveColorIndex = function (index) {\n    $localStorage.activeColorIndex = index;\n  };\n  self.activeColor = function () {\n    return self.colors[self.activeColorIndex()];\n  };\n}).controller(\"ColorCtrl\", function ($scope, $localStorage, ColorSvc) {\n  $scope.$storage = $localStorage;\n\n  $scope.fillColor = function (index) {\n    if (index === undefined) {\n      index = ColorSvc.activeColorIndex();\n    }\n    var color = ColorSvc.colors[index];\n    return \"#\" + ColorSvc.convert.rgba(color).to.hex24();\n  };\n  $scope.activeColorIndex = ColorSvc.activeColorIndex;\n  $scope.setActiveColorIndex = ColorSvc.setActiveColorIndex;\n});\n\n/* jshint camelcase: false */\n\nangular.module(\"bndry.drawing\", [\"ngStorage\", \"bndry.map\", \"bndry.color\", \"bndry.shape\", \"bndry.history\"]).service(\"DirectionsSvc\", function ($rootScope, $q, MapSvc) {\n  var self = this;\n  var directions = new MapSvc.DirectionsService();\n\n  self.route = function (locations) {\n    if (locations.length !== 2) {\n      console.error(\"Requires exactly 2 locations.\");\n      return false;\n    }\n\n    var request = {\n      origin: locations[0],\n      destination: locations[1],\n      travelMode: MapSvc.TravelMode.DRIVING\n    };\n\n    var deferred = $q.defer();\n\n    function processRequest(tries, request) {\n      directions.route(request,\n      // Success handler\n\n      (function (request, result, status) {\n        if (status === MapSvc.DirectionsStatus.OK) {\n          var overviewPath = result.routes[0].overview_path;\n\n          // Resolve with path\n          deferred.resolve(overviewPath);\n        } else if (status === MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n          tries++;\n          // Try again\n          processRequest(tries);\n        } else {\n          $rootScope.$broadcast(\"load:error\");\n          deferred.reject([request.origin, request.destination]);\n        }\n      }).bind(null, request),\n      // Error handler\n\n      (function (request) {\n        if (tries < 3) {\n          // Try again\n          tries++;\n          processRequest(tries, request);\n        } else {\n          $rootScope.$broadcast(\"load:error\");\n          deferred.reject();\n        }\n      }).bind(null, request));\n    }\n\n    processRequest(0, request);\n\n    $rootScope.$broadcast(\"load:start\");\n\n    return deferred.promise.then(function (result) {\n      $rootScope.$broadcast(\"load:done\");\n      return result;\n    });\n  };\n}).service(\"DrawingSvc\", function ($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc, ShapeSvc) {\n  var self = this;\n\n\n\n  function splice(itemArray) {\n    var index = arguments[1] === undefined ? 0 : arguments[1];\n    var removeLength = arguments[2] === undefined ? 0 : arguments[2];\n    var newItems = arguments[3] === undefined ? [] : arguments[3];\n    var args = [index, removeLength].concat(newItems);\n\n    return Array.prototype.splice.apply(itemArray, args);\n  }\n\n  function change(object, changes) {\n    for (var key in changes) {\n      if (changes.hasOwnProperty(key)) {\n        object[key] = changes[key];\n      }\n    }\n  }\n\n  function arrayify(items) {\n    if (!Array.isArray(items)) {\n      return [items];\n    } else {\n      return items;\n    }\n  }\n\n\n\n  /*\n  *** PRIVATE METHODS ***\n  */\n  // Path functions\n  function makePoint(latLng) {\n    console.assert(\"lat\" in latLng && \"lng\" in latLng && typeof latLng.lat === \"number\" && typeof latLng.lat === \"number\", \"latLng is not formatted properly\");\n    return new MapSvc.LatLng(latLng.lat, latLng.lng);\n  }\n\n  function addPoints(path, index, points) {\n    return splice(path, index, 0, points);\n  }\n\n  function removePoints(path, index, removeLength) {\n    return splice(path, index, removeLength);\n  }\n\n\n\n  function makePaths(locations) {\n    var rigid = arguments[1] === undefined ? false : arguments[1];\n    console.assert(Array.isArray(locations), \"locations is not an Array\");\n\n    var promises = [];\n    for (var i = 0; i < locations.length - 1; i++) {\n      var start = locations[i], end = locations[i + 1], promise;\n\n      if (rigid) {\n        promise = start.equals(end) ? $q.when([start]) : $q.when([start, end]);\n      } else {\n        promise = DirectionsSvc.route([start, end])[\"catch\"]((function (start, end) {\n          return start.equals(end) ? $q.when([start]) : $q.when([start, end]);\n        }).bind(null, start, end));\n      }\n      promises.push(promise);\n    }\n\n    return $q.all(promises);\n  }\n\n\n\n  // Node functions\n  function addNodes(nodes, index, nodesToAdd) {\n    nodesToAdd = arrayify(nodesToAdd);\n    var node;for (var _lwkc9n6d2t9 = 0; _lwkc9n6d2t9 < nodesToAdd.length; _lwkc9n6d2t9++) {\n      node = nodesToAdd[_lwkc9n6d2t9];\n      node._marker.setMap(MapSvc.map);\n    }\n\n    return splice(nodes, index, 0, nodesToAdd);\n  }\n  var addNode = addNodes;\n\n  function removeNodes(nodes, index) {\n    var removeLength = arguments[2] === undefined ? 1 : arguments[2];\n    var removed = splice(nodes, index, removeLength);\n    var node;for (var _ml54ld0wwmi = 0; _ml54ld0wwmi < removed.length; _ml54ld0wwmi++) {\n      node = removed[_ml54ld0wwmi];\n      node._marker.setMap(null);\n    }\n\n    return removed;\n  }\n  var removeNode = removeNodes;\n\n  function changeNode(node, changes) {\n    console.assert(typeof node === \"object\" && typeof changes === \"object\", \"Invalid parameters\");\n    change(node, changes);\n    for (var key in changes) {\n      switch (key) {\n        case \"lat\":\n        case \"lng\":\n          node._marker.setPosition(makePoint(node));\n          break;\n      }\n    }\n  }\n\n  function duplicateNode(drawing, node) {\n    return makeNode(drawing.colorIndex, makePoint(node), node.index);\n  }\n\n\n\n  function shiftIndexOfNodes(nodes, index, shifts) {\n    var nodeArray = arrayify(nodes), shift = 0, i = 0;\n\n    if (Array.isArray(shifts)) {\n      for (i = 0; i + index < nodeArray.length && i < shifts.length; i++) {\n        shift += shifts[i];\n        nodeArray[index + i].index += shift;\n      }\n    } else {\n      shift = shifts;\n    }\n    for (i += index; i < nodeArray.length; i++) {\n      nodeArray[i].index += shift;\n    }\n  }\n\n  function setIndexOfNodes(nodes, index, value) {\n    var nodeArray = arrayify(nodes);\n    for (var i = index; i < nodeArray.length; i++) {\n      nodeArray[i].index = value;\n    }\n  }\n\n  function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n    var nodeBefore = nodes[index - 1], indexForNode = 0;\n\n    if (nodeBefore) {\n      indexForNode = nodeBefore.index;\n    }\n    setIndexOfNodes(nodesToAdd, 0, indexForNode);\n  }\n\n\n\n  function rangeOfPathAroundNodes(nodes, start, end) {\n    var range = {\n      start: null,\n      end: null,\n      length: null,\n      nodeStart: null,\n      nodeEnd: null,\n      nodeLength: null,\n      lastNode: false,\n      firstNode: false\n    };\n\n    var nodeRange = nodes.slice(start, end), firstNodeInRange = nodeRange[0], lastNodeInRange = nodeRange[nodeRange.length - 1], nodeBeforeRange = nodes[start - 1], nodeAfterRange = nodes[end];\n\n    if (!nodeBeforeRange) {\n      range.firstNode = true;\n    }\n    if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n      range.start = nodeBeforeRange.index;\n      range.nodeStart = start;\n    } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n      range.start = firstNodeInRange.index;\n      range.nodeStart = start + 1;\n    } else {\n      range.start = 0;\n      range.nodeStart = 0;\n    }\n\n    if (!nodeAfterRange) {\n      range.lastNode = true;\n    }\n    if (nodeAfterRange && nodeAfterRange.index !== null) {\n      range.end = nodeAfterRange.index;\n      range.nodeEnd = end;\n    } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n      range.end = lastNodeInRange.index;\n      range.nodeEnd = end - 1;\n    } else {\n      range.end = range.start;\n      range.nodeEnd = range.nodeStart;\n    }\n\n    range.nodeLength = range.nodeEnd - range.nodeStart;\n    range.length = range.end - range.start;\n\n    return range;\n  }\n\n  function rangeOfPathAroundNode(nodes, index) {\n    return rangeOfPathAroundNodes(nodes, index, index);\n  }\n\n\n\n  function makePathsAroundNodes(nodes, start, end, rigid) {\n    var points = [], nodeRange = nodes.slice(start, end), nodeBefore = nodes[start - 1], nodeAfter = nodes[end], node;\n\n    if (nodeBefore) {\n      points.push(makePoint(nodeBefore));\n    }\n    for (var _19v9g3hxgvi = 0; _19v9g3hxgvi < nodeRange.length; _19v9g3hxgvi++) {\n      node = nodeRange[_19v9g3hxgvi];\n      points.push(makePoint(node));\n    }\n    if (nodeAfter) {\n      points.push(makePoint(nodeAfter));\n    }\n\n    if (points.length < 2) {\n      points.push(points[0]); // Duplicate first point; makePaths needs at least two points\n    }\n\n    return makePaths(points, rigid);\n  }\n\n  function makePathsAroundNode(nodes, index, rigid) {\n    return makePathsAroundNodes(nodes, index, index, rigid);\n  }\n\n\n\n  function alignNodesWithPath(path, nodes) {\n    var latLng;\n\n    var node;for (var _ptojcb7f1or = 0; _ptojcb7f1or < nodes.length; _ptojcb7f1or++) {\n      node = nodes[_ptojcb7f1or];\n      latLng = path[node.index];\n      console.assert(latLng, \"latLng is not defined\");\n      changeNode(node, {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      });\n    }\n  }\n\n\n\n  function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n    var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n\n    if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n      return;\n    }\n    var path = drawing._poly.getPath().getArray(), pathRemoveLength = range.length;\n\n    // Special case to remove last point if lastNode\n    if (range.lastNode) {\n      pathRemoveLength++;\n    }\n\n    removePoints(path, range.start, pathRemoveLength);\n\n    shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n    var removedNodes = removeNodes(drawing.nodes, index, nodeRemoveLength);\n\n    drawing._poly.setPath(path);\n\n    $rootScope.$broadcast(\"drawing:change\");\n\n    return removedNodes;\n  }\n\n  function addNodesAndTheirPathsToDrawing(drawing, index, newNodes, newPaths) {\n    var polyPath = drawing._poly.getPath().getArray(), nodes = drawing.nodes;\n\n    var shifts = [];\n    var path, lastPoint, i, pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length), pathIndex = pathRange.start;\n\n    for (var _oaj0blw61or = 0; _oaj0blw61or < newPaths.length; _oaj0blw61or++) {\n      path = newPaths[_oaj0blw61or];\n      lastPoint = path.pop();\n\n      // Adds new path\n      addPoints(polyPath, pathIndex, path);\n\n      pathIndex += path.length;\n      shifts.push(path.length);\n    }\n\n    var alignLength = newPaths.length;\n    shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n\n    if (pathRange.lastNode && lastPoint) {\n      // If lastNode is involved, put lastPoint back\n      polyPath.push(lastPoint);\n      alignLength++;\n    }\n\n    var nodesToAlign = nodes.slice(index, index + alignLength);\n    alignNodesWithPath(polyPath, nodesToAlign);\n\n    drawing._poly.setPath(polyPath);\n\n    $rootScope.$broadcast(\"drawing:change\");\n\n    return polyPath;\n  }\n\n\n\n  function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength) {\n    var nodesToAdd = arguments[3] === undefined ? [] : arguments[3];\n    var pathsToAdd = arguments[4] === undefined ? null : arguments[4];\n    return queue((function (drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n      var removedNodes = removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n\n      if (nodesToAdd === null) {\n        nodesToAdd = removedNodes;\n      } else {\n        nodesToAdd = arrayify(nodesToAdd);\n      }\n\n      setInitialIndexOfNodes(drawing.nodes, index, nodesToAdd);\n      addNodes(drawing.nodes, index, nodesToAdd);\n\n      var promise;\n      if (pathsToAdd) {\n        promise = $q.when(pathsToAdd);\n      } else {\n        promise = makePathsAroundNodes.bind(null, drawing.nodes, index, index + nodesToAdd.length, drawing.rigid)();\n      }\n\n      return promise.then((function (drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n        return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n      }).bind(null, drawing, index, nodeRemoveLength, nodesToAdd));\n    }).bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd));\n  }\n\n\n\n  /*\n  *** PUBLIC API ***\n  */\n  var internalQueue = $q.when();\n  function queue() {\n    var steps = arguments[0] === undefined ? [] : arguments[0];\n    // Keeps path operations in correct order\n    console.assert(steps !== undefined, \"steps cannot be undefined\");\n\n    steps = arrayify(steps);\n    var step;for (var _di3hqpeewmi = 0; _di3hqpeewmi < steps.length; _di3hqpeewmi++) {\n      step = steps[_di3hqpeewmi];\n      internalQueue = internalQueue.then(step);\n    }\n\n    return internalQueue;\n  }\n  self.queue = queue;\n\n\n\n  // Drawing functions\n  function makeDrawing(colorIndex, rigid) {\n    var fill = arguments[2] === undefined ? false : arguments[2];\n    var poly;\n\n    if (fill) {\n      poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n    } else {\n      poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n    }\n    return {\n      colorIndex: colorIndex,\n      rigid: rigid,\n      fill: fill,\n      _poly: poly,\n      nodes: []\n    };\n  }\n  self.makeDrawing = makeDrawing;\n\n  function addDrawings(drawings, index, drawingsToAdd) {\n    return queue(splice.bind(null, drawings, index, 0, drawingsToAdd));\n  }\n  self.addDrawings = self.addDrawing = addDrawings;\n\n  function removeDrawings(drawings, index, removeLength) {\n    return queue((function (drawings, index, removeLength) {\n      var removedDrawings = splice(drawings, index, removeLength);\n      for (var i = 0; i < removedDrawings.length; i++) {\n        var removedDrawing = removedDrawings[i];\n        removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n        removedDrawing._poly.setMap(null);\n      }\n    }).bind(null, drawings, index, removeLength));\n  }\n  self.removeDrawings = self.removeDrawing = removeDrawings;\n\n  function changeDrawing(drawing, changes) {\n    change(drawing, changes);\n\n    for (var key in changes) {\n      switch (key) {\n        case \"colorIndex\":\n        case \"fill\":\n          var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n          drawing._poly.setOptions(options);\n          break;\n        case \"rigid\":\n\n\n          break;\n      }\n    }\n\n    $rootScope.$broadcast(\"drawing:change\");\n  }\n\n\n\n  function makeNode(colorIndex, latLng) {\n    var index = arguments[2] === undefined ? null : arguments[2];\n    var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n\n    return {\n      lat: latLng.lat(),\n      lng: latLng.lng(),\n      index: index,\n      _marker: marker\n    };\n  }\n  self.makeNode = makeNode;\n\n  function addNodesToDrawing(drawing, index) {\n    var nodesToAdd = arguments[2] === undefined ? [] : arguments[2];\n    var pathsToAdd = arguments[3] === undefined ? null : arguments[3];\n    return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n  }\n  self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n\n  function removeNodesFromDrawing(drawing, index, removeLength) {\n    var pathsToAdd = arguments[3] === undefined ? null : arguments[3];\n    return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n  }\n  self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n\n  function changeNodeOfDrawing(drawing, index, changes) {\n    var pathsToAdd = arguments[3] === undefined ? null : arguments[3];\n    queue((function (drawing, index, changes) {\n      changeNode(drawing.nodes[index], changes);\n    }).bind(null, drawing, index, changes));\n\n    return spliceNodesIntoDrawing.bind(null, drawing, index, 1, null, pathsToAdd)();\n  }\n  self.changeNodeOfDrawing = changeNodeOfDrawing;\n\n\n\n  function makeIcon(colorIndex, options) {\n    var color = ColorSvc.colors[colorIndex];\n    var icon = {\n      path: MapSvc.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: \"#\" + ColorSvc.convert.rgba(color).to.hex24(),\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n    change(icon, options);\n\n    return icon;\n  }\n\n  function makeMarkerOptions(colorIndex, latLng, options) {\n    var markerOptions = {\n      clickable: true,\n      crossOnDrag: false,\n      cursor: \"pointer\",\n      draggable: true,\n      flat: true,\n      icon: makeIcon(colorIndex),\n      map: MapSvc.map,\n      position: latLng\n    };\n    change(markerOptions, options);\n\n    return markerOptions;\n  }\n\n  function makePolyOptions(colorIndex, fill) {\n    var value = {\n      clickable: !fill,\n      draggable: false,\n      editable: false,\n      map: MapSvc.map\n    };\n\n    var color = angular.copy(ColorSvc.colors[colorIndex]);\n    color.a = 0.5;\n\n    if (fill) {\n      value.fillColor = rgbaColorToString(color);\n      value.fillOpacity = 1;\n      value.strokeWeight = 0;\n    } else {\n      value.strokeColor = rgbaColorToString(color);\n      value.strokeWeight = color.weight;\n    }\n\n    return value;\n  }\n\n\n\n  function drawingsToGeoJson(drawings) {\n    var geoJson = {\n      type: \"FeatureCollection\"\n    };\n\n    geoJson.features = drawings.map(function (drawing) {\n      var feature = {\n        type: \"Feature\"\n      };\n\n      var polyPath = drawing._poly.getPath().getArray();\n      var coordinates = polyPath.map(function (latLng) {\n        return [latLng.lng(), latLng.lat()];\n      });\n\n      feature.geometry = {\n        type: drawing.fill ? \"Polygon\" : \"LineString\",\n        coordinates: drawing.fill ? [coordinates] : coordinates\n      };\n\n      var colorIndex = drawing.colorIndex;\n      var rigid = drawing.rigid;\n      var fill = drawing.fill;\n      var nodes = drawing.nodes;\n      feature.properties = { colorIndex: colorIndex, rigid: rigid, fill: fill };\n      feature.properties.nodes = nodes.map(function (node) {\n        var lat = node.lat;\n        var lng = node.lng;\n        var index = node.index;\n        return { lat: lat, lng: lng, index: index };\n      });\n      return feature;\n    });\n\n    return JSON.stringify(geoJson);\n  }\n  self.drawingsToGeoJson = drawingsToGeoJson;\n\n  function geoJsonToDrawings(geoJsonString) {\n    console.assert(typeof geoJsonString === \"string\", \"geoJson must be a string\");\n\n    var drawings = [];\n    var geoJson = JSON.parse(geoJsonString);\n    var drawings = geoJson.features.map(function (feature, i) {\n      var colorIndex = feature.properties.colorIndex;\n      var rigid = feature.properties.rigid;\n      var fill = feature.properties.fill;\n      var nodes = feature.properties.nodes;\n      var drawing = makeDrawing(colorIndex, rigid, fill);\n      addDrawings(drawings, i, drawing);\n\n      var nodesToAdd = nodes.map(function (node) {\n        var latLng = new MapSvc.LatLng(node.lat, node.lng);\n        return makeNode.bind(null, drawing.colorIndex, latLng, node.index)();\n      });\n\n      var coordinates;\n      if (fill) {\n        coordinates = feature.geometry.coordinates[0];\n      } else {\n        coordinates = feature.geometry.coordinates;\n      }\n      var polyPath = coordinates.map(function (coordinate) {\n        return new MapSvc.LatLng(coordinate[1], coordinate[0]);\n      });\n\n      var pathsToAdd = [];\n      for (var i = 0; i < nodesToAdd.length - 1; i++) {\n        var nodeAt = nodesToAdd[i], nodeAfter = nodesToAdd[i + 1], pathChunk = polyPath.slice(nodeAt.index, nodeAfter.index + 1);\n\n        pathsToAdd.push(pathChunk);\n      }\n\n      addNodesToDrawing.bind(null, drawing, 0, nodesToAdd, pathsToAdd)();\n\n      return drawing;\n    });\n\n    return drawings;\n  }\n  self.geoJsonToDrawings = geoJsonToDrawings;\n\n\n\n  function rgbaColorToString(rgba) {\n    return \"rgba(\" + Math.round(rgba.r * 255) + \",\" + Math.round(rgba.g * 255) + \",\" + Math.round(rgba.b * 255) + \",\" + rgba.a + \")\";\n  }\n\n\n\n  var activeMarker = new MapSvc.Marker();\n  function showActiveNode(colorIndex, node) {\n    var color = ColorSvc.colors[colorIndex];\n    activeMarker.setOptions(makeMarkerOptions(colorIndex, makePoint(node), {\n      clickable: false,\n      draggable: false,\n      icon: makeIcon(colorIndex, {\n        scale: 20,\n        strokeWeight: 2,\n        strokeOpacity: 0.5,\n        fillColor: \"#\" + ColorSvc.convert.rgba(color).to.hex24(),\n        fillOpacity: 0.125\n      })\n    }));\n  }\n  self.showActiveNode = showActiveNode;\n\n  function hideActiveNode() {\n    activeMarker.setMap(null);\n  }\n  self.hideActiveNode = hideActiveNode;\n\n\n\n  self.forceCreateNewDrawing = false;\n\n  self.shouldCreateNewDrawing = function () {\n    if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n      return true;\n    }\n    var latestDrawing = self.drawings[self.drawings.length - 1];\n    var value = latestDrawing && (latestDrawing.colorIndex !== ColorSvc.activeColorIndex() || latestDrawing.rigid !== ShapeSvc.rigid() || latestDrawing.fill !== ShapeSvc.fill());\n    return value;\n  };\n\n  self.drawings;\n\n  self.activeDrawingIndex = -1;\n})\n// Controllers\n.controller(\"DrawingCtrl\", function ($scope, $localStorage, $timeout, DrawingSvc, ColorSvc, ShapeSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n\n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n\n  // Load last saved drawings from geoJson in localStorage\n  var storedDrawings = DrawingSvc.geoJsonToDrawings(localStorage.geoJson || DrawingSvc.drawingsToGeoJson(drawings));\n  var storedDrawing;for (var _c1agjwtgldi = 0; _c1agjwtgldi < storedDrawings.length; _c1agjwtgldi++) {\n    storedDrawing = storedDrawings[_c1agjwtgldi];\n    drawings.push(storedDrawing);\n  }\n\n  function activeDrawingIndex(value) {\n    if (typeof value === \"number\") {\n      DrawingSvc.activeDrawingIndex = value;\n    } else {\n      return DrawingSvc.activeDrawingIndex;\n    }\n  }\n  activeDrawingIndex(drawings.length - 1);\n  var queue = DrawingSvc.queue;\n  // $scope.$storage = DrawingSvc.loadDrawings();\n\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n\n    var rigid = ShapeSvc.rigid(), fill = ShapeSvc.fill();\n\n    var createNewDrawing = DrawingSvc.shouldCreateNewDrawing();\n    if (createNewDrawing) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex(activeDrawingIndex() + 1);\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex(), newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n\n    queue((function (drawingIndex, colorIndex, latLng, createNewDrawing) {\n      var drawing = drawings[drawingIndex];\n      var newNode = DrawingSvc.makeNode(colorIndex, latLng);\n      var nodeIndex = drawing.nodes.length;\n\n      DrawingSvc.addNodeToDrawing(drawing, nodeIndex, newNode);\n\n      HistorySvc.add({\n        undo: (function (drawings, drawing, drawingIndex, nodeIndex, didCreateNewDrawing) {\n          DrawingSvc.removeNodeFromDrawing(drawing, nodeIndex, 1);\n\n          if (didCreateNewDrawing) {\n            DrawingSvc.removeDrawing(drawings, drawingIndex, 1);\n            activeDrawingIndex(drawingIndex - 1);\n          }\n        }).bind(null, drawings, drawing, drawingIndex, nodeIndex, createNewDrawing),\n\n        redo: (function (drawings, drawing, drawingIndex, nodeIndex, newNode, didCreateNewDrawing) {\n          if (didCreateNewDrawing) {\n            DrawingSvc.addDrawing(drawings, drawingIndex, drawing);\n            activeDrawingIndex(drawingIndex + 1);\n          }\n\n          DrawingSvc.addNodeToDrawing(drawing, nodeIndex, newNode);\n        }).bind(null, drawings, drawing, drawingIndex, nodeIndex, newNode, createNewDrawing)\n      });\n    }).bind(null, activeDrawingIndex(), colorIndex, param.latLng, createNewDrawing));\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0], drawing = drawings[drawingIndex], latLng = event.latLng;\n\n    queue((function (drawing, nodeIndex, latLng) {\n      var originalNode = drawing.nodes[nodeIndex], originalPosition = {\n        lat: originalNode.lat,\n        lng: originalNode.lng\n      }, newPosition = {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      };\n      DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, newPosition);\n\n      HistorySvc.add({\n        undo: (function (drawing, nodeIndex, originalPosition) {\n          DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, originalPosition);\n        }).bind(null, drawing, nodeIndex, originalPosition),\n\n        redo: (function (drawing, nodeIndex, newPosition) {\n          DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, newPosition);\n        }).bind(null, drawing, nodeIndex, newPosition)\n      });\n    }).bind(null, drawing, nodeIndex, latLng));\n  }\n\n  $scope.$on(\"map:click\", addNode);\n  $scope.$on(\"action:clear\", function ($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex(-1);\n  });\n\n  $scope.$on(\"drawing:change\", function () {\n    localStorage.geoJson = DrawingSvc.drawingsToGeoJson(drawings);\n\n    if (drawings.length > 0 && drawings[drawings.length - 1].nodes.length > 0) {\n      var latestNodes = drawings[drawings.length - 1].nodes, latestNode = latestNodes[latestNodes.length - 1];\n\n      DrawingSvc.showActiveNode(ColorSvc.activeColorIndex(), latestNode);\n    } else {\n      DrawingSvc.hideActiveNode();\n    }\n  });\n\n  $scope.marker = {\n    click: function ($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {\n    click: function ($params) {\n      addNode(undefined, $params[0]);\n    }\n  };\n});\n\nangular.module(\"bndry.geo\", [\"bndry.map\"]).service(\"GeolocationSvc\", function ($q) {\n  this.getLocation = function () {\n    var deferred = $q.defer();\n\n    if (\"geolocation\" in navigator) {\n      navigator.geolocation.getCurrentPosition(function (position) {\n        deferred.resolve(position);\n      }, function (error) {\n        deferred.reject(error);\n      });\n    } else {\n      deferred.reject(false);\n    }\n\n    return deferred.promise;\n  };\n}).service(\"GeocodeSvc\", function ($q, MapSvc) {\n  this.geocode = function (location, bounds) {\n    var geocoder = new MapSvc.Geocoder();\n    var deferred = $q.defer();\n\n    var request = {};\n\n    if (bounds) {\n      request.bounds = location;\n    } else {\n      request.location = location;\n    }\n\n\n    geocoder.geocode(request, function (results, status) {\n      if (status === MapSvc.GeocoderStatus.OK) {\n        deferred.resolve(results);\n      } else {\n        deferred.reject(status);\n      }\n    });\n\n    return deferred.promise;\n  };\n});\n\n// istanbul ignore next\nangular.module(\"bndry.history\", []).service(\"HistorySvc\", function () {\n  /* jshint quotmark:true */\n  /* jshint camelcase:false */\n  /*\n  Simple Javascript undo and redo.\n  https://github.com/ArthurClemens/Javascript-Undo-Manager\n  */\n  \"use strict\";\n\n  var commands = [], index = -1, isExecuting = false, callback,\n\n  // functions\n  execute;\n\n  execute = function (command, action) {\n    if (!command || typeof command[action] !== \"function\") {\n      return this;\n    }\n    isExecuting = true;\n\n    command[action]();\n\n    isExecuting = false;\n    return this;\n  };\n\n  return {\n\n    /*\n    Add a command to the queue.\n    */\n    add: function (command) {\n      if (isExecuting) {\n        return this;\n      }\n      // if we are here after having called undo,\n      // invalidate items higher on the stack\n      commands.splice(index + 1, commands.length - index);\n\n      commands.push(command);\n\n      // set the current index to the end\n      index = commands.length - 1;\n      if (callback) {\n        callback();\n      }\n      return this;\n    },\n\n    /*\n    Pass a function to be called on undo and redo actions.\n    */\n    setCallback: function (callbackFunc) {\n      callback = callbackFunc;\n    },\n\n    /*\n    Perform undo: call the undo function at the current index and decrease the index by 1.\n    */\n    undo: function () {\n      var command = commands[index];\n      if (!command) {\n        return this;\n      }\n      execute(command, \"undo\");\n      index -= 1;\n      if (callback) {\n        callback();\n      }\n      return this;\n    },\n\n    /*\n    Perform redo: call the redo function at the next index and increase the index by 1.\n    */\n    redo: function () {\n      var command = commands[index + 1];\n      if (!command) {\n        return this;\n      }\n      execute(command, \"redo\");\n      index += 1;\n      if (callback) {\n        callback();\n      }\n      return this;\n    },\n\n    /*\n    Clears the memory, losing all stored states. Reset the index.\n    */\n    clear: function () {\n      var prev_size = commands.length;\n\n      commands = [];\n      index = -1;\n\n      if (callback && prev_size > 0) {\n        callback();\n      }\n    },\n\n    hasUndo: function () {\n      return index !== -1;\n    },\n\n    hasRedo: function () {\n      return index < commands.length - 1;\n    },\n\n    getCommands: function () {\n      return commands;\n    }\n  };\n});\n\n/*\nLICENSE\nThe MIT License\nCopyright (c) 2010-2014 Arthur Clemens, arthurclemens@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: \nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n\nangular.module(\"bndry.image\", [\"ngStorage\", \"bndry.map\", \"bndry.drawing\", \"bndry.color\"]).service(\"ImageSvc\", function ($rootScope, $http, $document, $localStorage, MapSvc, DrawingSvc, ColorSvc) {\n  var self = this;\n\n  self.pxSize = function (maxWidth, maxHeight, ratio) {\n    return {\n      ratio: ratio,\n      width: ratio >= 1 ? maxWidth : Math.round(ratio * maxWidth),\n      height: ratio < 1 ? maxHeight : Math.round(1 / ratio * maxHeight)\n    };\n  };\n  self.generateUrl = function () {\n    if (!DrawingSvc.drawings) {\n      return;\n    }\n\n    var path = \"https://maps.googleapis.com/maps/api/staticmap\";\n\n    var params = [];\n\n    // Generate style from map styling and drawings\n    var rule;for (var _9icdm3d6lxr = 0; _9icdm3d6lxr < $localStorage.style.length; _9icdm3d6lxr++) {\n      rule = $localStorage.style[_9icdm3d6lxr];\n      var urlRule = [];\n\n      // Add selectors to urlRule\n      if (\"featureType\" in rule && rule.featureType !== \"all\") {\n        urlRule.push(\"feature:\" + rule.featureType);\n      }\n      if (\"elementType\" in rule && rule.elementType !== \"all\") {\n        urlRule.push(\"element:\" + rule.elementType);\n      }\n\n      // Loop through every styler, add to urlRule\n      var styler;for (var _s7v4x2h85mi = 0; _s7v4x2h85mi < rule.stylers.length; _s7v4x2h85mi++) {\n        styler = rule.stylers[_s7v4x2h85mi];\n        for (var key in styler) {\n          var value = styler[key];\n\n          if (key === \"color\") {\n            value = \"0x\" + value.substring(1);\n          }\n\n          urlRule.push(key + \":\" + value);\n        }\n      }\n\n      var urlParamText = urlRule.join(\"|\");\n\n      // Add urlParamText to params if not empty string\n      if (urlParamText !== \"\") {\n        params.push(\"style=\" + urlParamText);\n      }\n    }\n\n    // Generate paths from drawings\n    var drawing, urlPath, polyPath, encodedPath, color, hex;\n    var bounds = new MapSvc.LatLngBounds();\n    for (var i = 0; i < DrawingSvc.drawings.length; i++) {\n      urlPath = [];\n      drawing = DrawingSvc.drawings[i];\n      polyPath = drawing._poly.getPath().getArray();\n\n      for (var j = 0; j < polyPath.length; j++) {\n        bounds.extend(polyPath[j]);\n      }\n\n      encodedPath = MapSvc.geometry.encoding.encodePath(polyPath);\n      color = $localStorage.colors[drawing.colorIndex];\n      hex = \"0x\" + ColorSvc.convert.rgba(color).to.hex32();\n\n      // If drawing is polygon, use 'fillcolor'\n      if (drawing.fill) {\n        urlPath.push(\"fillcolor:\" + hex);\n        urlPath.push(\"weight:0\");\n      } else {\n        urlPath.push(\"color:\" + hex);\n        urlPath.push(\"weight:\" + color.weight);\n      }\n      urlPath.push(\"enc:\" + encodedPath);\n\n      urlPath = urlPath.join(\"|\");\n\n      // Add urlPath to params if not empty string\n      if (urlPath) {\n        params.push(\"path=\" + urlPath);\n      }\n    }\n\n    var northEast = bounds.getNorthEast();\n    var southWest = bounds.getSouthWest();\n    var computeHeading = MapSvc.geometry.spherical.computeHeading;\n    var heading = Math.abs(computeHeading(northEast, southWest) + computeHeading(southWest, northEast)) / 2;\n\n    var ratio = 45 <= heading && heading < 135 ? 3.5 / 5 : 5 / 3.5;\n    var pxSize = self.pxSize(640, 640, ratio);\n\n    // Landscape\n    params.push(\"size=\" + pxSize.height + \"x\" + pxSize.width);\n\n    params.push(\"format=jpg\");\n    params.push(\"scale=2\");\n    params.push(\"sensor=true\");\n\n    return encodeURI(path + \"?\" + params.join(\"&\"));\n  };\n  self.generatePdf = function (locality, number, imageUrl) {\n    if (!imageUrl) {\n      imageUrl = self.generateUrl();\n    }\n\n    var legend = [];\n    var color;for (var _errpaw6ogvi = 0; _errpaw6ogvi < ColorSvc.colors.length; _errpaw6ogvi++) {\n      color = ColorSvc.colors[_errpaw6ogvi];\n      var entry = {\n        name: color.name,\n        label: color.label,\n        color: \"#\" + ColorSvc.convert.rgba(color).to.hex24()\n      };\n      legend.push(entry);\n    }\n    var data = {\n      serif: true,\n      locality: locality,\n      notes: \"See attached form for Do Not Calls.\\nAdd new Do Not Calls as you find them.\",\n      legend: legend,\n      number: number,\n      image: imageUrl\n    };\n\n    // Ugly hack to force browser to download file\n    var form = document.createElement(\"form\");\n    form.style = \"display: none;\";\n    form.enctype = \"x-www-form-urlencoded\";\n    form.action = \"http://boundariesapp.herokuapp.com/pdf\";\n    form.method = \"POST\";\n\n    var input = document.createElement(\"input\");\n    input.name = \"json\";\n    input.type = \"text\";\n    input.value = angular.toJson(data);\n\n    form.appendChild(input);\n\n    document.body.appendChild(form);\n    form.submit();\n    document.body.removeChild(form);\n\n    $rootScope.$emit(\"territory:save\", {\n      locality: locality,\n      number: number,\n      drawings: DrawingSvc.drawingsToGeoJson(DrawingSvc.drawings)\n    });\n  };\n}).controller(\"ImageCtrl\", function ($scope, ImageSvc) {\n  $scope.data = {\n    locality: \"\",\n    number: \"\"\n  };\n\n  $scope.downloadPdf = function () {\n    var locality = prompt(\"Locality (for example, the name of the city)\", \"\");\n    if (!locality) {\n      return;\n    }\n    var number = prompt(\"Territory number (for example, MR-1056)\", \"\");\n    if (!number) {\n      return;\n    }\n\n    ImageSvc.generatePdf(locality, number, ImageSvc.generateUrl());\n  };\n});\n\n/* global google */\n\nangular.module(\"bndry.map\", [\"ngStorage\"])\n\n// MapSvc encapsulates google.maps, making it easier to mock for tests.\n.service(\"MapSvc\", function ($rootScope) {\n  function makeIcon(color) {\n    return {\n      path: self.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: color,\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n  }\n\n  function makeMarkerOptions(lat, lng, color) {\n    var clickable = false, cursor = \"pointer\", draggable = false;\n    return {\n      clickable: clickable,\n      crossOnDrag: false,\n      cursor: cursor,\n      draggable: draggable,\n      flat: true,\n      icon: makeIcon(color),\n      map: self.map,\n      position: new self.LatLng(lat, lng)\n    };\n  }\n\n  function addListener(eventName) {\n    self.map.addListener(eventName, function (mouseEvent) {\n      $rootScope.$broadcast(\"map:\" + eventName, mouseEvent);\n    });\n  }\n\n  var self = this;\n\n  angular.extend(self, google.maps);\n  self.map = new self.Map(document.getElementById(\"map_canvas\"));\n  self.placesSvc = new self.places.PlacesService(self.map);\n  self.autocompleteSvc = new self.places.AutocompleteService();\n\n  var events = [\"bounds_changed\", \"center_changed\", \"click\", \"dblclick\", \"drag\", \"dragend\", \"dragstart\", \"heading_changed\", \"idle\", \"maptypeid_changed\", \"mousemove\", \"mouseout\", \"mouseover\", \"projection_changed\", \"resize\", \"rightclick\", \"tilesloaded\", \"tilt_changed\", \"zoom_changed\"];\n\n  events.forEach(addListener);\n})\n\n// Map controller, mainly for event handling\n.controller(\"MapCtrl\", function ($scope, $rootScope, $localStorage, MapSvc) {\n  // Default values for lat, lng, zoom\n  $localStorage.$default({\n    lat: 0,\n    lng: 0,\n    zoom: 10,\n    mapTypeId: MapSvc.MapTypeId.ROADMAP,\n    style: [{\n      stylers: [{\n        visibility: \"off\"\n      }]\n    }, {\n      featureType: \"landscape\",\n      stylers: [{\n        visibility: \"on\"\n      }, {\n        color: \"#ffffff\"\n      }]\n    }, {\n      featureType: \"road\",\n      stylers: [{\n        visibility: \"on\"\n      }]\n    }, {\n      elementType: \"geometry.fill\",\n      stylers: [{\n        color: \"#ffffff\"\n      }]\n    }, {\n      featureType: \"road\",\n      elementType: \"geometry.stroke\",\n      stylers: [{\n        color: \"#808080\"\n      }]\n    }, {\n      elementType: \"labels.text.stroke\",\n      stylers: [{\n        color: \"#ffffff\"\n      }]\n    }, {\n      elementType: \"labels.text.fill\",\n      stylers: [{\n        color: \"#000000\"\n      }]\n    }, {\n      featureType: \"water\",\n      stylers: [{\n        visibility: \"on\"\n      }, {\n        color: \"#40bfbf\"\n      }]\n    }, {\n      featureType: \"water\",\n      elementType: \"labels.text.stroke\",\n      stylers: [{\n        color: \"#ffffff\"\n      }]\n    }, {\n      featureType: \"road.local\",\n      elementType: \"geometry\",\n      stylers: [{\n        color: \"#dfdfdf\"\n      }]\n    }, {\n      featureType: \"road.local\",\n      elementType: \"geometry.stroke\",\n      stylers: [{\n        visibility: \"off\"\n      }]\n    }, {\n      featureType: \"landscape.man_made\",\n      stylers: [{\n        visibility: \"off\"\n      }]\n    }]\n  });\n\n  $scope.$on(\"map:idle\", function () {\n    var center = MapSvc.map.getCenter();\n    var zoom = MapSvc.map.getZoom();\n\n    $localStorage.lat = center.lat();\n    $localStorage.lng = center.lng();\n    $localStorage.zoom = zoom;\n  });\n  $scope.$on(\"map:maptypeid_changed\", function () {\n    var mapTypeId = MapSvc.map.getMapTypeId();\n\n    $localStorage.mapTypeId = mapTypeId;\n  });\n\n  // Initialize map\n  var options = {\n    center: new MapSvc.LatLng($localStorage.lat, $localStorage.lng),\n    disableDefaultUI: true,\n    disableDoubleClickZoom: true,\n    draggableCursor: \"crosshair\",\n    draggingCursor: \"move\",\n    mapTypeId: $localStorage.mapTypeId,\n    zoomControl: true,\n    zoomControlOptions: {\n      position: MapSvc.ControlPosition.LEFT_CENTER\n    },\n    scaleControl: true,\n    zoom: $localStorage.zoom\n  };\n\n  MapSvc.map.setOptions(options);\n\n  var customMapStyle = new MapSvc.StyledMapType($localStorage.style, {\n    name: \"Custom\"\n  });\n  MapSvc.map.mapTypes.set(\"custom\", customMapStyle);\n}).controller(\"MapActionCtrl\", function ($scope, MapSvc) {\n  $scope.mapTypeId = MapSvc.MapTypeId;\n  $scope.setMapTypeId = function (mapTypeId) {\n    // if (mapTypeId in MapSvc.MapTypeId) {\n    //   console.log(mapTypeId, 'in MapSvc.mapTypeId');\n    //   mapTypeId = MapSvc.MapTypeId[mapTypeId];\n    // }\n\n    MapSvc.map.setMapTypeId(mapTypeId);\n  };\n  $scope.getMapTypeId = function () {\n    return MapSvc.map.getMapTypeId();\n  };\n});\n\n/* jslint camelcase: false */\n\nangular.module(\"bndry.search\", [\"ngSanitize\", \"bndry.map\"]).directive(\"focusOn\", function ($parse, $timeout) {\n  return {\n    restrict: \"A\",\n    link: function (scope, elem, attr) {\n      var value = $parse(attr.focusOn);\n\n      scope.$watch(value.bind(null, scope), function (newVal) {\n        if (newVal === undefined) {\n          return;\n        }\n\n        if (newVal) {\n          $timeout(function () {\n            elem[0].focus();\n            // scope.$apply();\n          });\n        } else {\n          $timeout(function () {\n            elem[0].blur();\n            // scope.$apply();\n          });\n        }\n      });\n      // attr.$observe('focusOn', function(newVal) {\n      //           if (newVal === undefined) {\n      //             return;\n      //           }\n      //\n      // \telem = elem[0];\n      //\n      // \tconsole.log(newVal ? 'Focus!' : 'Blur!');\n      //           if (newVal) {\n      //             $timeout(elem.focus.bind(elem), 10);\n      //           } else {\n      //             $timeout(elem.blur.bind(elem), 10);\n      //           }\n      // });\n    }\n  };\n}).service(\"SearchSvc\", function ($q, MapSvc) {\n  this.search = function (input) {\n    var deferred = $q.defer();\n\n    if (input.length <= 0) {\n      deferred.resolve([]);\n    } else {\n      var request = {\n        input: input\n      };\n\n      request.bounds = MapSvc.map.getBounds();\n\n      MapSvc.autocompleteSvc.getPlacePredictions(request, function (suggestions, status) {\n        if (status === MapSvc.places.PlacesServiceStatus.OK) {\n          deferred.resolve(suggestions);\n        } else if (status === MapSvc.places.PlacesServiceStatus.ZERO_RESULTS) {\n          deferred.reject(\"No Results\");\n        } else {\n          deferred.reject(\"An Error Occurred\");\n        }\n      });\n    }\n\n    return deferred.promise;\n  };\n\n  this.loadPlaceFromReference = function (reference) {\n    if (!reference) {\n      return;\n    }\n\n    if (reference) {\n      MapSvc.placesSvc.getDetails({\n        reference: reference\n      }, function (place, status) {\n        if (status === MapSvc.places.PlacesServiceStatus.OK) {\n          if (place.geometry.viewport) {\n            // fitBounds because panToBounds does not zoom out to show entire bounding box\n            MapSvc.map.fitBounds(place.geometry.viewport);\n          } else if (place.geometry.location) {\n            MapSvc.map.panTo(place.geometry.location);\n          }\n        }\n      });\n    }\n  };\n}).controller(\"SearchCtrl\", function ($scope, $sce, $sessionStorage, SearchSvc) {\n  function throttledSearch(newVal) {\n    // console.log('newVal:', newVal, 'queue:', queue, 'resolved:', resolved, 'last:', last);\n    if (!resolved) {\n      // console.log('Queueing newVal because not resolved. Exiting.', newVal);\n      queue = newVal;\n      return;\n    }\n\n    last = newVal;\n    resolved = false;\n\n    SearchSvc.search(newVal).then(formatSuggestions, errorMessage).then(function () {\n      resolved = true;\n\n      if (typeof queue === \"string\" && queue !== last) {\n        // console.log('Searching with queued value.', queue);\n        throttledSearch(queue);\n        queue = false;\n      }\n    });\n  }\n\n  function formatSuggestions(suggestions) {\n    for (var i = 0; i < suggestions.length; i++) {\n      var desc = suggestions[i].description;\n      suggestions[i].description = \"\";\n      var index = 0;\n\n      for (var j = 0; j < suggestions[i].matched_substrings.length; j++) {\n        var offset = suggestions[i].matched_substrings[j].offset;\n        var length = suggestions[i].matched_substrings[j].length;\n\n        suggestions[i].description += desc.slice(index, offset) + \"<b>\" + desc.substr(offset, length) + \"</b>\";\n\n        index = offset + length;\n      }\n      suggestions[i].description += desc.slice(index);\n      suggestions[i].description = \"<span>\" + suggestions[i].description + \"</span>\";\n      suggestions[i].description = $sce.trustAsHtml(suggestions[i].description);\n    }\n\n    $scope.suggestions = suggestions;\n  }\n  // Notifies user that no results were found\n\n  function errorMessage(message) {\n    if (typeof message === \"string\") {\n      $scope.suggestions = [{\n        description: $sce.trustAsHtml(\"<i>\" + message + \"</i>\"),\n        error: true\n      }];\n    }\n  }\n\n  var resolved = true, queue = false, last = \"\", focus = false;\n\n  $scope.query = \"\";\n  $scope.active = -1;\n\n  $scope.focus = function (value) {\n    if (value !== undefined) {\n      focus = Boolean(value);\n    }\n\n    return focus;\n  };\n\n\n  $scope.keydown = function (e) {\n    var enter = e.which === 13, up = e.which === 38, down = e.which === 40;\n\n    if (enter || up || down) {\n      e.preventDefault();\n    } else {\n      $scope.active = 0;\n      return;\n    }\n\n    if ($scope.suggestions[$scope.active]) {\n      if (enter) {\n        $scope.loadOnMap($scope.suggestions[$scope.active].reference);\n        $scope.focus(false);\n      } else if (up && $scope.active > -1) {\n        $scope.active--;\n      } else if (down && $scope.active < $scope.suggestions.length - 1) {\n        $scope.active++;\n      }\n    }\n  };\n\n  $scope.loadOnMap = function (reference) {\n    SearchSvc.loadPlaceFromReference(reference);\n    $scope.focus(false);\n  };\n\n  $scope.$watch(\"query\", throttledSearch);\n});\n\nangular.module(\"bndry.shape\", [\"ngStorage\"]).service(\"ShapeSvc\", function ($localStorage) {\n  this.rigid = function (value) {\n    if (value) {\n      $localStorage.rigid = value;\n    } else {\n      return $localStorage.rigid;\n    }\n  };\n  this.fill = function (value) {\n    if (value) {\n      $localStorage.fill = value;\n    } else {\n      return $localStorage.fill;\n    }\n  };\n}).controller(\"ShapeCtrl\", function ($scope, $localStorage) {\n  $scope.$storage = $localStorage;\n}).run(function ($localStorage) {\n  $localStorage.$default({\n    rigid: false,\n    fill: false\n  });\n});\n/* jshint camelcase: false */\n\nangular.module(\"bndry.status\", [\"bndry.map\", \"bndry.geo\"]).directive(\"statusBar\", function ($interval) {\n  return {\n    restrict: \"E\",\n    scope: {\n      hide: \"@\",\n      value: \"@\"\n    },\n    template: \"<div style=\\\"height: 100%; width: 100%; position: relative;\\\" ng-hide=\\\"indeterminate()\\\"><div class=\\\"bar\\\"></div></div>\",\n    link: function (scope) {\n      var pending = 0, finished = 0;\n\n      scope.$on(\"load:start\", function () {\n        pending++;\n      });\n      scope.$on(\"load:done\", function () {\n        finished++;\n        if (finished >= pending) {\n          pending = 0;\n          finished = 0;\n        }\n      });\n      scope.$on(\"load:error\", function () {\n        pending = 0;\n        finished = 0;\n        alert(\"Directions are not available for this location.\");\n      });\n\n      scope.indeterminate = function () {\n        return finished >= pending;\n      };\n      scope.percentage = function () {\n        return \"\" + (finished + 1) / (pending + 1) * 100 + \"%\";\n      };\n    }\n  };\n}).controller(\"StatusCtrl\", function ($scope, $timeout, MapSvc, GeocodeSvc) {\n  var locality = \"\";\n  var lastBounds;\n\n  $scope.locality = function () {\n    return locality;\n  };\n\n  $scope.$on(\"map:idle\", function () {\n    if (lastBounds && MapSvc.map.getBounds().equals(lastBounds)) {\n      return;\n    }\n    GeocodeSvc.geocode(MapSvc.map.getCenter()).then(function (results) {\n      var localityTypes = [\"locality\", \"administrative_area_level_1\", \"country\"];\n      locality = \"\";\n\n      if (results.length < 1) {\n        locality = \"Unknown Locality\";\n        return;\n      }\n      var type;for (var _hqvm9lfpqfr = 0; _hqvm9lfpqfr < localityTypes.length; _hqvm9lfpqfr++) {\n        type = localityTypes[_hqvm9lfpqfr];\n        var result;for (var _dtj3nkd42t9 = 0; _dtj3nkd42t9 < results.length; _dtj3nkd42t9++) {\n          result = results[_dtj3nkd42t9];\n          if (result.types.indexOf(type) > -1) {\n            locality = result.formatted_address;\n            return;\n          }\n        }\n      }\n    });\n  });\n});","/* global FastClick */\n\nangular\n.module('bndry', [\n  // 'ngTouch',\n  'ngStorage',\n  'ui.map',\n  'ngAnimate',\n  \n  'bndry.action',\n  'bndry.color',\n  'bndry.drawing',\n  'bndry.geo',\n  'bndry.history',\n  'bndry.image',\n  'bndry.map',\n  'bndry.shape',\n  'bndry.search',\n  'bndry.status'\n  // 'bndry.settings'\n])\n.config(function($compileProvider) {\n\t$compileProvider.debugInfoEnabled(false);\n})\n.directive('onActivate', function($parse) {\n\treturn {\n\t\trestrict: 'A',\n\t\tlink: function(scope, element, attr) {\n\t\t\tvar hasTouch = false;\n\t\t\tvar handler = $parse(attr.onActivate);\n\t\t\t\n\t\t\tvar promise;\n\t\t\tvar finished = 0;\n\t\t\tvar now, then;\n\t\t\t\n\t\t\tfunction whichAnimationEvent(){\n\t\t\t    var t;\n\t\t\t    var el = document.createElement('fakeelement');\n\t\t\t    var transitions = {\n\t\t\t      'animation':'animationend',\n\t\t\t      'OAnimation':'oAnimationEnd',\n\t\t\t      'MozAnimation':'animationend',\n\t\t\t      'WebkitAnimation':'webkitAnimationEnd'\n\t\t\t    }\n\n\t\t\t    for(t in transitions){\n\t\t\t        if( el.style[t] !== undefined ){\n\t\t\t            return transitions[t];\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction removeClassIfFinished(element, cName, total) {\n\t\t\t\tfinished++;\n\t\t\t\tif (finished >= total) {\n\t\t\t\t\telement.removeClass(cName);\n\t\t\t\t\tfinished = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\telement.on(whichAnimationEvent(), function() {\n\t\t\t\tremoveClassIfFinished(element, 'pressed', 2);\n\t\t\t});\n\t\t\t\n\t\t\telement.one('mousedown', function() {\n\t\t\t\tif (!hasTouch) {\n\t\t\t\t\tfinished = 0;\n\t\t\t\t\telement.addClass('pressed');\n\t\t\t\t\t\n\t\t\t\t\telement.on('mousedown', function() {\n\t\t\t\t\t\tfinished = 0;\n\t\t\t\t\t\telement.addClass('pressed');\n\t\t\t\t\t});\n\t\t\t\t\telement.on('mouseup', function() {\n\t\t\t\t\t\tremoveClassIfFinished(element, 'pressed', 2);\n\t\t\t\t\t});\n\t\t\t\t\telement.on('click', function(event) {\n\t\t\t\t\t\tconsole.log('Click!', event);\n\t\t\t\t\t\tscope.$evalAsync(function() {\n\t\t\t\t\t\t\thandler(scope, {$event:event});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\telement.one('touchstart', function(event) {\n\t\t\t\thasTouch = true;\n\t\t\t\tfinished = 0;\n\t\t\t\t\n\t\t\t\telement.addClass('pressed');\n\t\t\t\t\n\t\t\t\telement.on('touchstart', function() {\n\t\t\t\t\tfinished = 0;\n\t\t\t\t\telement.addClass('pressed');\n\t\t\t\t});\n\t\t\t\telement.on('touchend touchcancel', function() {\n\t\t\t\t\tremoveClassIfFinished(element, 'pressed', 2);\n\t\t\t\t});\n\t\t\t\telement.on('touchend', function(event) {\n\t\t\t\t\tscope.$evalAsync(function() {\n\t\t\t\t\t\thandler(scope, {$event:event});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n})\n.directive('ngXlinkHref', function() {\n  return {\n    priority: 99,\n    restrict: 'A',\n    link: function (scope, element, attr) {\n      var attrName = 'xlink:href';\n      attr.$observe('ngXlinkHref', function(value) {\n        if (!value)\n          return;\n\n        element.attr(attrName, value);\n      });\n    }\n  };\n})\n.directive('noScroll', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, elem) {\n      elem.on('touchstart wheel', function(e) {\n        e.preventDefault();\n      });\n    }\n  };\n})\n.controller('MasterCtrl', function($scope, $localStorage, $sce, ColorSvc, DrawingSvc) {\n  $scope.$storage = $localStorage;\n  \n  $scope.fillActiveColor = function() {\n    var hex = ColorSvc.convert.rgba(ColorSvc.activeColor()).to.hex24();\n    return `#${hex}`;\n  };\n  $scope.shouldCreateNewDrawing = DrawingSvc.shouldCreateNewDrawing;\n  $scope.toggleForceCreateNewDrawing = () => {\n    DrawingSvc.forceCreateNewDrawing = !DrawingSvc.forceCreateNewDrawing;\n  };\n  \n  $scope.sprite = function() {\n    return $sce.trustAsResourceUrl('#' + ($scope.$storage.rigid ? 'rigid' : 'flex') + '-' + ($scope.$storage.fill ? 'fill' : 'nofill'));\n  }\n  $scope.show = {\n    header: '',\n    footer: ''\n  };\n  \n  $scope.setShowHeader = function(show) {\n    if ($scope.show.header === show) {\n      $scope.show.header = '';\n    } else {\n      $scope.show.header = show;\n    }\n  };\n  $scope.setShowFooter = function(show) {\n    if ($scope.show.footer === show) {\n      $scope.show.footer = '';\n    } else {\n      $scope.show.footer = show;\n    }\n  };\n})\n.run(function() {\n  window.addEventListener('orientationchange', function() {\n    window.scrollTo(0,0);\n  });\n\t// FastClick.attach(document.body);\n});\n\n","(function() {\n  function initNgModules(element) {\n      var elements = [element],\n          moduleElements = [],\n          modules = [],\n          names = ['ng:module', 'ng-module', 'x-ng-module', 'data-ng-module', 'ng:modules', 'ng-modules', 'x-ng-modules', 'data-ng-modules'],\n          NG_MODULE_CLASS_REGEXP = /\\sng[:\\-]module[s](:\\s*([\\w\\d_]+);?)?\\s/;\n\n      function append(element) {\n          element && elements.push(element);\n      }\n\n      for(var i = 0; i < names.length; i++) {\n          var name = names[i];\n          names[i] = true;\n          append(document.getElementById(name));\n          name = name.replace(':', '\\\\:');\n          if (element.querySelectorAll) {\n              var elements2;\n              elements2 = element.querySelectorAll('.' + name);\n              for(var j = 0; j < elements2.length; j++) append(elements2[j]);\n              \n              elements2 = element.querySelectorAll('.' + name + '\\\\:');\n              for(var j = 0; j < elements2.length; j++) append(elements2[j]);\n              \n              elements2 = element.querySelectorAll('[' + name + ']');\n              for(var j = 0; j < elements2.length; j++) append(elements2[j]);\n          }\n      }\n\n      for(var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n\n          var className = ' ' + element.className + ' ';\n          var match = NG_MODULE_CLASS_REGEXP.exec(className);\n          if (match) {\n              moduleElements.push(element);\n              modules.push((match[2] || '').replace(/\\s+/g, ','));\n          } else {\n              if(element.attributes) {\n                  for (var attrName in element.attributes) {\n                      if(attrName == \"length\") continue;\n                      var attr = { name: attrName, value: element.attributes[attrName].nodeValue };\n                      \n                      if (names[attr.name]) {\n                          moduleElements.push(element);\n                          modules.push(attr.value);\n                      }\n                  }\n              }\n          }\n      }\n      \n      for(var i = 0; i < moduleElements.length; i++) {\n          var moduleElement = moduleElements[i];\n          var module = modules[i].replace(/ /g,'').split(\",\");\n          angular.bootstrap(moduleElement, module);\n      }\n  }\n\n  angular.element(document).ready(function() {\n        initNgModules(document);\n  });\n})();","angular.module('bndry.action', ['bndry.history'])\n.controller('ActionCtrl', function($rootScope, $scope, HistorySvc) {\n  $scope.clear = function() {\n    $rootScope.$broadcast('action:clear');\n    HistorySvc.clear();\n  };\n\t\n\t$scope.hasUndo = HistorySvc.hasUndo;\n  $scope.undo = function() {\n    if (HistorySvc.hasUndo()) {\n      HistorySvc.undo();\n    }\n  };\n\t\n\t$scope.hasRedo = HistorySvc.hasRedo;\n  $scope.redo = function() {\n    if (HistorySvc.hasRedo()) {\n      HistorySvc.redo();\n    }\n  };\n})\n","/* jshint bitwise: false */\n\nangular.module('bndry.color', ['ngStorage'])\n\n/*\nColor Service\n \nConverts color notations to various formats\nSupported formats: rgba, hsla, hex24, hex32\n*/\n.service('ColorSvc', function($localStorage) {\n  var _rgba = {};\n  var self = this;\n\n  function rgbaToInt(r, g, b, a) {\n    r = Math.round(r * 255);\n    g = Math.round(g * 255);\n    b = Math.round(b * 255);\n    a = Math.round(a * 255);\n\n    /*\n    Bitwise black magic (given r = 0x12, g = 0x34, b = 56, a = 78):\n    (r << 24) => 0x12000000\n    (g << 16) => 0x00340000\n    (b << 8)  => 0x00005600\n    (a)       => 0x00000078\n    \n    All OR'ed => 0x12345678\n    \n    `>>> 0` converts to unsigned 32-bit int\n    */\n    return ((r << 24) | (g << 16) | (b << 8) | (a)) >>> 0;\n  }\n  function hueToRgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1/6) return p + (q - p) * 6 * t;\n    if (t < 1/2) return q;\n    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n    return p;\n  }\n  \n  this.convert = {\n    rgba: function(rgba) {\n      _rgba = rgbaToInt(rgba.r,\n        rgba.g,\n        rgba.b,\n        rgba.a);\n\n      return self;\n    },\n    hsla: function(hsla) {\n      var r, g, b;\n      var {h, s, l, a} = hsla;\n\n      if (s == 0) {\n          r = g = b = l; // achromatic\n      } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = hueToRgb(p, q, h + 1/3);\n          g = hueToRgb(p, q, h);\n          b = hueToRgb(p, q, h - 1/3);\n      }\n      \n      _rgba = rgbaToInt(r, g, b, a);\n      \n      return self;\n    },\n    hex24: function(hex24) {\n      self.convert.hex32(hex24 + 'FF');\n\n      return self;\n    },\n    hex32: function(hex32) {\n      _rgba = parseInt(hex32, 16) >>> 0; // `>>> 0` => unsigned 32-bit int\n\n      return self;\n    }\n  };\n  this.to = {\n    rgba: function() {\n      var r = (_rgba >> 24 & 0xFF) / 0xFF,\n        g = (_rgba >> 16 & 0xFF) / 0xFF,\n        b = (_rgba >> 8 & 0xFF) / 0xFF,\n        a = (_rgba & 0xFF) / 0xFF;\n\n      _rgba = 0;\n\n      return {r,g,b,a};\n    },\n    hsla: function() {\n      var {r, g, b, a} = self.to.rgba();\n      \n      var max = Math.max(r, g, b), min = Math.min(r, g, b);\n      var h, s, l = (max + min) / 2;\n\n      if (max === min) {\n        h = s = 0; // achromatic\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n          case g: h = (b - r) / d + 2; break;\n          case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n      }\n\n      return {h, s, l, a};\n    },\n    hex24: function() {\n      return self.to.hex32().substring(0, 6);\n    },\n    hex32: function() {\n      var hex = _rgba.toString(16);\n      _rgba = 0;\n\n      return ('00000000' + hex).slice(-8); // Pad output with leading zero\n    }\n  };\n  \n  // HOTFIX until proper interface arrives\n  delete $localStorage.colors;\n  \n  $localStorage.$default({\n    colors: [{\n      name: 'Red',\n      label: 'Do not work either side',\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: 'Green',\n      label: 'Work ONLY the inner side',\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: 'Blue',\n      label: 'Work both sides',\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }],\n    activeColorIndex: 1\n  });\n  self.colors = $localStorage.colors;\n  self.activeColorIndex = () => $localStorage.activeColorIndex;\n  self.setActiveColorIndex = function(index) {\n    $localStorage.activeColorIndex = index;\n  }\n  self.activeColor = function() {\n    return self.colors[self.activeColorIndex()];\n  };\n})\n  .controller('ColorCtrl', function($scope, $localStorage, ColorSvc) {\n    $scope.$storage = $localStorage;\n    \n    $scope.fillColor = function(index) {\n      if (index === undefined) {\n        index = ColorSvc.activeColorIndex();\n      }\n      var color = ColorSvc.colors[index];\n      return '#' + ColorSvc.convert.rgba(color).to.hex24();\n    };\n    $scope.activeColorIndex = ColorSvc.activeColorIndex;\n    $scope.setActiveColorIndex = ColorSvc.setActiveColorIndex;\n  });\n","/* jshint camelcase: false */\n\nangular.module('bndry.drawing', ['ngStorage', 'bndry.map', 'bndry.color', 'bndry.shape', 'bndry.history'])\n.service('DirectionsSvc', function($rootScope, $q, MapSvc) {\n  var self = this;\n  var directions = new MapSvc.DirectionsService();\n\n  self.route = function(locations) {\n    if (locations.length !== 2) {\n      console.error('Requires exactly 2 locations.');\n      return false;\n    }\n\n    var request = {\n      origin: locations[0],\n      destination: locations[1],\n      travelMode: MapSvc.TravelMode.DRIVING\n    };\n\n    var deferred = $q.defer();\n\n    function processRequest(tries, request) {\n      directions.route(request,\n        // Success handler\n\n        function(request, result, status) {\n          if (status === MapSvc.DirectionsStatus.OK) {\n            var overviewPath = result.routes[0].overview_path;\n\n            // Resolve with path\n            deferred.resolve(overviewPath);\n          } else if (status ===\n            MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n            tries++;\n            // Try again\n            processRequest(tries);\n          } else {\n            $rootScope.$broadcast('load:error');\n            deferred.reject([request.origin, request.destination]);\n          }\n        }.bind(null, request),\n        // Error handler\n\n        function(request) {\n          if (tries < 3) {\n            // Try again\n            tries++;\n            processRequest(tries, request);\n          } else {\n            $rootScope.$broadcast('load:error');\n            deferred.reject();\n          }\n        }.bind(null, request));\n    }\n\n    processRequest(0, request);\n\n    $rootScope.$broadcast('load:start');\n    \n    return deferred.promise.then((result) => {\n      $rootScope.$broadcast('load:done');\n      return result;\n    });\n  };\n})\n.service('DrawingSvc', function($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc, ShapeSvc) {\n  var self = this;\n\n\n\n  function splice(itemArray, index = 0, removeLength = 0, newItems = []) {\n    var args = [index, removeLength].concat(newItems);\n    \n    return Array.prototype.splice.apply(itemArray, args);\n  }\n  \n  function change(object, changes) {\n    for (var key in changes) {\n      if (changes.hasOwnProperty(key)) {\n        object[key] = changes[key];\n      }\n    }\n  }\n  \n  function arrayify(items) {\n    if (!Array.isArray(items)) {\n      return [items];\n    } else {\n      return items;\n    }\n  }\n  \n  \n  \n  /*\n  *** PRIVATE METHODS ***\n  */\n  // Path functions\n  function makePoint(latLng) {\n    console.assert(\n      'lat' in latLng &&\n      'lng' in latLng &&\n      typeof latLng.lat === 'number' &&\n      typeof latLng.lat === 'number',\n      \n      'latLng is not formatted properly'\n    );\n    return new MapSvc.LatLng(latLng.lat, latLng.lng);\n  }\n  \n  function addPoints(path, index, points) {\n    return splice(path, index, 0, points);\n  }\n  \n  function removePoints(path, index, removeLength) {\n    return splice(path, index, removeLength);\n  }\n\n\n\n  function makePaths(locations, rigid = false) {\n    console.assert(\n      Array.isArray(locations),\n      \n      'locations is not an Array'\n    );\n    \n    var promises = [];\n    for (var i = 0; i < locations.length - 1; i++) {\n      var start = locations[i],\n        end = locations[i + 1],\n        promise;\n      \n      if (rigid) {\n        promise = start.equals(end) ?\n          $q.when([start]) :\n          $q.when([start, end]);\n      } else {\n        promise = DirectionsSvc.route([start, end])\n\t\t\t\t  .catch(function(start, end) {\n\t\t\t\t  \treturn start.equals(end) ?\n\t\t          $q.when([start]) :\n\t\t          $q.when([start, end]);\n\t\t\t\t  }.bind(null, start, end));\n      }\n      promises.push(promise);\n    }\n    \n    return $q.all(promises);\n  }\n\n\n\n  // Node functions\n  function addNodes(nodes, index, nodesToAdd) {\n    nodesToAdd = arrayify(nodesToAdd);\n    for (var node of nodesToAdd) {\n      node._marker.setMap(MapSvc.map);\n    }\n    \n    return splice(nodes, index, 0, nodesToAdd);\n  }\n  var addNode = addNodes;\n  \n  function removeNodes(nodes, index, removeLength = 1) {\n    var removed = splice(nodes, index, removeLength);\n    for (var node of removed) {\n      node._marker.setMap(null);\n    }\n    \n    return removed;\n  }\n  var removeNode = removeNodes;\n  \n  function changeNode(node, changes) {\n    console.assert(\n      typeof node === 'object' &&\n      typeof changes === 'object',\n      \n      'Invalid parameters'\n    );\n    change(node, changes);\n    for (var key in changes) {\n      switch (key) {\n      case 'lat':\n      case 'lng':\n        node._marker.setPosition(makePoint(node));\n        break;\n      }\n    }\n  }\n  \n  function duplicateNode(drawing, node) {\n    return makeNode(drawing.colorIndex, makePoint(node), node.index);\n  }\n  \n  \n  \n  function shiftIndexOfNodes(nodes, index, shifts) {\n    var nodeArray = arrayify(nodes),\n      shift = 0,\n      i = 0;\n    \n    if (Array.isArray(shifts)) {\n      for (i = 0; (i + index) < nodeArray.length && i < shifts.length; i++) {\n        shift += shifts[i];\n        nodeArray[index + i].index += shift;\n      }\n    } else {\n      shift = shifts;\n    }\n    for (i += index; i < nodeArray.length; i++) {\n      nodeArray[i].index += shift;\n    }\n  }\n  \n  function setIndexOfNodes(nodes, index, value) {\n    var nodeArray = arrayify(nodes);\n    for (var i = index; i < nodeArray.length; i++) {\n      nodeArray[i].index = value;\n    }\n  }\n  \n  function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n    var nodeBefore = nodes[index - 1], indexForNode = 0;\n    \n    if (nodeBefore) {\n      indexForNode = nodeBefore.index;\n    }\n    setIndexOfNodes(nodesToAdd, 0, indexForNode);\n  }\n  \n  \n  \n  function rangeOfPathAroundNodes(nodes, start, end) {\n    var range = {\n      start: null,\n      end: null,\n      length: null,\n      nodeStart: null,\n      nodeEnd: null,\n      nodeLength: null,\n      lastNode: false,\n      firstNode: false\n    };\n    \n    var nodeRange = nodes.slice(start, end),\n      firstNodeInRange = nodeRange[0],\n      lastNodeInRange = nodeRange[nodeRange.length - 1],\n      nodeBeforeRange = nodes[start - 1],\n      nodeAfterRange = nodes[end];\n    \n    if (!nodeBeforeRange) {\n      range.firstNode = true;\n    }\n    if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n      range.start = nodeBeforeRange.index;\n      range.nodeStart = start;\n    } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n      range.start = firstNodeInRange.index;\n      range.nodeStart = start + 1;\n    } else {\n      range.start = 0;\n      range.nodeStart = 0;\n    }\n    \n    if (!nodeAfterRange) {\n      range.lastNode = true;\n    }\n    if (nodeAfterRange && nodeAfterRange.index !== null) {\n      range.end = nodeAfterRange.index;\n      range.nodeEnd = end;\n    } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n      range.end = lastNodeInRange.index;\n      range.nodeEnd = end - 1;\n    } else {\n      range.end = range.start;\n      range.nodeEnd = range.nodeStart;\n    }\n    \n    range.nodeLength = range.nodeEnd - range.nodeStart;\n    range.length = range.end - range.start;\n    \n    return range;\n  }\n  \n  function rangeOfPathAroundNode(nodes, index) {\n    return rangeOfPathAroundNodes(nodes, index, index);\n  }\n  \n  \n  \n  function makePathsAroundNodes(nodes, start, end, rigid) {\n    var points = [],\n      nodeRange = nodes.slice(start, end),\n      nodeBefore = nodes[start - 1],\n      nodeAfter = nodes[end],\n      node;\n    \n    if (nodeBefore) {\n      points.push(makePoint(nodeBefore));\n    }\n    for (node of nodeRange) {\n      points.push(makePoint(node));\n    }\n    if (nodeAfter) {\n      points.push(makePoint(nodeAfter));\n    }\n    \n    if (points.length < 2) {\n      points.push(points[0]); // Duplicate first point; makePaths needs at least two points\n    }\n    \n    return makePaths(points, rigid);\n  }\n  \n  function makePathsAroundNode(nodes, index, rigid) {\n    return makePathsAroundNodes(nodes, index, index, rigid);\n  }\n  \n\n  \n  function alignNodesWithPath(path, nodes) {\n    var latLng;\n    \n    for (var node of nodes) {\n      latLng = path[node.index];\n      console.assert(\n        latLng,\n\n        'latLng is not defined'\n      );\n      changeNode(node, {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      });\n    }\n  }\n  \n  \n  \n  function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n    var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n\n    if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n      return;\n    }\n    var path = drawing._poly.getPath().getArray(),\n      pathRemoveLength = range.length;\n\n    // Special case to remove last point if lastNode\n    if (range.lastNode) {\n      pathRemoveLength++;\n    }\n\n    removePoints(path, range.start, pathRemoveLength);\n\n    shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n    var removedNodes = removeNodes(drawing.nodes, index, nodeRemoveLength);\n    \n    drawing._poly.setPath(path);\n\n    $rootScope.$broadcast('drawing:change');\n    \n    return removedNodes;\n  }\n  \n  function addNodesAndTheirPathsToDrawing(drawing, index, newNodes, newPaths) {\n    var polyPath = drawing._poly.getPath().getArray(),\n      nodes = drawing.nodes;\n      \n    var shifts = [];\n    var path, lastPoint, i,\n      pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length),\n      pathIndex = pathRange.start;\n      \n    for (path of newPaths) {\n      lastPoint = path.pop();\n      \n      // Adds new path\n      addPoints(polyPath, pathIndex, path);\n      \n      pathIndex += path.length;\n      shifts.push(path.length);\n    }\n    \n    var alignLength = newPaths.length;\n    shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n    \n    if (pathRange.lastNode && lastPoint) { // If lastNode is involved, put lastPoint back\n      polyPath.push(lastPoint);\n      alignLength++;\n    }\n    \n    var nodesToAlign = nodes.slice(index, index + alignLength);\n    alignNodesWithPath(polyPath, nodesToAlign);\n    \n    drawing._poly.setPath(polyPath);\n    \n    $rootScope.$broadcast('drawing:change');\n    \n    return polyPath;\n  }\n  \n  \n  \n  function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength, nodesToAdd = [], pathsToAdd = null) {\n    return queue(\n      function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n        var removedNodes = removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n        \n        if (nodesToAdd === null) {\n          nodesToAdd = removedNodes;\n        } else {\n          nodesToAdd = arrayify(nodesToAdd);\n        }\n        \n        setInitialIndexOfNodes(drawing.nodes, index, nodesToAdd);\n        addNodes(drawing.nodes, index, nodesToAdd);\n      \n        var promise;\n        if (pathsToAdd) {\n          promise = $q.when(pathsToAdd);\n        } else {\n          promise = makePathsAroundNodes.bind(null, drawing.nodes, index, index + nodesToAdd.length, drawing.rigid)();\n        }\n        \n        return promise.then(\n          function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n            return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n          }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd)\n        );\n      }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd)\n    );\n  }\n  \n  \n  \n  /*\n  *** PUBLIC API ***\n  */\n  var internalQueue = $q.when();\n  function queue(steps = []) { // Keeps path operations in correct order\n    console.assert(\n      steps !== undefined,\n\n      'steps cannot be undefined'\n    );\n    \n    steps = arrayify(steps);\n    for (var step of steps) {\n      internalQueue = internalQueue.then(step);\n    }\n    \n    return internalQueue;\n  }\n  self.queue = queue;\n  \n  \n  \n  // Drawing functions\n  function makeDrawing(colorIndex, rigid, fill = false) {\n    var poly;\n\n    if (fill) {\n      poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n    } else {\n      poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n    }\n    return {\n      colorIndex: colorIndex,\n      rigid: rigid,\n      fill: fill,\n      _poly: poly,\n      nodes: []\n    };\n  }\n  self.makeDrawing = makeDrawing;\n  \n  function addDrawings(drawings, index, drawingsToAdd) {\n    return queue(\n      splice.bind(null, drawings, index, 0, drawingsToAdd)\n    );\n  }\n  self.addDrawings = self.addDrawing = addDrawings;\n  \n  function removeDrawings(drawings, index, removeLength) {\n    return queue(\n      function(drawings, index, removeLength) {\n        var removedDrawings = splice(drawings, index, removeLength);\n        for (var i = 0; i < removedDrawings.length; i++) {\n          var removedDrawing = removedDrawings[i];\n          removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n          removedDrawing._poly.setMap(null);\n        }\n      }.bind(null, drawings, index, removeLength)\n    );\n  }\n  self.removeDrawings = self.removeDrawing = removeDrawings;\n  \n  function changeDrawing(drawing, changes) {\n    change(drawing, changes);\n    \n    for (var key in changes) {\n      switch (key) {\n      case 'colorIndex':\n      case 'fill':\n        var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n        drawing._poly.setOptions(options);\n        break;\n      case 'rigid':\n        \n        break;\n      }\n    }\n    \n    $rootScope.$broadcast('drawing:change');\n  }\n  \n  \n  \n  function makeNode(colorIndex, latLng, index = null) {\n    var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n\n    return {\n      lat: latLng.lat(),\n      lng: latLng.lng(),\n      index: index,\n      _marker: marker\n    };\n  }\n  self.makeNode = makeNode;\n  \n  function addNodesToDrawing(drawing, index, nodesToAdd = [], pathsToAdd = null) {\n    return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n  }\n  self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n  \n  function removeNodesFromDrawing(drawing, index, removeLength, pathsToAdd = null) {\n    return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n  }\n  self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n  \n  function changeNodeOfDrawing(drawing, index, changes, pathsToAdd = null) {\n    queue(\n      function(drawing, index, changes) {\n        changeNode(drawing.nodes[index], changes);\n      }.bind(null, drawing, index, changes)\n    );\n    \n    return spliceNodesIntoDrawing.bind(null, drawing, index, 1, null, pathsToAdd)(); \n  }\n  self.changeNodeOfDrawing = changeNodeOfDrawing;\n  \n\n\n  function makeIcon(colorIndex, options) {\n    var color = ColorSvc.colors[colorIndex];\n    var icon = {\n      path: MapSvc.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n    change(icon, options);\n    \n    return icon;\n  }\n  \n  function makeMarkerOptions(colorIndex, latLng, options) {\n    var markerOptions = {\n      clickable: true,\n      crossOnDrag: false,\n      cursor: 'pointer',\n      draggable: true,\n      flat: true,\n      icon: makeIcon(colorIndex),\n      map: MapSvc.map,\n      position: latLng\n    };\n    change(markerOptions, options);\n    \n    return markerOptions;\n  }\n  \n  function makePolyOptions(colorIndex, fill) {\n    var value = {\n      clickable: !fill,\n      draggable: false,\n      editable: false,\n      map: MapSvc.map\n    };\n\n    var color = angular.copy(ColorSvc.colors[colorIndex]);\n    color.a = 0.5;\n    \n    if (fill) {\n      value.fillColor = rgbaColorToString(color);\n      value.fillOpacity = 1;\n      value.strokeWeight = 0;\n    } else {\n      value.strokeColor = rgbaColorToString(color);\n      value.strokeWeight = color.weight;\n    }\n\n    return value;\n  }\n  \n  \n  \n  function drawingsToGeoJson(drawings) {\n    var geoJson = {\n      type: 'FeatureCollection'\n    };\n\n    geoJson.features = drawings.map(\n      (drawing) => {\n        var feature = {\n          type: 'Feature'\n        };\n        \n        var polyPath = drawing._poly.getPath().getArray();          \n        var coordinates = polyPath.map(\n          (latLng) => {\n            return [\n              latLng.lng(),\n              latLng.lat()\n            ];\n          }\n        );\n        \n        feature.geometry = {\n          type: drawing.fill ? 'Polygon' : 'LineString',\n          coordinates: drawing.fill ? [coordinates] : coordinates\n        };\n        \n        var {colorIndex, rigid, fill, nodes} = drawing;\n        feature.properties = {colorIndex, rigid, fill};\n        feature.properties.nodes = nodes.map(\n          (node) => {\n            var {lat, lng, index} = node;\n            return {lat, lng, index};\n          }\n        );\n        return feature;\n      }\n    );\n    \n    return JSON.stringify(geoJson);\n  }\n  self.drawingsToGeoJson = drawingsToGeoJson;\n  \n  function geoJsonToDrawings(geoJsonString) {\n    console.assert(\n      typeof geoJsonString === 'string',\n\n      'geoJson must be a string'\n    );\n    \n    var drawings = [];\n    var geoJson = JSON.parse(geoJsonString);\n    var drawings = geoJson.features.map(\n      (feature, i) => {\n        var {colorIndex, rigid, fill, nodes} = feature.properties;\n        var drawing = makeDrawing(colorIndex, rigid, fill);\n        addDrawings(drawings, i, drawing);\n        \n        var nodesToAdd = nodes.map(\n          (node) => {\n            var latLng = new MapSvc.LatLng(node.lat, node.lng);\n            return makeNode.bind(null, drawing.colorIndex, latLng, node.index)();\n          }\n        );\n        \n        var coordinates;\n        if (fill) {\n          coordinates = feature.geometry.coordinates[0];\n        } else {\n          coordinates = feature.geometry.coordinates;\n        }\n        var polyPath = coordinates.map(\n          (coordinate) => new MapSvc.LatLng(coordinate[1], coordinate[0])\n        );\n        \n        var pathsToAdd = [];\n        for (var i = 0; i < nodesToAdd.length - 1; i++) {\n          var nodeAt = nodesToAdd[i],\n            nodeAfter = nodesToAdd[i + 1],\n            pathChunk = polyPath.slice(nodeAt.index, nodeAfter.index + 1);\n          \n          pathsToAdd.push(pathChunk);\n        }\n                \n        addNodesToDrawing.bind(null, drawing, 0, nodesToAdd, pathsToAdd)();\n        \n        return drawing;\n      }\n    );\n    \n    return drawings;\n  }\n  self.geoJsonToDrawings = geoJsonToDrawings;\n  \n  \n  \n  function rgbaColorToString(rgba) {\n    return `rgba(${Math.round(rgba.r*255)},${Math.round(rgba.g*255)},${Math.round(rgba.b*255)},${rgba.a})`;\n  }\n  \n  \n  \n  var activeMarker = new MapSvc.Marker();\n  function showActiveNode(colorIndex, node) {\n    var color = ColorSvc.colors[colorIndex];\n    activeMarker.setOptions(makeMarkerOptions(colorIndex, makePoint(node), {\n      clickable: false,\n      draggable: false,\n      icon: makeIcon(colorIndex, {\n        scale: 20,\n        strokeWeight: 2,\n        strokeOpacity: 0.5,\n        fillColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n        fillOpacity: 0.125\n      })\n    }));\n  }\n  self.showActiveNode = showActiveNode;\n  \n  function hideActiveNode() {\n    activeMarker.setMap(null);\n  }\n  self.hideActiveNode = hideActiveNode;\n  \n  \n  \n  self.forceCreateNewDrawing = false;\n  \n  self.shouldCreateNewDrawing = () => {\n    if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n      return true;\n    }\n    var latestDrawing = self.drawings[self.drawings.length - 1];\n    var value = (latestDrawing &&\n      (latestDrawing.colorIndex !== ColorSvc.activeColorIndex() ||\n      latestDrawing.rigid !== ShapeSvc.rigid() ||\n      latestDrawing.fill !== ShapeSvc.fill()));\n    return value;\n  };\n  \n  self.drawings;\n  \n  self.activeDrawingIndex = -1;\n})\n// Controllers\n.controller('DrawingCtrl', function($scope, $localStorage, $timeout, DrawingSvc, ColorSvc, ShapeSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n  \n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n  \n  // Load last saved drawings from geoJson in localStorage\n  var storedDrawings = DrawingSvc.geoJsonToDrawings(\n    localStorage.geoJson || DrawingSvc.drawingsToGeoJson(drawings)\n  );\n  for (var storedDrawing of storedDrawings) {\n    drawings.push(storedDrawing);\n  }\n  \n  function activeDrawingIndex(value) {\n    if (typeof value === 'number') {\n      DrawingSvc.activeDrawingIndex = value;\n    } else {\n      return DrawingSvc.activeDrawingIndex;\n    }\n  }\n  activeDrawingIndex(drawings.length - 1);\n  var queue = DrawingSvc.queue;\n  // $scope.$storage = DrawingSvc.loadDrawings();\n\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n    \n    var rigid = ShapeSvc.rigid(),\n      fill = ShapeSvc.fill();\n\n    var createNewDrawing = DrawingSvc.shouldCreateNewDrawing();\n    if (createNewDrawing) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex(activeDrawingIndex() + 1);\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex(), newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n\n    queue(\n      function(drawingIndex, colorIndex, latLng, createNewDrawing) {\n        var drawing = drawings[drawingIndex];\n        var newNode = DrawingSvc.makeNode(colorIndex, latLng);\n        var nodeIndex = drawing.nodes.length;\n        \n        DrawingSvc.addNodeToDrawing(drawing, nodeIndex, newNode);\n        \n        HistorySvc.add({\n          undo: function(drawings, drawing, drawingIndex, nodeIndex, didCreateNewDrawing) {\n            DrawingSvc.removeNodeFromDrawing(drawing, nodeIndex, 1);\n            \n            if (didCreateNewDrawing) {\n              DrawingSvc.removeDrawing(drawings, drawingIndex, 1);\n              activeDrawingIndex(drawingIndex - 1);\n            }\n          }.bind(null, drawings, drawing, drawingIndex, nodeIndex, createNewDrawing),\n          \n          redo: function(drawings, drawing, drawingIndex, nodeIndex, newNode, didCreateNewDrawing) {\n            if (didCreateNewDrawing) {\n              DrawingSvc.addDrawing(drawings, drawingIndex, drawing);\n              activeDrawingIndex(drawingIndex + 1);\n            }\n            \n            DrawingSvc.addNodeToDrawing(drawing, nodeIndex, newNode);\n          }.bind(null, drawings, drawing, drawingIndex, nodeIndex, newNode, createNewDrawing)\n        });\n      }.bind(null, activeDrawingIndex(), colorIndex, param.latLng, createNewDrawing)\n    );\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0],\n      drawing = drawings[drawingIndex],\n      latLng = event.latLng;\n    \n    queue(\n      function(drawing, nodeIndex, latLng) {\n        var originalNode = drawing.nodes[nodeIndex],\n          originalPosition = {\n            lat: originalNode.lat,\n            lng: originalNode.lng\n          },\n          newPosition = {\n            lat: latLng.lat(),\n            lng: latLng.lng()\n          };\n        DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, newPosition);\n        \n        HistorySvc.add({\n          undo: function(drawing, nodeIndex, originalPosition) {\n            DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, originalPosition);\n          }.bind(null, drawing, nodeIndex, originalPosition),\n          \n          redo: function(drawing, nodeIndex, newPosition) {\n            DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, newPosition);\n          }.bind(null, drawing, nodeIndex, newPosition)\n        });\n      }.bind(null, drawing, nodeIndex, latLng)\n    );\n  }\n  \n  $scope.$on('map:click', addNode);\n  $scope.$on('action:clear', function($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex(-1);\n  });\n  \n  $scope.$on('drawing:change', () => {\n    localStorage.geoJson = DrawingSvc.drawingsToGeoJson(drawings);\n    \n    if (drawings.length > 0 && drawings[drawings.length - 1].nodes.length > 0) {\n      var latestNodes = drawings[drawings.length - 1].nodes,\n        latestNode = latestNodes[latestNodes.length - 1];\n      \n      DrawingSvc.showActiveNode(ColorSvc.activeColorIndex(), latestNode);\n    } else {\n      DrawingSvc.hideActiveNode();\n    }\n  });\n  \n  $scope.marker = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    }\n  };\n});\n","angular.module('bndry.geo', ['bndry.map'])\n  .service('GeolocationSvc', function($q) {\n    this.getLocation = function() {\n      var deferred = $q.defer();\n\n      if ('geolocation' in navigator) {\n        navigator.geolocation.getCurrentPosition(function(position) {\n          deferred.resolve(position);\n        }, function(error) {\n          deferred.reject(error);\n        });\n      } else {\n        deferred.reject(false);\n      }\n\n      return deferred.promise;\n    };\n  })\n  .service('GeocodeSvc', function($q, MapSvc) {\n    this.geocode = function(location, bounds) {\n      var geocoder = new MapSvc.Geocoder();\n      var deferred = $q.defer();\n\t\t\t\n\t\t\tvar request = {};\n\t\t\t\n\t\t\tif (bounds) {\n\t\t\t\trequest.bounds = location;\n\t\t\t} else {\n\t\t\t\trequest.location = location;\n\t\t\t}\n\t\t\t\n\t\t\t\n      geocoder.geocode(request, function(results, status) {\n        if (status === MapSvc.GeocoderStatus.OK) {\n          deferred.resolve(results);\n        } else {\n          deferred.reject(status);\n        }\n      });\n\n      return deferred.promise;\n    };\n  });\n","// istanbul ignore next\nangular.module('bndry.history', [])\n  .service('HistorySvc', function() {\n    /* jshint quotmark:true */\n    /* jshint camelcase:false */\n      /*\n      Simple Javascript undo and redo.\n      https://github.com/ArthurClemens/Javascript-Undo-Manager\n      */\n      \"use strict\";\n\n      var commands = [],\n        index = -1,\n        isExecuting = false,\n        callback,\n\n        // functions\n        execute;\n\n      execute = function(command, action) {\n        if (!command || typeof command[action] !== \"function\") {\n          return this;\n        }\n        isExecuting = true;\n\n        command[action]();\n\n        isExecuting = false;\n        return this;\n      };\n\n      return {\n\n        /*\n        Add a command to the queue.\n        */\n        add: function(command) {\n          if (isExecuting) {\n            return this;\n          }\n          // if we are here after having called undo,\n          // invalidate items higher on the stack\n          commands.splice(index + 1, commands.length - index);\n\n          commands.push(command);\n\n          // set the current index to the end\n          index = commands.length - 1;\n          if (callback) {\n            callback();\n          }\n          return this;\n        },\n\n        /*\n        Pass a function to be called on undo and redo actions.\n        */\n        setCallback: function(callbackFunc) {\n          callback = callbackFunc;\n        },\n\n        /*\n        Perform undo: call the undo function at the current index and decrease the index by 1.\n        */\n        undo: function() {\n          var command = commands[index];\n          if (!command) {\n            return this;\n          }\n          execute(command, \"undo\");\n          index -= 1;\n          if (callback) {\n            callback();\n          }\n          return this;\n        },\n\n        /*\n        Perform redo: call the redo function at the next index and increase the index by 1.\n        */\n        redo: function() {\n          var command = commands[index + 1];\n          if (!command) {\n            return this;\n          }\n          execute(command, \"redo\");\n          index += 1;\n          if (callback) {\n            callback();\n          }\n          return this;\n        },\n\n        /*\n        Clears the memory, losing all stored states. Reset the index.\n        */\n        clear: function() {\n          var prev_size = commands.length;\n\n          commands = [];\n          index = -1;\n\n          if (callback && (prev_size > 0)) {\n            callback();\n          }\n        },\n\n        hasUndo: function() {\n          return index !== -1;\n        },\n\n        hasRedo: function() {\n          return index < (commands.length - 1);\n        },\n\n        getCommands: function() {\n          return commands;\n        }\n      };\n    });\n\n      /*\nLICENSE\n\nThe MIT License\n\nCopyright (c) 2010-2014 Arthur Clemens, arthurclemens@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: \n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n","angular.module('bndry.image', ['ngStorage', 'bndry.map', 'bndry.drawing', 'bndry.color'])\n.service('ImageSvc', function($rootScope, $http, $document, $localStorage, MapSvc, DrawingSvc, ColorSvc) {\n  var self = this;\n  \n  self.pxSize = function(maxWidth, maxHeight, ratio) {\n    return {\n      ratio: ratio,\n      width: (ratio >= 1) ? maxWidth : Math.round(ratio * maxWidth),\n      height: (ratio < 1) ? maxHeight : Math.round(1 / ratio * maxHeight)\n    };\n  };\n  self.generateUrl = function() {\n    if (!DrawingSvc.drawings) {\n      return;\n    }\n\n    var path = 'https://maps.googleapis.com/maps/api/staticmap';\n\n    var params = [];\n\n    // Generate style from map styling and drawings\n    for (var rule of $localStorage.style) {\n      var urlRule = [];\n\n      // Add selectors to urlRule\n      if ('featureType' in rule && rule.featureType !== 'all') {\n        urlRule.push('feature:' + rule.featureType);\n      }\n      if ('elementType' in rule && rule.elementType !== 'all') {\n        urlRule.push('element:' + rule.elementType);\n      }\n\n      // Loop through every styler, add to urlRule\n      for (var styler of rule.stylers) {\n        for (var key in styler) {\n          var value = styler[key];\n\n          if (key === 'color') {\n            value = '0x' + value.substring(1);\n          }\n\n          urlRule.push(key + ':' + value);\n        }\n      }\n\n      var urlParamText = urlRule.join('|');\n\n      // Add urlParamText to params if not empty string\n      if (urlParamText !== '') {\n        params.push('style=' + urlParamText);\n      }\n    }\n\n    // Generate paths from drawings\n    var drawing, urlPath, polyPath, encodedPath, color, hex;\n    var bounds = new MapSvc.LatLngBounds();\n    for ( let i = 0; i < DrawingSvc.drawings.length; i++ ) {\n      urlPath = [];\n      drawing = DrawingSvc.drawings[i];\n      polyPath = drawing._poly.getPath().getArray();\n\n      for ( let j = 0; j < polyPath.length; j++ ) {\n        bounds.extend(polyPath[j]);\n      }\n\n      encodedPath = MapSvc.geometry.encoding.encodePath(polyPath);\n      color = $localStorage.colors[drawing.colorIndex];\n      hex = '0x' + ColorSvc.convert.rgba(color).to.hex32();\n\n      // If drawing is polygon, use 'fillcolor'\n      if (drawing.fill) {\n        urlPath.push('fillcolor:' + hex);\n        urlPath.push('weight:0');\n      } else {\n        urlPath.push('color:' + hex);\n        urlPath.push('weight:' + color.weight);\n      }\n      urlPath.push('enc:' + encodedPath);\n\n      urlPath = urlPath.join('|');\n\n      // Add urlPath to params if not empty string\n      if (urlPath) {\n        params.push('path=' + urlPath);\n      }\n    }\n\n    var northEast = bounds.getNorthEast();\n    var southWest = bounds.getSouthWest();\n    var computeHeading = MapSvc.geometry.spherical.computeHeading;\n    var heading = Math.abs(computeHeading(northEast, southWest) + computeHeading(southWest, northEast)) / 2;\n\n\t\tvar ratio = (45 <= heading && heading < 135) ? 3.5/5 : 5/3.5;\n\t\tvar pxSize = self.pxSize(640, 640, ratio);\n\t\t\n    // Landscape\n    params.push('size=' + pxSize.height + 'x' + pxSize.width);\n\n    params.push('format=jpg');\n    params.push('scale=2');\n    params.push('sensor=true');\n\n    return encodeURI(path + '?' + params.join('&'));\n  };\n  self.generatePdf = function(locality, number, imageUrl) {\n    if (!imageUrl) {\n      imageUrl = self.generateUrl();\n    }\n    \n    var legend = [];\n    for (var color of ColorSvc.colors) {\n      var entry = {\n        name: color.name,\n        label: color.label,\n        color: `#${ColorSvc.convert.rgba(color).to.hex24()}`\n      };\n      legend.push(entry);\n    }\n    var data = {\n      serif: true,\n      locality: locality,\n      notes: \"See attached form for Do Not Calls.\\nAdd new Do Not Calls as you find them.\",\n      legend: legend,\n      number: number,\n      image: imageUrl\n    }\n    \n    // Ugly hack to force browser to download file\n    var form = document.createElement('form');\n    form.style = 'display: none;'\n    form.enctype = 'x-www-form-urlencoded';\n    form.action = 'http://boundariesapp.herokuapp.com/pdf';\n    form.method = 'POST';\n    \n    var input = document.createElement('input');\n    input.name = 'json';\n    input.type = 'text';\n    input.value = angular.toJson(data);\n    \n    form.appendChild(input);\n    \n    document.body.appendChild(form);\n    form.submit();\n    document.body.removeChild(form);\n\t\t\n\t\t$rootScope.$emit('territory:save', {\n\t\t\tlocality: locality,\n\t\t\tnumber: number,\n\t\t\tdrawings: DrawingSvc.drawingsToGeoJson(DrawingSvc.drawings)\n\t\t});\n  }\n})\n.controller('ImageCtrl', function($scope, ImageSvc) {\n  $scope.data = {\n\t\tlocality: '',\n\t\tnumber: ''\n\t};\n  \n  $scope.downloadPdf = () => {\n    var locality = prompt('Locality (for example, the name of the city)', '');\n    if (!locality) {\n      return;\n    }\n    var number = prompt('Territory number (for example, MR-1056)', '');\n    if (!number) {\n      return;\n    }\n\n\t\tImageSvc.generatePdf(locality, number, ImageSvc.generateUrl());\n  };\n});\n","/* global google */\n\nangular.module('bndry.map', ['ngStorage'])\n\n// MapSvc encapsulates google.maps, making it easier to mock for tests.\n.service('MapSvc', function($rootScope) {\n  function makeIcon(color) {\n    return {\n      path: self.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: color,\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n  }\n\n  function makeMarkerOptions(lat, lng, color) {\n    var clickable = false,\n      cursor = 'pointer',\n      draggable = false;\n    return {\n      clickable: clickable,\n      crossOnDrag: false,\n      cursor: cursor,\n      draggable: draggable,\n      flat: true,\n      icon: makeIcon(color),\n      map: self.map,\n      position: new self.LatLng(lat, lng)\n    };\n  }\n\n  function addListener(eventName) {\n    self.map.addListener(eventName, function(mouseEvent) {\n      $rootScope.$broadcast('map:' + eventName, mouseEvent);\n    });\n  }\n\n  var self = this;\n\n  angular.extend(self, google.maps);\n  self.map = new self.Map(document.getElementById('map_canvas'));\n  self.placesSvc = new self.places.PlacesService(self.map);\n  self.autocompleteSvc = new self.places.AutocompleteService();\n\n  var events = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle', 'maptypeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick', 'tilesloaded', 'tilt_changed', 'zoom_changed'];\n\n  events.forEach(addListener);\n})\n\n// Map controller, mainly for event handling\n.controller('MapCtrl', function($scope, $rootScope, $localStorage, MapSvc) {\n  // Default values for lat, lng, zoom\n  $localStorage.$default({\n    lat: 0,\n    lng: 0,\n    zoom: 10,\n    mapTypeId: MapSvc.MapTypeId.ROADMAP,\n    style: [{\n      'stylers': [{\n        'visibility': 'off'\n      }]\n    }, {\n      'featureType': 'landscape',\n      'stylers': [{\n        'visibility': 'on'\n      }, {\n        'color': '#ffffff'\n      }]\n    }, {\n      'featureType': 'road',\n      'stylers': [{\n        'visibility': 'on'\n      }]\n    }, {\n      'elementType': 'geometry.fill',\n      'stylers': [{\n        'color': '#ffffff'\n      }]\n    }, {\n      'featureType': 'road',\n      'elementType': 'geometry.stroke',\n      'stylers': [{\n        'color': '#808080'\n      }]\n    }, {\n      'elementType': 'labels.text.stroke',\n      'stylers': [{\n        'color': '#ffffff'\n      }]\n    }, {\n      'elementType': 'labels.text.fill',\n      'stylers': [{\n        'color': '#000000'\n      }]\n    }, {\n      'featureType': 'water',\n      'stylers': [{\n        'visibility': 'on'\n      }, {\n        'color': '#40bfbf'\n      }]\n    }, {\n      'featureType': 'water',\n      'elementType': 'labels.text.stroke',\n      'stylers': [{\n        'color': '#ffffff'\n      }]\n    }, {\n      'featureType': 'road.local',\n      'elementType': 'geometry',\n      'stylers': [{\n        'color': '#dfdfdf'\n      }]\n    }, {\n      'featureType': 'road.local',\n      'elementType': 'geometry.stroke',\n      'stylers': [{\n        'visibility': 'off'\n      }]\n    }, {\n      'featureType': 'landscape.man_made',\n      'stylers': [{\n        'visibility': 'off'\n      }]\n    }]\n  });\n  \n  $scope.$on('map:idle', function() {\n    var center = MapSvc.map.getCenter();\n    var zoom = MapSvc.map.getZoom();\n\n    $localStorage.lat = center.lat();\n    $localStorage.lng = center.lng();\n    $localStorage.zoom = zoom;\n  });\n  $scope.$on('map:maptypeid_changed', function() {\n    var mapTypeId = MapSvc.map.getMapTypeId();\n\n    $localStorage.mapTypeId = mapTypeId;\n  });\n\n  // Initialize map\n  var options = {\n    center: new MapSvc.LatLng($localStorage.lat, $localStorage.lng),\n    disableDefaultUI: true,\n    disableDoubleClickZoom: true,\n    draggableCursor: 'crosshair',\n    draggingCursor: 'move',\n    mapTypeId: $localStorage.mapTypeId,\n    zoomControl: true,\n    zoomControlOptions: {\n      position: MapSvc.ControlPosition.LEFT_CENTER\n    },\n    scaleControl: true,\n    zoom: $localStorage.zoom\n  };\n\n  MapSvc.map.setOptions(options);\n  \n  var customMapStyle = new MapSvc.StyledMapType($localStorage.style, {\n    name: 'Custom'\n  });\n  MapSvc.map.mapTypes.set('custom', customMapStyle);\n})\n.controller('MapActionCtrl', function($scope, MapSvc) {\n\t$scope.mapTypeId = MapSvc.MapTypeId;\n  $scope.setMapTypeId = function(mapTypeId) {\n    // if (mapTypeId in MapSvc.MapTypeId) {\n    //   console.log(mapTypeId, 'in MapSvc.mapTypeId');\n    //   mapTypeId = MapSvc.MapTypeId[mapTypeId];\n    // }\n    \n    MapSvc.map.setMapTypeId(mapTypeId);\n  };\n\t$scope.getMapTypeId = () => {\n\t\treturn MapSvc.map.getMapTypeId();\n\t};\n});\n","/* jslint camelcase: false */\n\nangular.module('bndry.search', ['ngSanitize', 'bndry.map'])\n  .directive('focusOn', function($parse, $timeout) {\n    return {\n      restrict: 'A',\n      link: function(scope, elem, attr) {\n\t\t\t\tvar value = $parse(attr.focusOn);\n\t\t\t\t\n\t\t\t\tscope.$watch(value.bind(null, scope), function(newVal) {\n          if (newVal === undefined) {\n            return;\n          }\n\t\t\t\t\t\t\t\t\t\t\n          if (newVal) {\n            $timeout(function() {\n\t\t\t\t\t\t\telem[0].focus();\n\t\t\t\t\t\t\t// scope.$apply();\n\t\t\t\t\t\t});\n          } else {\n            $timeout(function() {\n\t\t\t\t\t\t\telem[0].blur();\n\t\t\t\t\t\t\t// scope.$apply();\n\t\t\t\t\t\t});\n          }\n\t\t\t\t});\n\t\t\t\t// attr.$observe('focusOn', function(newVal) {\n\t\t\t\t//           if (newVal === undefined) {\n\t\t\t\t//             return;\n\t\t\t\t//           }\n\t\t\t\t//\n\t\t\t\t// \telem = elem[0];\n\t\t\t\t//\n\t\t\t\t// \tconsole.log(newVal ? 'Focus!' : 'Blur!');\n\t\t\t\t//           if (newVal) {\n\t\t\t\t//             $timeout(elem.focus.bind(elem), 10);\n\t\t\t\t//           } else {\n\t\t\t\t//             $timeout(elem.blur.bind(elem), 10);\n\t\t\t\t//           }\n\t\t\t\t// });\n      }\n    };\n  })\n  .service('SearchSvc', function($q, MapSvc) {\n    this.search = function(input) {\n      var deferred = $q.defer();\n\n      if (input.length <= 0) {\n        deferred.resolve([]);\n      } else {\n        var request = {\n          input: input\n        };\n\n        request.bounds = MapSvc.map.getBounds();\n\n        MapSvc.autocompleteSvc.getPlacePredictions(request, function(suggestions, status) {\n          if (status === MapSvc.places.PlacesServiceStatus.OK) {\n            deferred.resolve(suggestions);\n          } else if (status === MapSvc.places.PlacesServiceStatus.ZERO_RESULTS) {\n            deferred.reject('No Results');\n          } else {\n            deferred.reject('An Error Occurred');\n          }\n        });\n      }\n\n      return deferred.promise;\n    };\n\n    this.loadPlaceFromReference = function(reference) {\n      if (!reference) {\n        return;\n      }\n\n      if (reference) {\n        MapSvc.placesSvc.getDetails({\n          reference: reference\n        }, function(place, status) {\n          if (status === MapSvc.places.PlacesServiceStatus.OK) {\n            if (place.geometry.viewport) {\n              // fitBounds because panToBounds does not zoom out to show entire bounding box\n              MapSvc.map.fitBounds(place.geometry.viewport);\n            } else if (place.geometry.location) {\n              MapSvc.map.panTo(place.geometry.location);\n            }\n          }\n        });\n      }\n    };\n  })\n  .controller('SearchCtrl', function($scope, $sce, $sessionStorage, SearchSvc) {\n    function throttledSearch(newVal) {\n\t\t\t// console.log('newVal:', newVal, 'queue:', queue, 'resolved:', resolved, 'last:', last);\n\t\t\tif (!resolved) {\n\t\t\t\t// console.log('Queueing newVal because not resolved. Exiting.', newVal);\n        queue = newVal;\n        return;\n      }\n\n      last = newVal;\n      resolved = false;\n\n      SearchSvc.search(newVal)\n        .then(formatSuggestions, errorMessage)\n        .then(function() {\n          resolved = true;\n\n          if (typeof queue === 'string' && queue !== last) {\n\t\t\t\t\t\t// console.log('Searching with queued value.', queue);\n            throttledSearch(queue);\n            queue = false;\n          }\n        });\n    }\n\n    function formatSuggestions(suggestions) {\n      for (var i = 0; i < suggestions.length; i++) {\n        var desc = suggestions[i].description;\n        suggestions[i].description = '';\n        var index = 0;\n\n        for (var j = 0; j < suggestions[i].matched_substrings.length; j++) {\n          var offset = suggestions[i].matched_substrings[j].offset;\n          var length = suggestions[i].matched_substrings[j].length;\n\n          suggestions[i].description += desc.slice(index, offset) + '<b>' + desc.substr(offset, length) + '</b>';\n\n          index = offset + length;\n        }\n        suggestions[i].description += desc.slice(index);\n        suggestions[i].description = '<span>' + suggestions[i].description + '</span>';\n        suggestions[i].description = $sce.trustAsHtml(suggestions[i].description);\n      }\n\n      $scope.suggestions = suggestions;\n    }\n    // Notifies user that no results were found\n\n    function errorMessage(message) {\n      if (typeof message === 'string') {\n\n        $scope.suggestions = [{\n          description: $sce.trustAsHtml('<i>' + message + '</i>'),\n          error: true\n        }];\n      }\n    }\n\n    var resolved = true,\n      queue = false,\n      last = '',\n\t\t\tfocus = false;\n\n    $scope.query = '';\n\t\t$scope.active = -1;\n\t\t\n\t\t$scope.focus = (value) => {\n\t\t\tif (value !== undefined) {\n\t\t\t\tfocus = Boolean(value);\n\t\t\t}\n\t\t\t\n\t\t\treturn focus;\n\t\t};\n\t\t\n        \n    $scope.keydown = function(e) {\n      var enter = (e.which === 13),\n        up = (e.which === 38),\n        down = (e.which === 40);\n\n      if (enter || up || down) {\n        e.preventDefault();\n      } else {\n        $scope.active = 0;\n        return;\n      }\n\n      if ($scope.suggestions[$scope.active]) {\n        if (enter) {\n          $scope.loadOnMap($scope.suggestions[$scope.active].reference);\n          $scope.focus(false);\n        } else if (up && $scope.active > -1) {\n          $scope.active--;\n        } else if (down && $scope.active < $scope.suggestions.length - 1) {\n          $scope.active++;\n        }\n      }\n    };\n\n    $scope.loadOnMap = function(reference) {\n\t\t\tSearchSvc.loadPlaceFromReference(reference);\n\t\t\t$scope.focus(false);\n\t\t};\n\n    $scope.$watch('query', throttledSearch);\n  });\n","angular.module('bndry.shape', ['ngStorage'])\n.service('ShapeSvc', function($localStorage) {\n  this.rigid = (value) => {\n    if (value) {\n      $localStorage.rigid = value;\n    } else {\n      return $localStorage.rigid;\n    }\n  };\n  this.fill = (value) => {\n    if (value) {\n      $localStorage.fill = value;\n    } else {\n      return $localStorage.fill;\n    }\n  };\n})\n.controller('ShapeCtrl', function($scope, $localStorage) {\n  $scope.$storage = $localStorage;\n})\n.run(function($localStorage) {\n  $localStorage.$default({\n    rigid: false,\n    fill: false\n  });\n});","/* jshint camelcase: false */\n\nangular.module('bndry.status', ['bndry.map', 'bndry.geo'])\n.directive('statusBar', function($interval) {\n  return {\n    restrict: 'E',\n    scope: {\n      hide: '@',\n      value: '@'\n    },\n    template: '<div style=\"height: 100%; width: 100%; position: relative;\" ng-hide=\"indeterminate()\"><div class=\"bar\"></div></div>',\n    link: function(scope) {\n      var pending = 0,\n        finished = 0;\n      \n      scope.$on('load:start', () => {\n        pending++;\n      });\n      scope.$on('load:done', () => {\n        finished++;\n        if (finished >= pending) {\n          pending = 0;\n          finished = 0;\n        }\n      });\n      scope.$on('load:error', () => {\n        pending = 0;\n        finished = 0;\n\t\t\t\talert('Directions are not available for this location.');\n      });\n      \n\t\t\tscope.indeterminate = () => (finished >= pending);\n      scope.percentage = function() {\n        return `${(finished + 1) / (pending + 1) * 100}%`;\n      };\n    }\n  };\n})\n.controller('StatusCtrl', function($scope, $timeout, MapSvc, GeocodeSvc) {\n  var locality = '';\n\tvar lastBounds;\n  \n  $scope.locality = function() {\n    return locality;\n  };\n\n  $scope.$on('map:idle', function() {\n\t\tif (lastBounds && MapSvc.map.getBounds().equals(lastBounds)) {\n\t\t\treturn;\n\t\t}\n    GeocodeSvc.geocode(MapSvc.map.getCenter())\n      .then(function(results) {          \n        var localityTypes = [\n\t\t\t\t\t'locality',\n\t\t\t\t\t'administrative_area_level_1',\n\t\t\t\t\t'country'\n\t\t\t\t];\n        locality = '';\n\t\t\t\t\n\t\t\t\tif (results.length < 1) {\n\t\t\t\t\tlocality = 'Unknown Locality';\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (var type of localityTypes) {\n\t\t\t\t\tfor (var result of results) {\n\t\t\t\t\t\tif (result.types.indexOf(type) > -1) {\n\t\t\t\t\t\t\tlocality = result.formatted_address;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t});\n  });\n});\n"],"sourceRoot":"/source/"}