/*
 Boundaries v1.0.0
 (c) 2013-2014 Tyler Eich https://github.com/TylerEich/Boundaries
 License: MIT
*/
{"version":3,"sources":["action/action.js","color/color.js","drawing/drawing.js","geo/geo.js","history/history.js","image/image.js","map/map.js","mode/mode.js","search/search.js","status/status.js","app.js"],"names":[],"mappings":"AAAA;AACA,4DAAA,uCAAA;EACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;EACA;EACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;AClBA;AACA,iEAAA,kBAAA;EACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;MACA;IACA;MACA;IACA;MACA;IACA;MACA;IACA;EACA;EACA;IACA;MACA;MACA;IACA;IACA;MACA;UACA;UACA;MACA;UACA;UACA;UACA;UACA;MACA;QACA;MACA;QACA;QACA;QACA;QACA;QACA;MACA;MACA;MACA;IACA;IACA;MACA;MACA;IACA;IACA;MACA;MACA;IACA;EACA;EACA;IACA;MACA;UACA;UACA;UACA;MACA;MACA;QACA;QACA;QACA;QACA;MACA;IACA;IACA;MACA;UACA;UACA;UACA;UACA;MACA;UACA;MACA;UACA;UACA;MACA;QACA;MACA;QACA;QACA;QACA;UACA;YACA;YACA;UACA;YACA;YACA;UACA;YACA;YACA;QACA;QACA;MACA;MACA;QACA;QACA;QACA;QACA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;MACA;MACA;IACA;EACA;EACA;EACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;EACA;EACA;EACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;EACA;AACA,CAAA,CAAA,0BAAA,wCAAA;EACA;EACA;IACA;MACA;IACA;IACA;IACA;EACA;EACA;EACA;AACA,CAAA,CAAA;;AAEA;AC1KA;AACA,qHAAA,iBAAA;EACA;EACA;EACA;IACA;MACA;MACA;IACA;IACA;MACA;MACA;MACA;IACA;IACA;IACA;MACA;QACA;UACA;UACA;QACA;UACA;UACA;QACA;UACA;QACA;MACA;QACA;UACA;UACA;QACA;UACA;QACA;MACA;IACA;IACA;IACA;EACA;AACA,CAAA,CAAA,wBAAA,6EAAA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;IACA;IACA;EACA;EACA;IACA;MACA;QACA;MACA;IACA;EACA;EACA;IACA;IACA;EACA;EACA;IACA;IACA;IACA;IACA;MACA;UACA;UACA;MACA;QACA;MACA;QACA;MACA;MACA;IACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;MACA;IACA;MACA;IACA;EACA;EACA;IACA;EACA;EACA;EACA;IACA;IACA;IACA;MACA;IACA;EACA;EACA;EACA;IACA;IACA;IACA;MACA;QACA;QACA;UACA;UACA;MACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;QACA;QACA;IACA;MACA;QACA;QACA;MACA;IACA;MACA;IACA;IACA;MACA;IACA;EACA;EACA;IACA;IACA;MACA;IACA;EACA;EACA;IACA;QACA;IACA;MACA;IACA;IACA;EACA;EACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;QACA;QACA;QACA;QACA;IACA;MACA;IACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;QACA;QACA;QACA;QACA;IACA;MACA;IACA;IACA;QACA;MACA;MACA;QACA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;IACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;IACA;QACA;MACA;MACA;QACA;QACA;QACA;UACA;UACA;QACA;MACA;IACA;EACA;EACA;EACA;IACA;IACA;MACA;IACA;IACA;QACA;IACA;MACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;MACA;QACA;MACA;IACA;MACA;IACA;IACA;MACA;UACA;MACA;MACA;UACA;UACA;UACA;UACA;MACA;UACA;QACA;QACA;UACA;UACA;UACA;UACA;QACA;MACA;MACA;MACA;MACA;QACA;QACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;MACA;IACA;IACA;EACA;EACA;EACA;IACA;MACA;IACA;EACA;EACA;IACA;IACA;IACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;EACA;IACA;IACA;IACA;MACA;IACA;MACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;EACA;IACA;EACA;EACA;EACA;IACA;IACA;IACA;EACA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;IACA;EACA;EACA;EACA;IACA;IACA;EACA;EACA;EACA;IACA;IACA;IACA;IACA;EACA;EACA;EACA;IACA;IACA;MACA;QACA;QACA;UACA;UACA;UACA;QACA;UACA;MACA;IACA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;QACA;UACA;QACA;UACA;UACA;YACA;YACA;YACA;cACA;gBACA;cACA;YACA;YACA;UACA;QACA;UACA;QACA;MACA;MACA;IACA;IACA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;MACA;QACA;QACA;QACA;QACA;MACA;MACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;MACA;IACA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;IACA;MACA;MACA;MACA;MACA;IACA;IACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;IACA;EACA;EACA;EACA;IACA;MACA;IACA;IACA;IACA;EACA;EACA;AACA,CAAA,CAAA,4BAAA,oEAAA;EACA;IACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;EACA;EACA;IACA;IACA;QACA;IACA;MACA;MACA;MACA;MACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;QACA;QACA;QACA;IACA;MACA;MACA;IACA;EACA;EACA;EACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;IACA;EACA;EACA;AACA,CAAA,CAAA;;AAEA;AC5iBA;AACA,qEAAA,OAAA;EACA;IACA;IACA;MACA;QACA;MACA;QACA;MACA;IACA;MACA;IACA;IACA;EACA;AACA,CAAA,CAAA,wBAAA,iBAAA;EACA;IACA;IACA;IACA;MACA;QACA;MACA;QACA;MACA;IACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;AC9BA;AACA;EACA;EACA;MACA;MACA;MACA;MACA;EACA;IACA;MACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;MACA;QACA;MACA;MACA;MACA;MACA;MACA;QACA;MACA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;MACA;QACA;MACA;MACA;MACA;MACA;QACA;MACA;MACA;IACA;IACA;MACA;MACA;QACA;MACA;MACA;MACA;MACA;QACA;MACA;MACA;IACA;IACA;MACA;MACA;MACA;MACA;QACA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;IACA;EACA;AACA;;AAEA;AC7EA;AACA,8GAAA,4EAAA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;IACA;EACA;EACA;IACA;MACA;IACA;IACA;IACA;IACA;IACA;QACA;IACA;QACA;QACA;QACA;QACA;IACA;MACA;MACA;MACA;QACA;MACA;MACA;QACA;MACA;MACA;QACA;QACA;UACA;UACA;YACA;UACA;UACA;QACA;MACA;MACA;MACA;QACA;MACA;IACA;IACA;QACA;QACA;QACA;QACA;QACA;IACA;IACA;MACA;MACA;MACA;MACA;QACA;MACA;MACA;MACA;MACA;MACA;MACA;QACA;MACA;QACA;QACA;MACA;MACA;MACA;MACA;QACA;MACA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;IACA;MACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;IACA;IACA;IACA;QACA;MACA;MACA;QACA;UACA;UACA;UACA;QACA;QACA;MACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACA;AACA,CAAA,CAAA,0BAAA,uBAAA;EACA;EACA;EACA;IACA;IACA;MACA;IACA;IACA;IACA;MACA;IACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;ACrJA;AACA,6DAAA,eAAA;EACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;IACA;QACA;QACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;IACA;MACA;IACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA,CAAA,CAAA,wBAAA,oDAAA;EACA;IACA;IACA;IACA;IACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;IACA;MACA;MACA;IACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IACA;IACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;EACA;EACA;AACA,CAAA,CAAA,8BAAA,qBAAA;EACA;IACA;MACA;MACA;IACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;ACvHA;AACA,wDAAA,WAAA;EACA;EACA;AACA,CAAA,CAAA;;AAEA;ACNA;AACA,iFAAA,WAAA;EACA;IACA;IACA;MACA;MACA;QACA;UACA;QACA;QACA;UACA;QACA;UACA;QACA;MACA;IACA;EACA;AACA,CAAA,CAAA,uBAAA,iBAAA;EACA;IACA;IACA;MACA;IACA;MACA;MACA;MACA;QACA;UACA;QACA;UACA;QACA;UACA;QACA;MACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;IACA;MACA;QACA;UACA;YACA;UACA;YACA;UACA;QACA;MACA;IACA;EACA;AACA,CAAA,CAAA,2BAAA,mDAAA;EACA;IACA;MACA;IACA;MACA;MACA;IACA;IACA;IACA;IACA;MACA;MACA;QACA;QACA;MACA;IACA;EACA;EACA;IACA;MACA;MACA;MACA;MACA;QACA;QACA;QACA;QACA;MACA;MACA;MACA;MACA;IACA;IACA;EACA;EACA;IACA;MACA;QACA;QACA;MACA;IACA;EACA;EACA;MACA;MACA;EACA;IACA;IACA;EACA;EACA;IACA;QACA;QACA;IACA;MACA;IACA;MACA;MACA;IACA;IACA;MACA;QACA;QACA;MACA;QACA;MACA;QACA;MACA;IACA;EACA;EACA;EACA;AACA,CAAA,CAAA;;AAEA;ACjIA;AACA,kFAAA,cAAA;EACA;IACA;IACA;MACA;MACA;IACA;IACA;IACA;MACA;QACA;MACA;IACA;EACA;AACA,CAAA,CAAA,2BAAA,+CAAA;EACA;EACA;IACA;EACA;EACA;IACA;MACA;MACA;MACA;QACA;UACA;QACA;QACA;UACA;YACA;UACA;UACA;YACA;UACA;QACA;MACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;AC3CA;AACA;EACA;IACA;IACA;MACA;QACA;MACA;IACA;EACA;AACA,4BAAA,sDAAA;EACA;EACA;IACA;IACA;EACA;EACA;EACA;IACA;EACA;EACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;MACA;IACA;EACA;EACA;IACA;MACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;EACA;IACA;EACA;AACA;;AAEA","sourcesContent":["\"use strict\";\nangular.module('bndry.action', []).controller('ActionCtrl', function($rootScope, $scope, HistorySvc) {\n  $scope.clear = function() {\n    $rootScope.$broadcast('action:clear');\n    HistorySvc.clear();\n  };\n  $scope.undo = function() {\n    if (HistorySvc.hasUndo()) {\n      HistorySvc.undo();\n    }\n  };\n  $scope.redo = function() {\n    if (HistorySvc.hasRedo()) {\n      HistorySvc.redo();\n    }\n  };\n});\n\n//# sourceMappingURL=../../sourcemaps/action/action.js.map","\"use strict\";\nangular.module('bndry.color', ['ngStorage']).service('ColorSvc', function($localStorage) {\n  var _rgba = {};\n  var self = this;\n  function rgbaToInt(r, g, b, a) {\n    r = Math.round(r * 255);\n    g = Math.round(g * 255);\n    b = Math.round(b * 255);\n    a = Math.round(a * 255);\n    return ((r << 24) | (g << 16) | (b << 8) | (a)) >>> 0;\n  }\n  function hueToRgb(p, q, t) {\n    if (t < 0)\n      t += 1;\n    if (t > 1)\n      t -= 1;\n    if (t < 1 / 6)\n      return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n      return q;\n    if (t < 2 / 3)\n      return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n  this.convert = {\n    rgba: function(rgba) {\n      _rgba = rgbaToInt(rgba.r, rgba.g, rgba.b, rgba.a);\n      return self;\n    },\n    hsla: function(hsla) {\n      var r,\n          g,\n          b;\n      var $__0 = hsla,\n          h = $__0.h,\n          s = $__0.s,\n          l = $__0.l,\n          a = $__0.a;\n      if (s == 0) {\n        r = g = b = l;\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hueToRgb(p, q, h + 1 / 3);\n        g = hueToRgb(p, q, h);\n        b = hueToRgb(p, q, h - 1 / 3);\n      }\n      _rgba = rgbaToInt(r, g, b, a);\n      return self;\n    },\n    hex24: function(hex24) {\n      self.convert.hex32(hex24 + 'FF');\n      return self;\n    },\n    hex32: function(hex32) {\n      _rgba = parseInt(hex32, 16) >>> 0;\n      return self;\n    }\n  };\n  this.to = {\n    rgba: function() {\n      var r = (_rgba >> 24 & 0xFF) / 0xFF,\n          g = (_rgba >> 16 & 0xFF) / 0xFF,\n          b = (_rgba >> 8 & 0xFF) / 0xFF,\n          a = (_rgba & 0xFF) / 0xFF;\n      _rgba = 0;\n      return {\n        r: r,\n        g: g,\n        b: b,\n        a: a\n      };\n    },\n    hsla: function() {\n      var $__0 = self.to.rgba(),\n          r = $__0.r,\n          g = $__0.g,\n          b = $__0.b,\n          a = $__0.a;\n      var max = Math.max(r, g, b),\n          min = Math.min(r, g, b);\n      var h,\n          s,\n          l = (max + min) / 2;\n      if (max === min) {\n        h = s = 0;\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n          case g:\n            h = (b - r) / d + 2;\n            break;\n          case b:\n            h = (r - g) / d + 4;\n            break;\n        }\n        h /= 6;\n      }\n      return {\n        h: h,\n        s: s,\n        l: l,\n        a: a\n      };\n    },\n    hex24: function() {\n      return self.to.hex32().substring(0, 6);\n    },\n    hex32: function() {\n      var hex = _rgba.toString(16);\n      _rgba = 0;\n      return ('00000000' + hex).slice(-8);\n    }\n  };\n  delete $localStorage.colors;\n  $localStorage.$default({\n    colors: [{\n      name: 'Red',\n      label: 'Do not work either side',\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: 'Green',\n      label: 'Work ONLY the inner side',\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: 'Blue',\n      label: 'Work both sides',\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }],\n    activeColorIndex: 1\n  });\n  self.colors = $localStorage.colors;\n  self.activeColorIndex = (function() {\n    return $localStorage.activeColorIndex;\n  });\n  self.setActiveColorIndex = function(index) {\n    $localStorage.activeColorIndex = index;\n  };\n  self.activeColor = function() {\n    return self.colors[self.activeColorIndex()];\n  };\n}).controller('ColorCtrl', function($scope, $localStorage, ColorSvc) {\n  $scope.$storage = $localStorage;\n  $scope.fillColor = function(index) {\n    if (index === undefined) {\n      index = ColorSvc.activeColorIndex;\n    }\n    var color = ColorSvc.colors[index];\n    return '#' + ColorSvc.convert.rgba(color).to.hex24();\n  };\n  $scope.activeColorIndex = ColorSvc.activeColorIndex;\n  $scope.setActiveColorIndex = ColorSvc.setActiveColorIndex;\n});\n\n//# sourceMappingURL=../../sourcemaps/color/color.js.map","\"use strict\";\nangular.module('bndry.drawing', ['ngStorage', 'bndry.map', 'bndry.color', 'bndry.history']).service('DirectionsSvc', function($q, MapSvc) {\n  var self = this;\n  var directions = new MapSvc.DirectionsService();\n  self.route = function(locations) {\n    if (locations.length !== 2) {\n      console.error('Requires exactly 2 locations.');\n      return false;\n    }\n    var request = {\n      origin: locations[0],\n      destination: locations[1],\n      travelMode: MapSvc.TravelMode.DRIVING\n    };\n    var deferred = $q.defer();\n    function processRequest(tries) {\n      directions.route(request, function(result, status) {\n        if (status === MapSvc.DirectionsStatus.OK) {\n          var overviewPath = result.routes[0].overview_path;\n          deferred.resolve(overviewPath);\n        } else if (status === MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n          tries++;\n          processRequest(tries);\n        } else {\n          deferred.reject();\n        }\n      }, function() {\n        if (tries < 3) {\n          tries++;\n          processRequest(tries);\n        } else {\n          deferred.reject();\n        }\n      });\n    }\n    processRequest(0);\n    return deferred.promise;\n  };\n}).service('DrawingSvc', function($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc) {\n  var self = this;\n  function splice(itemArray) {\n    var index = arguments[1] !== (void 0) ? arguments[1] : 0;\n    var removeLength = arguments[2] !== (void 0) ? arguments[2] : 0;\n    var newItems = arguments[3] !== (void 0) ? arguments[3] : [];\n    var args = [index, removeLength].concat(newItems);\n    return Array.prototype.splice.apply(itemArray, args);\n  }\n  function splicePassThru(itemArray) {\n    var args = [itemArray].concat(arguments);\n    splice.apply(null, args);\n    return itemArray;\n  }\n  function change(object, changes) {\n    for (var key in changes) {\n      if (changes.hasOwnProperty(key)) {\n        object[key] = changes[key];\n      }\n    }\n  }\n  function makePoint(latLng) {\n    console.assert('lat' in latLng && 'lng' in latLng && typeof latLng.lat === 'number' && typeof latLng.lat === 'number', 'latLng is not formatted properly');\n    return new MapSvc.LatLng(latLng.lat, latLng.lng);\n  }\n  function makePaths(locations) {\n    var rigid = arguments[1] !== (void 0) ? arguments[1] : false;\n    console.assert(Array.isArray(locations), 'locations is not an Array');\n    var promises = [];\n    for (var i = 0; i < locations.length - 1; i++) {\n      var start = locations[i],\n          end = locations[i + 1],\n          promise;\n      if (rigid) {\n        promise = start.equals(end) ? $q.when([start]) : $q.when([start, end]);\n      } else {\n        promise = DirectionsSvc.route([start, end]);\n      }\n      promises.push(promise);\n    }\n    return $q.all(promises);\n  }\n  function addPoints(path, index, points) {\n    return splice(path, index, 0, points);\n  }\n  function removePoints(path, index, removeLength) {\n    return splice(path, index, removeLength);\n  }\n  function arrayify(nodes) {\n    if (!Array.isArray(nodes)) {\n      return [nodes];\n    } else {\n      return nodes;\n    }\n  }\n  function addNodes(nodes, index, nodesToAdd) {\n    splice(nodes, index, 0, nodesToAdd);\n  }\n  var addNode = addNodes;\n  function removeNodes(nodes, index) {\n    var removeLength = arguments[2] !== (void 0) ? arguments[2] : 1;\n    var removed = splice(nodes, index, removeLength);\n    for (var i = 0; i < removed.length; i++) {\n      removed[i]._marker.setMap(null);\n    }\n  }\n  var removeNode = removeNodes;\n  function changeNode(node, changes) {\n    console.assert(typeof node === 'object' && typeof changes === 'object', 'Invalid parameters');\n    change(node, changes);\n    for (var key in changes) {\n      switch (key) {\n        case 'lat':\n        case 'lng':\n          node._marker.setPosition(makePoint(node));\n          break;\n      }\n    }\n  }\n  function duplicateNode(drawing, node) {\n    return makeNode(drawing.colorIndex, makePoint(node), node.index);\n  }\n  function shiftIndexOfNodes(nodes, index, shifts) {\n    var nodeArray = arrayify(nodes),\n        shift = 0,\n        i = 0;\n    if (Array.isArray(shifts)) {\n      for (i = 0; (i + index) < nodeArray.length && i < shifts.length; i++) {\n        shift += shifts[i];\n        nodeArray[index + i].index += shift;\n      }\n    } else {\n      shift = shifts;\n    }\n    for (i += index; i < nodeArray.length; i++) {\n      nodeArray[i].index += shift;\n    }\n  }\n  function setIndexOfNodes(nodes, index, value) {\n    var nodeArray = arrayify(nodes);\n    for (var i = index; i < nodeArray.length; i++) {\n      nodeArray[i].index = value;\n    }\n  }\n  function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n    var nodeBefore = nodes[index - 1],\n        indexForNode = 0;\n    if (nodeBefore) {\n      indexForNode = nodeBefore.index;\n    }\n    setIndexOfNodes(nodesToAdd, 0, indexForNode);\n  }\n  function rangeOfPathAroundNodes(nodes, start, end) {\n    var range = {\n      start: null,\n      end: null,\n      length: null,\n      nodeStart: null,\n      nodeEnd: null,\n      nodeLength: null,\n      lastNode: false,\n      firstNode: false\n    };\n    var nodeRange = nodes.slice(start, end),\n        firstNodeInRange = nodeRange[0],\n        lastNodeInRange = nodeRange[nodeRange.length - 1],\n        nodeBeforeRange = nodes[start - 1],\n        nodeAfterRange = nodes[end];\n    if (!nodeBeforeRange) {\n      range.firstNode = true;\n    }\n    if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n      range.start = nodeBeforeRange.index;\n      range.nodeStart = start;\n    } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n      range.start = firstNodeInRange.index;\n      range.nodeStart = start + 1;\n    } else {\n      range.start = 0;\n      range.nodeStart = 0;\n    }\n    if (!nodeAfterRange) {\n      range.lastNode = true;\n    }\n    if (nodeAfterRange && nodeAfterRange.index !== null) {\n      range.end = nodeAfterRange.index;\n      range.nodeEnd = end;\n    } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n      range.end = lastNodeInRange.index;\n      range.nodeEnd = end - 1;\n    } else {\n      range.end = range.start;\n      range.nodeEnd = range.nodeStart;\n    }\n    range.nodeLength = range.nodeEnd - range.nodeStart;\n    range.length = range.end - range.start;\n    return range;\n  }\n  function rangeOfPathAroundNode(nodes, index) {\n    return rangeOfPathAroundNodes(nodes, index, index);\n  }\n  function makePathsAroundNodes(nodes, start, end, rigid) {\n    var points = [],\n        nodeRange = nodes.slice(start, end),\n        nodeBefore = nodes[start - 1],\n        nodeAfter = nodes[end],\n        node;\n    if (nodeBefore) {\n      points.push(makePoint(nodeBefore));\n    }\n    for (var $__0 = nodeRange[Symbol.iterator](),\n        $__1; !($__1 = $__0.next()).done; ) {\n      node = $__1.value;\n      {\n        points.push(makePoint(node));\n      }\n    }\n    if (nodeAfter) {\n      points.push(makePoint(nodeAfter));\n    }\n    if (points.length < 2) {\n      points.push(points[0]);\n    }\n    return makePaths(points, rigid);\n  }\n  function makePathsAroundNode(nodes, index, rigid) {\n    return makePathsAroundNodes(nodes, index, index, rigid);\n  }\n  function alignNodesWithPath(path, nodes) {\n    var latLng;\n    for (var $__0 = nodes[Symbol.iterator](),\n        $__1; !($__1 = $__0.next()).done; ) {\n      var node = $__1.value;\n      {\n        latLng = path[node.index];\n        console.assert(latLng, 'latLng is not defined');\n        changeNode(node, {\n          lat: latLng.lat(),\n          lng: latLng.lng()\n        });\n      }\n    }\n  }\n  function processPaths(paths) {}\n  function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n    var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n    if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n      return;\n    }\n    var path = drawing._poly.getPath().getArray(),\n        pathRemoveLength = range.length;\n    if (range.lastNode) {\n      pathRemoveLength++;\n    }\n    removePoints(path, range.start, pathRemoveLength);\n    shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n    removeNodes(drawing.nodes, index, nodeRemoveLength);\n    drawing._poly.setPath(path);\n  }\n  function addNodesAndTheirPathsToDrawing(drawing, index, newNodes) {\n    var newPaths = arguments[3] !== (void 0) ? arguments[3] : null;\n    setInitialIndexOfNodes(drawing.nodes, index, newNodes);\n    addNodes(drawing.nodes, index, newNodes);\n    var promise = $q.when();\n    if (newPaths) {\n      promise = promise.then((function(newPaths) {\n        return newPaths;\n      }));\n    } else {\n      promise = promise.then(makePathsAroundNodes.bind(null, drawing.nodes, index, index + newNodes.length, drawing.rigid));\n    }\n    promise = promise.then(function(drawing, index, newNodes, newPaths) {\n      var polyPath = drawing._poly.getPath().getArray(),\n          nodes = drawing.nodes;\n      var shifts = [];\n      var path,\n          lastPoint,\n          i,\n          pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length),\n          pathIndex = pathRange.start;\n      for (var $__0 = newPaths[Symbol.iterator](),\n          $__1; !($__1 = $__0.next()).done; ) {\n        path = $__1.value;\n        {\n          lastPoint = path.pop();\n          addPoints(polyPath, pathIndex, path);\n          pathIndex += path.length;\n          shifts.push(path.length);\n        }\n      }\n      var alignLength = newPaths.length;\n      shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n      if (pathRange.lastNode && lastPoint) {\n        polyPath.push(lastPoint);\n        alignLength++;\n      }\n      var nodesToAlign = nodes.slice(index, index + alignLength);\n      alignNodesWithPath(polyPath, nodesToAlign);\n      drawing._poly.setPath(polyPath);\n      return polyPath;\n    }.bind(null, drawing, index, newNodes));\n    return promise;\n  }\n  function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength) {\n    var nodesToAdd = arguments[3] !== (void 0) ? arguments[3] : [];\n    var pathsToAdd = arguments[4] !== (void 0) ? arguments[4] : null;\n    var polyPath = drawing._poly.getPath().getArray();\n    nodesToAdd = arrayify(nodesToAdd);\n    var promise = $q.when();\n    promise = promise.then(function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n      removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n      return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n    }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd));\n    return promise;\n  }\n  var internalQueue = $q.when();\n  function queue(promise) {\n    internalQueue = internalQueue.then((function(promise) {\n      return promise;\n    }));\n  }\n  function makeNode(colorIndex, latLng) {\n    var index = arguments[2] !== (void 0) ? arguments[2] : null;\n    var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n    return {\n      lat: latLng.lat(),\n      lng: latLng.lng(),\n      index: index,\n      _marker: marker\n    };\n  }\n  self.makeNode = makeNode;\n  function makeDrawing(colorIndex, rigid) {\n    var fill = arguments[2] !== (void 0) ? arguments[2] : false;\n    var poly;\n    if (fill) {\n      poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n    } else {\n      poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n    }\n    return {\n      colorIndex: colorIndex,\n      rigid: rigid,\n      fill: fill,\n      _poly: poly,\n      nodes: []\n    };\n  }\n  self.makeDrawing = makeDrawing;\n  function addDrawings(drawings, index, drawingsToAdd) {\n    splice(drawings, index, 0, drawingsToAdd);\n  }\n  self.addDrawings = self.addDrawing = addDrawings;\n  function addNodesToDrawing(drawing, index) {\n    var nodesToAdd = arguments[2] !== (void 0) ? arguments[2] : [];\n    var pathsToAdd = arguments[3] !== (void 0) ? arguments[3] : null;\n    return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n  }\n  self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n  function removeDrawings(drawings, index, removeLength) {\n    var removedDrawings = splice(drawings, index, removeLength);\n    for (var i = 0; i < removedDrawings.length; i++) {\n      var removedDrawing = removedDrawings[i];\n      removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n      removedDrawing._poly.setMap(null);\n    }\n  }\n  self.removeDrawings = self.removeDrawing = removeDrawings;\n  function removeNodesFromDrawing(drawing, index, removeLength) {\n    var pathsToAdd = arguments[3] !== (void 0) ? arguments[3] : null;\n    return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n  }\n  self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n  function changeNodeOfDrawing(drawing, index, changes) {\n    var pathsToAdd = arguments[3] !== (void 0) ? arguments[3] : null;\n    var node = drawing.nodes[index];\n    changeNode(node, changes);\n    return spliceNodesIntoDrawing(drawing, index, 1, duplicateNode(drawing, node), pathsToAdd);\n  }\n  self.changeNodeOfDrawing = changeNodeOfDrawing;\n  function changeDrawing(drawing, changes) {\n    change(drawing, changes);\n    for (var key in changes) {\n      switch (key) {\n        case 'colorIndex':\n        case 'fill':\n          var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n          drawing._poly.setOptions(options);\n          break;\n        case 'rigid':\n          break;\n      }\n    }\n  }\n  function drawingsToGeoJson(drawings) {\n    var storableDrawings = [];\n    for (var i = 0; i < drawings.length; i++) {\n      var drawing = drawings[i];\n      var storableDrawing = {};\n      for (var key in drawing) {\n        if (key === '_poly') {\n          storableDrawing.path = MapSvc.geometry.encoding.encodePath(drawing._poly.getPath());\n        } else if (key === 'nodes') {\n          var storableNodes = [];\n          for (var j = 0; j < drawing.nodes.length; j++) {\n            var node = drawing.nodes[j];\n            var storableNode = {};\n            for (var nodeKey in node) {\n              if (key[0] !== '_' && key[0] !== '$' && node.hasOwnProperty(nodeKey)) {\n                storableNode[nodeKey] = node[nodeKey];\n              }\n            }\n            storableNodes[i] = storableNode;\n          }\n        } else if (drawing.hasOwnProperty(key)) {\n          storableDrawing[key] = drawing[key];\n        }\n      }\n      return storableDrawing;\n    }\n    $localStorage.drawings = storableDrawings;\n  }\n  function geoJsonToDrawings(drawings) {\n    var storedDrawings = $localStorage.drawings || {};\n    for (var i = 0; i < storedDrawings.length; i++) {\n      var storedDrawing = storedDrawings[i];\n      var path = MapSvc.geometry.encoding.decodePath(storedDrawing.path);\n      var drawing = self.makeDrawing(storedDrawing.colorIndex, storedDrawing.rigid, storedDrawing.fill, path);\n      for (var j = 0; j < storedDrawing.nodes.length; j++) {\n        var storedNode = storedDrawing[j];\n        var latLng = new MapSvc.LatLng(storedNode.lat, storedNode.lng);\n        var node = self.makeNode(storedDrawing.colorIndex, latLng);\n        drawing.nodes.push(node);\n      }\n      self.drawings.push(drawing);\n    }\n  }\n  function rgbaColorToString(rgba) {\n    return (\"rgba(\" + Math.round(rgba.r * 255) + \",\" + Math.round(rgba.g * 255) + \",\" + Math.round(rgba.b * 255) + \",\" + rgba.a + \")\");\n  }\n  function shiftIndices(array, index, shift) {\n    for (var i = index; i < array.length; i++) {\n      array[i].index += shift;\n    }\n  }\n  function makeIcon(colorIndex) {\n    var color = ColorSvc.colors[colorIndex];\n    return {\n      path: MapSvc.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n  }\n  function makeMarkerOptions(colorIndex, latLng) {\n    return {\n      clickable: true,\n      crossOnDrag: false,\n      cursor: 'pointer',\n      draggable: true,\n      flat: true,\n      icon: makeIcon(colorIndex),\n      map: MapSvc.map,\n      position: latLng\n    };\n  }\n  function makePolyOptions(colorIndex, fill) {\n    var value = {\n      clickable: true,\n      draggable: false,\n      editable: false,\n      map: MapSvc.map\n    };\n    var color = ColorSvc.colors[colorIndex];\n    if (fill) {\n      value.fillColor = rgbaColorToString(color);\n      value.strokeWeight = 0;\n    } else {\n      value.strokeColor = rgbaColorToString(color);\n      value.strokeWeight = color.weight;\n    }\n    return value;\n  }\n  self.forceCreateNewDrawing = false;\n  self.shouldCreateNewDrawing = (function() {\n    if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n      return true;\n    }\n    var latestDrawing = self.drawings[self.drawings.length - 1];\n    return (latestDrawing && latestDrawing.colorIndex !== ColorSvc.activeColorIndex());\n  });\n  self.drawings;\n}).controller('DrawingCtrl', function($scope, $localStorage, DrawingSvc, ColorSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n  var activeDrawingIndex = -1;\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n    var rigid = false,\n        fill = false;\n    if (DrawingSvc.shouldCreateNewDrawing()) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex++;\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex, newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n    var drawing = drawings[activeDrawingIndex];\n    var newNode = DrawingSvc.makeNode(colorIndex, param.latLng);\n    DrawingSvc.addNodeToDrawing(drawing, drawing.nodes.length, newNode);\n    return;\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0],\n        drawing = drawings[drawingIndex],\n        originalNode = drawing.nodes[nodeIndex],\n        latLng = event.latLng;\n    DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, {\n      lat: latLng.lat(),\n      lng: latLng.lng()\n    });\n  }\n  $scope.$on('map:click', addNode);\n  $scope.$on('action:clear', function($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex = -1;\n  });\n  $scope.marker = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {click: function($params) {}};\n});\n\n//# sourceMappingURL=../../sourcemaps/drawing/drawing.js.map","\"use strict\";\nangular.module('bndry.geo', ['bndry.map']).service('GeolocationSvc', function($q) {\n  this.getLocation = function() {\n    var deferred = $q.defer();\n    if ('geolocation' in navigator) {\n      navigator.geolocation.getCurrentPosition(function(position) {\n        deferred.resolve(position);\n      }, function(error) {\n        deferred.reject(error);\n      });\n    } else {\n      deferred.reject(false);\n    }\n    return deferred.promise;\n  };\n}).service('GeocodeSvc', function($q, MapSvc) {\n  this.geocode = function(location) {\n    var geocoder = new MapSvc.Geocoder();\n    var deferred = $q.defer();\n    geocoder.geocode({location: location}, function(results, status) {\n      if (status === MapSvc.GeocoderStatus.OK) {\n        deferred.resolve(results);\n      } else {\n        deferred.reject(status);\n      }\n    });\n    return deferred.promise;\n  };\n});\n\n//# sourceMappingURL=../../sourcemaps/geo/geo.js.map","\"use strict\";\nangular.module('bndry.history', []).service('HistorySvc', function() {\n  \"use strict\";\n  var commands = [],\n      index = -1,\n      isExecuting = false,\n      callback,\n      execute;\n  execute = function(command, action) {\n    if (!command || typeof command[action] !== \"function\") {\n      return this;\n    }\n    isExecuting = true;\n    command[action]();\n    isExecuting = false;\n    return this;\n  };\n  return {\n    add: function(command) {\n      if (isExecuting) {\n        return this;\n      }\n      commands.splice(index + 1, commands.length - index);\n      commands.push(command);\n      index = commands.length - 1;\n      if (callback) {\n        callback();\n      }\n      return this;\n    },\n    setCallback: function(callbackFunc) {\n      callback = callbackFunc;\n    },\n    undo: function() {\n      var command = commands[index];\n      if (!command) {\n        return this;\n      }\n      execute(command, \"undo\");\n      index -= 1;\n      if (callback) {\n        callback();\n      }\n      return this;\n    },\n    redo: function() {\n      var command = commands[index + 1];\n      if (!command) {\n        return this;\n      }\n      execute(command, \"redo\");\n      index += 1;\n      if (callback) {\n        callback();\n      }\n      return this;\n    },\n    clear: function() {\n      var prev_size = commands.length;\n      commands = [];\n      index = -1;\n      if (callback && (prev_size > 0)) {\n        callback();\n      }\n    },\n    hasUndo: function() {\n      return index !== -1;\n    },\n    hasRedo: function() {\n      return index < (commands.length - 1);\n    },\n    getCommands: function() {\n      return commands;\n    }\n  };\n});\n\n//# sourceMappingURL=../../sourcemaps/history/history.js.map","\"use strict\";\nangular.module('bndry.image', ['ngStorage', 'bndry.map', 'bndry.drawing', 'bndry.color']).service('ImageSvc', function($http, $document, $localStorage, MapSvc, DrawingSvc, ColorSvc) {\n  var self = this;\n  self.pxSize = function(maxWidth, maxHeight) {\n    var ratio = 3.5 / 5;\n    return {\n      ratio: ratio,\n      width: (ratio >= 1) ? maxWidth : Math.round(ratio * maxWidth),\n      height: (ratio < 1) ? maxHeight : Math.round(1 / ratio * maxHeight)\n    };\n  };\n  self.generateUrl = function() {\n    if (!DrawingSvc.drawings) {\n      return;\n    }\n    var path = 'https://maps.googleapis.com/maps/api/staticmap';\n    var params = [];\n    var pxSize = self.pxSize(640, 640);\n    var i,\n        j;\n    var rule,\n        urlRule,\n        styler,\n        key,\n        value;\n    for (i = 0; i < $localStorage.style.length; i++) {\n      rule = $localStorage.style[i];\n      urlRule = [];\n      if ('featureType' in rule && rule.featureType !== 'all') {\n        urlRule.push('feature:' + rule.featureType);\n      }\n      if ('elementType' in rule && rule.elementType !== 'all') {\n        urlRule.push('element:' + rule.elementType);\n      }\n      for (j = 0; j < rule.stylers.length; j++) {\n        styler = rule.stylers[j];\n        for (key in styler) {\n          value = styler[key];\n          if (key === 'color') {\n            value = '0x' + value.substring(1);\n          }\n          urlRule.push(key + ':' + value);\n        }\n      }\n      urlRule = urlRule.join('|');\n      if (urlRule !== '') {\n        params.push('style=' + urlRule);\n      }\n    }\n    var drawing,\n        urlPath,\n        polyPath,\n        encodedPath,\n        color,\n        hex;\n    var bounds = new MapSvc.LatLngBounds();\n    for (i = 0; i < DrawingSvc.drawings.length; i++) {\n      urlPath = [];\n      drawing = DrawingSvc.drawings[i];\n      polyPath = drawing._poly.getPath().getArray();\n      for (j = 0; j < polyPath.length; j++) {\n        bounds.extend(polyPath[j]);\n      }\n      encodedPath = MapSvc.geometry.encoding.encodePath(polyPath);\n      color = $localStorage.colors[drawing.colorIndex];\n      debugger;\n      hex = '0x' + ColorSvc.convert.rgba(color).to.hex32();\n      if (drawing.polygon) {\n        urlPath.push('fillcolor:' + hex);\n      } else {\n        urlPath.push('color:' + hex);\n        urlPath.push('weight:' + color.weight);\n      }\n      urlPath.push('enc:' + encodedPath);\n      urlPath = urlPath.join('|');\n      if (urlPath) {\n        params.push('path=' + urlPath);\n      }\n    }\n    var northEast = bounds.getNorthEast();\n    var southWest = bounds.getSouthWest();\n    var computeHeading = MapSvc.geometry.spherical.computeHeading;\n    var heading = Math.abs(computeHeading(northEast, southWest) + computeHeading(southWest, northEast)) / 2;\n    if ((45 <= heading && heading < 135) === (pxSize.ratio >= 1)) {\n      params.push('size=' + pxSize.height + 'x' + pxSize.width);\n    } else {\n      params.push('size=' + pxSize.width + 'x' + pxSize.height);\n    }\n    params.push('format=jpg');\n    params.push('scale=2');\n    params.push('sensor=true');\n    return encodeURI(path + '?' + params.join('&'));\n  };\n  self.generatePdf = function(locality, number, imageUrl) {\n    if (!imageUrl) {\n      imageUrl = self.generateUrl();\n    }\n    console.info(imageUrl);\n    var legend = [];\n    for (var $__0 = ColorSvc.colors[Symbol.iterator](),\n        $__1; !($__1 = $__0.next()).done; ) {\n      var color = $__1.value;\n      {\n        var entry = {\n          name: color.name,\n          label: color.label,\n          color: (\"#\" + ColorSvc.convert.rgba(color).to.hex24())\n        };\n        legend.push(entry);\n      }\n    }\n    var data = {\n      serif: true,\n      locality: locality,\n      notes: \"See attached form for Do Not Calls.\\nAdd new Do Not Calls as you find them.\",\n      legend: legend,\n      number: number,\n      image: imageUrl\n    };\n    var form = document.createElement('form');\n    form.style = 'display: none;';\n    form.enctype = 'x-www-form-urlencoded';\n    form.action = 'http://boundariesapp.herokuapp.com/pdf';\n    form.method = 'POST';\n    var input = document.createElement('input');\n    input.name = 'json';\n    input.type = 'text';\n    input.value = angular.toJson(data);\n    form.appendChild(input);\n    document.body.appendChild(form);\n    form.submit();\n    document.body.removeChild(form);\n  };\n}).controller('ImageCtrl', function($scope, ImageSvc) {\n  $scope.locality = '';\n  $scope.number = '';\n  $scope.downloadPdf = (function() {\n    var locality = prompt('Locality (for example, the name of the city)', '');\n    if (locality === null) {\n      return;\n    }\n    var number = prompt('Territory number (for example, MR-1056)', '');\n    if (number === null) {\n      return;\n    }\n    ImageSvc.generatePdf(locality, number, ImageSvc.generateUrl());\n  });\n});\n\n//# sourceMappingURL=../../sourcemaps/image/image.js.map","\"use strict\";\nangular.module('bndry.map', ['ngStorage']).service('MapSvc', function($rootScope) {\n  function makeIcon(color) {\n    return {\n      path: self.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: color,\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n  }\n  function makeMarkerOptions(lat, lng, color) {\n    var clickable = false,\n        cursor = 'pointer',\n        draggable = false;\n    return {\n      clickable: clickable,\n      crossOnDrag: false,\n      cursor: cursor,\n      draggable: draggable,\n      flat: true,\n      icon: makeIcon(color),\n      map: self.map,\n      position: new self.LatLng(lat, lng)\n    };\n  }\n  function addListener(eventName) {\n    self.map.addListener(eventName, function(mouseEvent) {\n      $rootScope.$broadcast('map:' + eventName, mouseEvent);\n    });\n  }\n  var self = this;\n  angular.extend(self, google.maps);\n  self.map = new self.Map(document.getElementById('map_canvas'));\n  self.placesSvc = new self.places.PlacesService(self.map);\n  self.autocompleteSvc = new self.places.AutocompleteService();\n  var events = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle', 'maptypeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick', 'tilesloaded', 'tilt_changed', 'zoom_changed'];\n  events.forEach(addListener);\n}).controller('MapCtrl', function($scope, $rootScope, $localStorage, MapSvc) {\n  $localStorage.$default({\n    lat: 0,\n    lng: 0,\n    zoom: 10,\n    mapTypeId: MapSvc.MapTypeId.ROADMAP,\n    style: [{'stylers': [{'visibility': 'off'}]}, {\n      'featureType': 'landscape',\n      'stylers': [{'visibility': 'on'}, {'color': '#ffffff'}]\n    }, {\n      'featureType': 'road',\n      'stylers': [{'visibility': 'on'}]\n    }, {\n      'elementType': 'geometry.fill',\n      'stylers': [{'color': '#ffffff'}]\n    }, {\n      'featureType': 'road',\n      'elementType': 'geometry.stroke',\n      'stylers': [{'color': '#808080'}]\n    }, {\n      'elementType': 'labels.text.stroke',\n      'stylers': [{'color': '#ffffff'}]\n    }, {\n      'elementType': 'labels.text.fill',\n      'stylers': [{'color': '#000000'}]\n    }, {\n      'featureType': 'water',\n      'stylers': [{'visibility': 'on'}, {'color': '#40bfbf'}]\n    }, {\n      'featureType': 'water',\n      'elementType': 'labels.text.stroke',\n      'stylers': [{'color': '#ffffff'}]\n    }, {\n      'featureType': 'road.local',\n      'elementType': 'geometry',\n      'stylers': [{'color': '#dfdfdf'}]\n    }, {\n      'featureType': 'road.local',\n      'elementType': 'geometry.stroke',\n      'stylers': [{'visibility': 'off'}]\n    }, {\n      'featureType': 'landscape.man_made',\n      'stylers': [{'visibility': 'off'}]\n    }]\n  });\n  $scope.$on('map:idle', function() {\n    var center = MapSvc.map.getCenter();\n    var zoom = MapSvc.map.getZoom();\n    $localStorage.lat = center.lat();\n    $localStorage.lng = center.lng();\n    $localStorage.zoom = zoom;\n  });\n  $scope.$on('map:maptypeid_changed', function() {\n    var mapTypeId = MapSvc.map.getMapTypeId();\n    $localStorage.mapTypeId = mapTypeId;\n  });\n  var options = {\n    center: new MapSvc.LatLng($localStorage.lat, $localStorage.lng),\n    disableDefaultUI: true,\n    disableDoubleClickZoom: true,\n    draggableCursor: 'crosshair',\n    draggingCursor: 'move',\n    mapTypeId: $localStorage.mapTypeId,\n    zoomControl: true,\n    zoomControlOptions: {position: MapSvc.ControlPosition.LEFT_CENTER},\n    scaleControl: true,\n    zoom: $localStorage.zoom\n  };\n  MapSvc.map.setOptions(options);\n  var customMapStyle = new MapSvc.StyledMapType($localStorage.style, {name: 'Custom'});\n  MapSvc.map.mapTypes.set('custom', customMapStyle);\n}).controller('MapActionCtrl', function($scope, MapSvc) {\n  $scope.setMapTypeId = function(mapTypeId) {\n    if (mapTypeId in MapSvc.MapTypeId) {\n      console.log(mapTypeId, 'in MapSvc.mapTypeId');\n      mapTypeId = MapSvc.MapTypeId[mapTypeId];\n    }\n    MapSvc.map.setMapTypeId(mapTypeId);\n  };\n});\n\n//# sourceMappingURL=../../sourcemaps/map/map.js.map","\"use strict\";\nangular.module('bndry.mode', []).controller('ModeCtrl', function($scope) {\n  $scope.rigid = false;\n  $scope.polygon = false;\n});\n\n//# sourceMappingURL=../../sourcemaps/mode/mode.js.map","\"use strict\";\nangular.module('bndry.search', ['ngSanitize', 'bndry.map']).directive('focusOn', function($parse) {\n  return {\n    restrict: 'A',\n    link: function(scope, elem, attr) {\n      var focusOn = $parse(attr.focusOn);\n      scope.$watch(focusOn, function(newVal) {\n        if (newVal === undefined) {\n          return;\n        }\n        if (newVal) {\n          elem[0].focus();\n        } else {\n          elem[0].blur();\n        }\n      });\n    }\n  };\n}).service('SearchSvc', function($q, MapSvc) {\n  this.search = function(input) {\n    var deferred = $q.defer();\n    if (input.length <= 0) {\n      deferred.resolve([]);\n    } else {\n      var request = {input: input};\n      request.bounds = MapSvc.map.getBounds();\n      MapSvc.autocompleteSvc.getPlacePredictions(request, function(suggestions, status) {\n        if (status === MapSvc.places.PlacesServiceStatus.OK) {\n          deferred.resolve(suggestions);\n        } else if (status === MapSvc.places.PlacesServiceStatus.ZERO_RESULTS) {\n          deferred.reject('No Results');\n        } else {\n          deferred.reject('An Error Occurred');\n        }\n      });\n    }\n    return deferred.promise;\n  };\n  this.loadPlaceFromReference = function(reference) {\n    if (!reference) {\n      return;\n    }\n    if (reference) {\n      MapSvc.placesSvc.getDetails({reference: reference}, function(place, status) {\n        if (status === MapSvc.places.PlacesServiceStatus.OK) {\n          if (place.geometry.viewport) {\n            MapSvc.map.fitBounds(place.geometry.viewport);\n          } else if (place.geometry.location) {\n            MapSvc.map.panTo(place.geometry.location);\n          }\n        }\n      });\n    }\n  };\n}).controller('SearchCtrl', function($scope, $sce, $sessionStorage, SearchSvc) {\n  function throttledSearch(newVal) {\n    if (!newVal) {\n      return;\n    } else if (!resolved) {\n      queue = newVal;\n      return;\n    }\n    last = newVal;\n    resolved = false;\n    SearchSvc.search(newVal).then(formatSuggestions, errorMessage).then(function() {\n      resolved = true;\n      if (queue !== last) {\n        throttledSearch(queue);\n        queue = '';\n      }\n    });\n  }\n  function formatSuggestions(suggestions) {\n    for (var i = 0; i < suggestions.length; i++) {\n      var desc = suggestions[i].description;\n      suggestions[i].description = '';\n      var index = 0;\n      for (var j = 0; j < suggestions[i].matched_substrings.length; j++) {\n        var offset = suggestions[i].matched_substrings[j].offset;\n        var length = suggestions[i].matched_substrings[j].length;\n        suggestions[i].description += desc.slice(index, offset) + '<b>' + desc.substr(offset, length) + '</b>';\n        index = offset + length;\n      }\n      suggestions[i].description += desc.slice(index);\n      suggestions[i].description = '<span>' + suggestions[i].description + '</span>';\n      suggestions[i].description = $sce.trustAsHtml(suggestions[i].description);\n    }\n    $scope.suggestions = suggestions;\n  }\n  function errorMessage(message) {\n    if (typeof message === 'string') {\n      $scope.suggestions = [{\n        description: $sce.trustAsHtml('<i>' + message + '</i>'),\n        error: true\n      }];\n    }\n  }\n  var resolved = true,\n      queue = '',\n      last = '';\n  $scope.$tempStorage = $sessionStorage.$default({\n    query: '',\n    active: -1\n  });\n  $scope.keydown = function(e) {\n    var enter = (e.which === 13),\n        up = (e.which === 38),\n        down = (e.which === 40);\n    if (enter || up || down) {\n      e.preventDefault();\n    } else {\n      $scope.$tempStorage.active = 0;\n      return;\n    }\n    if ($scope.suggestions[$scope.$tempStorage.active]) {\n      if (enter) {\n        $scope.loadOnMap($scope.suggestions[$scope.$tempStorage.active].reference);\n        $scope.show.header = '';\n      } else if (up && $scope.$tempStorage.active > -1) {\n        $scope.$tempStorage.active--;\n      } else if (down && $scope.$tempStorage.active < $scope.suggestions.length - 1) {\n        $scope.$tempStorage.active++;\n      }\n    }\n  };\n  $scope.loadOnMap = SearchSvc.loadPlaceFromReference;\n  $scope.$watch('$tempStorage.query', throttledSearch);\n});\n\n//# sourceMappingURL=../../sourcemaps/search/search.js.map","\"use strict\";\nangular.module('bndry.status', ['bndry.map', 'bndry.geo']).directive('statusBar', function($interval) {\n  return {\n    restrict: 'E',\n    scope: {\n      hide: '@',\n      value: '@'\n    },\n    template: '<div ng-style=\"{width: value * 100 + \\'%\\'}\" style=\"height: 100%; position: absolute;\" ng-hide=\"hide\"></div>',\n    link: function(scope) {\n      $interval(function() {\n        scope.value = Math.random();\n      }, 1000);\n    }\n  };\n}).controller('StatusCtrl', function($scope, $timeout, MapSvc, GeocodeSvc) {\n  var locality = '';\n  $scope.locality = function() {\n    return locality;\n  };\n  $scope.$on('map:idle', function() {\n    GeocodeSvc.geocode(MapSvc.map.getCenter()).then(function(results) {\n      var localityOptions = ['administrative_area_level_3', 'administrative_area_level_2', 'administrative_area_level_1', 'country'];\n      locality = '';\n      results.forEach(function(result) {\n        if (locality) {\n          return;\n        }\n        for (var i = 0; i < localityOptions.length; i++) {\n          if (result.types.indexOf(localityOptions[i]) > -1) {\n            locality = result.formatted_address;\n          }\n          if (locality) {\n            return false;\n          }\n        }\n      });\n    }, function() {\n      locality = 'Unknown Locality';\n    });\n  });\n});\n\n//# sourceMappingURL=../../sourcemaps/status/status.js.map","\"use strict\";\nangular.module('bndry', ['ngTouch', 'ngStorage', 'ui.map', 'ngAnimate', 'bndry.action', 'bndry.color', 'bndry.drawing', 'bndry.geo', 'bndry.history', 'bndry.image', 'bndry.map', 'bndry.mode', 'bndry.search', 'bndry.status']).directive('noScroll', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, elem) {\n      elem.on('touchstart wheel', function(e) {\n        e.preventDefault();\n      });\n    }\n  };\n}).controller('MasterCtrl', function($scope, $localStorage, ColorSvc, DrawingSvc) {\n  $scope.$storage = $localStorage;\n  $scope.fillActiveColor = function() {\n    var hex = ColorSvc.convert.rgba(ColorSvc.activeColor()).to.hex24();\n    return (\"#\" + hex);\n  };\n  $scope.shouldCreateNewDrawing = DrawingSvc.shouldCreateNewDrawing;\n  $scope.toggleForceCreateNewDrawing = (function() {\n    DrawingSvc.forceCreateNewDrawing = !DrawingSvc.forceCreateNewDrawing;\n  });\n  $scope.show = {\n    header: '',\n    footer: ''\n  };\n  $scope.setShowHeader = function(show) {\n    if ($scope.show.header === show) {\n      $scope.show.header = '';\n    } else {\n      $scope.show.header = show;\n    }\n  };\n  $scope.setShowFooter = function(show) {\n    if ($scope.show.footer === show) {\n      $scope.show.footer = '';\n    } else {\n      $scope.show.footer = show;\n    }\n  };\n}).run(function() {\n  window.addEventListener('orientationchange', function() {\n    window.scrollTo(0, 0);\n  });\n});\n\n//# sourceMappingURL=../sourcemaps/app.js.map"],"file":"script.min.js","sourceRoot":"/source/"}