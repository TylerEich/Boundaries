/*
 Boundaries v1.0.0
 (c) 2013-2014 Tyler Eich https://github.com/TylerEich/Boundaries
 License: MIT
*/
{"version":3,"sources":["app.js","action/action.js","color/color.js","drawing/drawing.js","geo/geo.js","history/history.js","image/image.js","map/map.js","search/search.js","shape/shape.js","status/status.js"],"names":[],"mappings":"AAAA;;AAEA;AACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA;AACA,QAAA,qBAAA;CACA;AACA,CAAA,CAAA;AACA,YAAA,UAAA,GAAA,WAAA;CACA;EACA;EACA;GACA;GACA;;GAEA;IACA;KACA;MACA;MACA;KACA;IACA;GACA;GACA;IACA;IACA;;IAEA;KACA;KACA;IACA;GACA;EACA;CACA;AACA,CAAA,CAAA;AACA,YAAA,WAAA;EACA;IACA;IACA;IACA;MACA;MACA;QACA;UACA;;QAEA;MACA;IACA;EACA;AACA;AACA,YAAA,QAAA;EACA;IACA;IACA;MACA;QACA;MACA;IACA;EACA;AACA;AACA,aAAA,UAAA,GAAA,8DAAA;EACA;;EAEA;IACA;IACA;EACA;EACA;EACA;IACA;EACA;;EAEA;IACA;EACA;EACA;IACA;IACA;EACA;;EAEA;IACA;MACA;IACA;MACA;IACA;EACA;EACA;IACA;MACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;AACA;EACA;IACA;EACA;CACA;AACA;;;AAGA;ACvHA;AACA,aAAA,UAAA,GAAA,uCAAA;EACA;IACA;IACA;EACA;;CAEA;EACA;IACA;MACA;IACA;EACA;;CAEA;EACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;ACtBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAA,QAAA,GAAA,kBAAA;EACA;EACA;;EAEA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;IACA;EACA;;EAEA;IACA;MACA;QACA;QACA;QACA;;MAEA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;;MAEA;UACA;MACA;UACA;UACA;UACA;UACA;UACA;MACA;;MAEA;;MAEA;IACA;IACA;MACA;;MAEA;IACA;IACA;MACA;;MAEA;IACA;EACA;EACA;IACA;MACA;QACA;QACA;QACA;;MAEA;;MAEA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA;;MAEA;QACA;MACA;QACA;QACA;QACA;UACA;UACA;UACA;QACA;QACA;MACA;;MAEA;IACA;IACA;MACA;IACA;IACA;MACA;MACA;;MAEA;IACA;EACA;;EAEA;EACA;;EAEA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;EACA;EACA;EACA;IACA;EACA;EACA;IACA;EACA;EACA;IACA;EACA;AACA,CAAA,CAAA;EACA,aAAA,SAAA,GAAA,wCAAA;IACA;;IAEA;MACA;QACA;MACA;MACA;MACA;IACA;IACA;IACA;EACA,CAAA,CAAA;;AAEA;AC1LA;;AAEA;AACA,UAAA,aAAA,GAAA,+BAAA;EACA;EACA;;EAEA;IACA;MACA;MACA;IACA;;IAEA;MACA;MACA;MACA;IACA;;IAEA;;IAEA;MACA;QACA;;QAEA;UACA;YACA;;YAEA;YACA;UACA;YACA;YACA;YACA;YACA;UACA;YACA;YACA;UACA;QACA;QACA;;QAEA;UACA;YACA;YACA;YACA;UACA;YACA;YACA;UACA;QACA;IACA;;IAEA;;IAEA;;IAEA;MACA;MACA;IACA;EACA;AACA,CAAA,CAAA;AACA,UAAA,UAAA,GAAA,yFAAA;EACA;;;;EAIA;IACA;MACA;;IAEA;MACA;;IAEA;MACA;;IAEA;;IAEA;EACA;;EAEA;IACA;MACA;QACA;MACA;IACA;EACA;;EAEA;IACA;MACA;IACA;MACA;IACA;EACA;;;;EAIA;EACA;EACA;EACA;EACA;IACA;MACA;MACA;MACA;MACA;;MAEA;IACA;IACA;EACA;;EAEA;IACA;EACA;;EAEA;IACA;EACA;;;;EAIA;IACA;MACA;;IAEA;MACA;;MAEA;IACA;;IAEA;IACA;MACA;QACA;QACA;;MAEA;QACA;UACA;UACA;MACA;QACA;MACA;OACA;YACA;YACA;MACA;MACA;MACA;IACA;;IAEA;EACA;;;;EAIA;EACA;IACA;IACA;MACA;IACA;;IAEA;EACA;EACA;;EAEA;IACA;MACA;;IAEA;IACA;QACA;MACA;;IAEA;EACA;EACA;;EAEA;IACA;MACA;MACA;;MAEA;IACA;IACA;IACA;MACA;MACA;MACA;QACA;QACA;MACA;IACA;EACA;;EAEA;IACA;EACA;;;;EAIA;IACA;MACA;MACA;;IAEA;MACA;QACA;QACA;MACA;IACA;MACA;IACA;IACA;MACA;IACA;EACA;;EAEA;IACA;IACA;MACA;IACA;EACA;;EAEA;IACA;;IAEA;MACA;IACA;IACA;EACA;;;;EAIA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;;IAEA;MACA;MACA;MACA;MACA;;IAEA;MACA;IACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;;IAEA;MACA;IACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;MACA;MACA;IACA;;IAEA;IACA;;IAEA;EACA;;EAEA;IACA;EACA;;;;EAIA;IACA;MACA;MACA;MACA;MACA;;IAEA;MACA;IACA;IACA;MACA;IACA;IACA;MACA;IACA;;IAEA;MACA;IACA;;IAEA;EACA;;EAEA;IACA;EACA;;;;EAIA;IACA;;IAEA;MACA;MACA;QACA;;QAEA;MACA;MACA;QACA;QACA;MACA;IACA;EACA;;;;EAIA;IACA;;IAEA;MACA;IACA;IACA;MACA;;IAEA;IACA;MACA;IACA;;IAEA;;IAEA;IACA;;IAEA;;IAEA;;IAEA;EACA;;EAEA;IACA;MACA;;IAEA;IACA;MACA;MACA;;IAEA;MACA;;MAEA;MACA;;MAEA;MACA;IACA;;IAEA;IACA;;IAEA;MACA;MACA;IACA;;IAEA;IACA;;IAEA;;IAEA;;IAEA;EACA;;;;EAIA;IACA;MACA;;IAEA;MACA;;IAEA;MACA;QACA;;QAEA;UACA;QACA;UACA;QACA;;QAEA;QACA;;QAEA;QACA;UACA;QACA;UACA;QACA;;QAEA;UACA;YACA;UACA;QACA;MACA;IACA;EACA;;;;EAIA;EACA;EACA;EACA;EACA;EACA;IACA;MACA;;IAEA;MACA;;MAEA;IACA;;IAEA;IACA;QACA;MACA;;IAEA;EACA;EACA;;;;EAIA;EACA;IACA;MACA;;IAEA;;IAEA;MACA;IACA;MACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;;EAEA;IACA;MACA;IACA;EACA;EACA;;EAEA;IACA;MACA;QACA;QACA;UACA;UACA;UACA;QACA;MACA;IACA;EACA;EACA;;EAEA;IACA;;IAEA;MACA;MACA;MACA;QACA;QACA;QACA;MACA;;QAEA;MACA;IACA;;IAEA;EACA;;;;EAIA;IACA;MACA;;IAEA;;IAEA;MACA;MACA;MACA;MACA;IACA;EACA;EACA;;EAEA;IACA;MACA;;IAEA;MACA;;IAEA;EACA;EACA;;EAEA;IACA;MACA;;IAEA;EACA;EACA;;EAEA;IACA;MACA;;IAEA;MACA;QACA;MACA;IACA;;IAEA;EACA;EACA;;;;EAIA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;;IAEA;EACA;;EAEA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;;IAEA;EACA;;EAEA;IACA;MACA;MACA;MACA;MACA;IACA;;IAEA;IACA;;IAEA;MACA;MACA;MACA;IACA;MACA;MACA;IACA;;IAEA;EACA;;;;EAIA;IACA;MACA;IACA;;IAEA;MACA;QACA;UACA;QACA;;QAEA;QACA;UACA;YACA;cACA;cACA;YACA;UACA;QACA;;QAEA;UACA;UACA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;UACA;YACA;YACA;YACA;YACA;UACA;QACA;QACA;MACA;IACA;;IAEA;EACA;EACA;;EAEA;IACA;MACA;;MAEA;IACA;;IAEA;IACA;IACA;MACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;UACA;YACA;YACA;UACA;QACA;;QAEA;QACA;UACA;QACA;UACA;QACA;QACA;UACA;YACA;UACA;QACA;;QAEA;QACA;UACA;YACA;YACA;;UAEA;QACA;;QAEA;;QAEA;MACA;IACA;;IAEA;EACA;EACA;;;;EAIA;IACA;EACA;;;;EAIA;EACA;IACA;IACA;MACA;MACA;MACA;QACA;QACA;QACA;QACA;QACA;MACA;IACA;EACA;EACA;;EAEA;IACA;EACA;EACA;;;;EAIA;;EAEA;IACA;MACA;IACA;IACA;IACA;MACA;MACA;MACA;IACA;EACA;;EAEA;;EAEA;AACA,CAAA,CAAA;AACA;AACA,aAAA,WAAA,GAAA,4FAAA;EACA;IACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;;EAEA;;EAEA;EACA;IACA;EACA;EACA;IACA;EACA;;EAEA;IACA;MACA;IACA;MACA;IACA;EACA;EACA;EACA;EACA;;EAEA;IACA;;IAEA;MACA;;IAEA;IACA;MACA;MACA;MACA;MACA;IACA;;IAEA;MACA;QACA;QACA;QACA;;QAEA;;QAEA;UACA;YACA;;YAEA;cACA;cACA;YACA;UACA;;UAEA;YACA;cACA;cACA;YACA;;YAEA;UACA;QACA;MACA;IACA;EACA;EACA;IACA;MACA;MACA;;IAEA;MACA;QACA;UACA;YACA;YACA;UACA;UACA;YACA;YACA;UACA;QACA;;QAEA;UACA;YACA;UACA;;UAEA;YACA;UACA;QACA;MACA;IACA;EACA;;EAEA;EACA;IACA;IACA;EACA;;EAEA;IACA;;IAEA;MACA;QACA;;MAEA;IACA;MACA;IACA;EACA;;EAEA;IACA;MACA;IACA;IACA;EACA;EACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;;AAEA;ACj8BA;EACA,UAAA,cAAA,GAAA,OAAA;IACA;MACA;;MAEA;QACA;UACA;QACA;UACA;QACA;MACA;QACA;MACA;;MAEA;IACA;EACA,CAAA,CAAA;EACA,UAAA,UAAA,GAAA,iBAAA;IACA;MACA;MACA;;GAEA;;GAEA;IACA;GACA;IACA;GACA;;;MAGA;QACA;UACA;QACA;UACA;QACA;MACA;;MAEA;IACA;EACA,CAAA,CAAA;;AAEA;AC5CA;AACA;EACA,UAAA,UAAA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;;MAEA;QACA;QACA;QACA;;QAEA;QACA;;MAEA;QACA;UACA;QACA;QACA;;QAEA;;QAEA;QACA;MACA;;MAEA;;QAEA;QACA;QACA;QACA;UACA;YACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;UACA;UACA;YACA;UACA;UACA;QACA;;QAEA;QACA;QACA;QACA;UACA;QACA;;QAEA;QACA;QACA;QACA;UACA;UACA;YACA;UACA;UACA;UACA;UACA;YACA;UACA;UACA;QACA;;QAEA;QACA;QACA;QACA;UACA;UACA;YACA;UACA;UACA;UACA;UACA;YACA;UACA;UACA;QACA;;QAEA;QACA;QACA;QACA;UACA;;UAEA;UACA;;UAEA;YACA;UACA;QACA;;QAEA;UACA;QACA;;QAEA;UACA;QACA;;QAEA;UACA;QACA;MACA;IACA;;MAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;ACpJA;EACA,UAAA,QAAA,GAAA,0FAAA;IACA;;IAEA;MACA;QACA;QACA;QACA;MACA;IACA;IACA;MACA;QACA;MACA;;MAEA;;MAEA;;MAEA;MACA;QACA;;QAEA;QACA;UACA;QACA;QACA;UACA;QACA;;QAEA;QACA;UACA;YACA;;YAEA;cACA;YACA;;YAEA;UACA;QACA;;QAEA;;QAEA;QACA;UACA;QACA;MACA;;MAEA;MACA;MACA;MACA;QACA;QACA;QACA;;QAEA;UACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;UACA;UACA;QACA;UACA;UACA;QACA;QACA;;QAEA;;QAEA;QACA;UACA;QACA;MACA;;MAEA;MACA;MACA;MACA;;GAEA;GACA;;MAEA;MACA;;MAEA;MACA;MACA;;MAEA;IACA;IACA;MACA;QACA;MACA;;MAEA;MACA;QACA;UACA;UACA;UACA;QACA;QACA;MACA;MACA;QACA;QACA;QACA;QACA;QACA;QACA;MACA;;MAEA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;;MAEA;;MAEA;MACA;MACA;;GAEA;IACA;IACA;IACA;GACA;IACA;EACA,CAAA,CAAA;EACA,aAAA,SAAA,GAAA,uBAAA;IACA;GACA;GACA;EACA;;IAEA;MACA;MACA;QACA;MACA;MACA;MACA;QACA;MACA;;GAEA;IACA;EACA,CAAA,CAAA;;AAEA;AC5KA;;AAEA;;AAEA;AACA,UAAA,MAAA,GAAA,eAAA;EACA;IACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;;EAEA;IACA;MACA;MACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;;EAEA;IACA;MACA;IACA;EACA;;EAEA;;EAEA;EACA;EACA;EACA;;EAEA;;EAEA;AACA,CAAA,CAAA;;AAEA;AACA,aAAA,OAAA,GAAA,oDAAA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;QACA;MACA;IACA;MACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;MACA;QACA;MACA;IACA;MACA;MACA;QACA;MACA;IACA;EACA;;EAEA;IACA;IACA;;IAEA;IACA;IACA;EACA;EACA;IACA;;IAEA;EACA;;EAEA;EACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;IACA;IACA;IACA;EACA;;EAEA;;EAEA;IACA;EACA;EACA;AACA,CAAA,CAAA;AACA,aAAA,aAAA,GAAA,qBAAA;CACA;EACA;IACA;IACA;IACA;IACA;;IAEA;EACA;CACA;EACA;CACA;AACA,CAAA,CAAA;;AAEA;ACpLA;;AAEA;EACA,YAAA,OAAA,GAAA,uBAAA;IACA;MACA;MACA;IACA;;IAEA;UACA;YACA;UACA;;UAEA;YACA;UACA;YACA;UACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;IACA;EACA,CAAA,CAAA;EACA,UAAA,SAAA,GAAA,iBAAA;IACA;MACA;;MAEA;QACA;MACA;QACA;UACA;QACA;;QAEA;;QAEA;UACA;YACA;UACA;YACA;UACA;YACA;UACA;QACA;MACA;;MAEA;IACA;;IAEA;MACA;QACA;MACA;;MAEA;QACA;UACA;QACA;UACA;YACA;cACA;cACA;YACA;cACA;YACA;UACA;QACA;MACA;IACA;EACA,CAAA,CAAA;EACA,aAAA,UAAA,GAAA,mDAAA;IACA;GACA;GACA;IACA;QACA;QACA;MACA;;MAEA;MACA;;MAEA;QACA;QACA;UACA;;UAEA;MACA;YACA;YACA;UACA;QACA;IACA;;IAEA;MACA;QACA;QACA;QACA;;QAEA;UACA;UACA;;UAEA;;UAEA;QACA;QACA;QACA;QACA;MACA;;MAEA;IACA;IACA;;IAEA;MACA;;QAEA;UACA;UACA;QACA;MACA;IACA;;IAEA;MACA;MACA;GACA;;IAEA;EACA;;IAEA;MACA;QACA;QACA;;MAEA;QACA;MACA;QACA;QACA;MACA;;MAEA;QACA;UACA;UACA;QACA;UACA;QACA;UACA;QACA;MACA;IACA;;EAEA;GACA;IACA;GACA;;GAEA;EACA;IACA;GACA;GACA;EACA;;IAEA;EACA,CAAA,CAAA;;AAEA;AC9LA;AACA,UAAA,QAAA,GAAA,kBAAA;EACA;IACA;MACA;IACA;MACA;IACA;EACA;EACA;IACA;MACA;IACA;MACA;IACA;EACA;AACA,CAAA,CAAA;AACA,aAAA,SAAA,GAAA,4BAAA;EACA;AACA,CAAA,CAAA;AACA,KAAA,kBAAA;EACA;IACA;IACA;EACA;AACA,CAAA,CAAA;AACA;AC1BA;;AAEA;EACA,YAAA,SAAA,GAAA,cAAA;IACA;MACA;MACA;QACA;QACA;MACA;MACA;MACA;QACA;UACA;;QAEA;UACA;QACA;QACA;UACA;UACA;YACA;YACA;UACA;QACA;QACA;UACA;UACA;KACA;QACA;;QAEA;UACA;QACA;MACA;IACA;EACA,CAAA,CAAA;EACA,aAAA,UAAA,GAAA,+CAAA;IACA;EACA;;IAEA;MACA;IACA;;IAEA;GACA;IACA;GACA;MACA;QACA;UACA;MACA;MACA;MACA;KACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;UAEA;;KAEA;MACA;MACA;KACA;KACA;MACA;OACA;QACA;QACA;OACA;MACA;KACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;GACA;IACA;EACA,CAAA,CAAA;;AAEA","file":"script.min.js","sourcesContent":["/* global FastClick */\n\nangular\n.module('bndry', [\n  // 'ngTouch',\n  'ngStorage',\n  'ui.map',\n  'ngAnimate',\n  \n  'bndry.action',\n  'bndry.color',\n  'bndry.drawing',\n  'bndry.geo',\n  'bndry.history',\n  'bndry.image',\n  'bndry.map',\n  'bndry.shape',\n  'bndry.search',\n  'bndry.status'\n  // 'bndry.settings'\n])\n.config(function($compileProvider) {\n\t$compileProvider.debugInfoEnabled(false);\n})\n.directive('onActivate', function($parse) {\n\treturn {\n\t\trestrict: 'A',\n\t\tlink: function(scope, element, attr) {\n\t\t\tvar hasTouch = false;\n\t\t\tvar handler = $parse(attr.onActivate);\n\t\t\t\n\t\t\telement.one('mousedown', function() {\n\t\t\t\tif (!hasTouch) {\n\t\t\t\t\telement.on('click', function(event) {\n\t\t\t\t\t\tconsole.log('click');\n\t\t\t\t\t\tscope.$apply(handler(scope, {$event:event}));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\telement.one('touchstart', function() {\n\t\t\t\tconsole.log('touchStart');\n\t\t\t\thasTouch = true;\n\t\t\t\t\n\t\t\t\telement.on('touchend', function(event) {\n\t\t\t\t\tconsole.log('touchEnd');\n\t\t\t\t\tscope.$apply(handler(scope, {$event:event}));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n})\n.directive('ngXlinkHref', function() {\n  return {\n    priority: 99,\n    restrict: 'A',\n    link: function (scope, element, attr) {\n      var attrName = 'xlink:href';\n      attr.$observe('ngXlinkHref', function(value) {\n        if (!value)\n          return;\n\n        element.attr(attrName, value);\n      });\n    }\n  };\n})\n.directive('noScroll', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, elem) {\n      elem.on('touchstart wheel', function(e) {\n        e.preventDefault();\n      });\n    }\n  };\n})\n.controller('MasterCtrl', function($scope, $localStorage, $sce, ColorSvc, DrawingSvc) {\n  $scope.$storage = $localStorage;\n  \n  $scope.fillActiveColor = function() {\n    var hex = ColorSvc.convert.rgba(ColorSvc.activeColor()).to.hex24();\n    return \"#\" + hex;\n  };\n  $scope.shouldCreateNewDrawing = DrawingSvc.shouldCreateNewDrawing;\n  $scope.toggleForceCreateNewDrawing = function() {\n    DrawingSvc.forceCreateNewDrawing = !DrawingSvc.forceCreateNewDrawing;\n  };\n  \n  $scope.sprite = function() {\n    return $sce.trustAsResourceUrl('#' + ($scope.$storage.rigid ? 'rigid' : 'flex') + '-' + ($scope.$storage.fill ? 'fill' : 'nofill'));\n  }\n  $scope.show = {\n    header: '',\n    footer: ''\n  };\n  \n  $scope.setShowHeader = function(show) {\n    if ($scope.show.header === show) {\n      $scope.show.header = '';\n    } else {\n      $scope.show.header = show;\n    }\n  };\n  $scope.setShowFooter = function(show) {\n    if ($scope.show.footer === show) {\n      $scope.show.footer = '';\n    } else {\n      $scope.show.footer = show;\n    }\n  };\n})\n.run(function() {\n  window.addEventListener('orientationchange', function() {\n    window.scrollTo(0,0);\n  });\n\t// FastClick.attach(document.body);\n});\n\n\n//# sourceMappingURL=../sourcemaps/app.js.map","angular.module('bndry.action', ['bndry.history'])\n.controller('ActionCtrl', function($rootScope, $scope, HistorySvc) {\n  $scope.clear = function() {\n    $rootScope.$broadcast('action:clear');\n    HistorySvc.clear();\n  };\n\t\n\t$scope.hasUndo = HistorySvc.hasUndo;\n  $scope.undo = function() {\n    if (HistorySvc.hasUndo()) {\n      HistorySvc.undo();\n    }\n  };\n\t\n\t$scope.hasRedo = HistorySvc.hasRedo;\n  $scope.redo = function() {\n    if (HistorySvc.hasRedo()) {\n      HistorySvc.redo();\n    }\n  };\n});\n\n//# sourceMappingURL=../../sourcemaps/action/action.js.map","/* jshint bitwise: false */\n\nangular.module('bndry.color', ['ngStorage'])\n\n/*\nColor Service\n \nConverts color notations to various formats\nSupported formats: rgba, hsla, hex24, hex32\n*/\n.service('ColorSvc', function($localStorage) {\n  var _rgba = {};\n  var self = this;\n\n  function rgbaToInt(r, g, b, a) {\n    r = Math.round(r * 255);\n    g = Math.round(g * 255);\n    b = Math.round(b * 255);\n    a = Math.round(a * 255);\n\n    /*\n    Bitwise black magic (given r = 0x12, g = 0x34, b = 56, a = 78):\n    (r << 24) => 0x12000000\n    (g << 16) => 0x00340000\n    (b << 8)  => 0x00005600\n    (a)       => 0x00000078\n    \n    All OR'ed => 0x12345678\n    \n    `>>> 0` converts to unsigned 32-bit int\n    */\n    return ((r << 24) | (g << 16) | (b << 8) | (a)) >>> 0;\n  }\n  function hueToRgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1/6) return p + (q - p) * 6 * t;\n    if (t < 1/2) return q;\n    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n    return p;\n  }\n  \n  this.convert = {\n    rgba: function(rgba) {\n      _rgba = rgbaToInt(rgba.r,\n        rgba.g,\n        rgba.b,\n        rgba.a);\n\n      return self;\n    },\n    hsla: function(hsla) {\n      var r, g, b;\n      var h = hsla.h;\n      var s = hsla.s;\n      var l = hsla.l;\n      var a = hsla.a;\n\n      if (s == 0) {\n          r = g = b = l; // achromatic\n      } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = hueToRgb(p, q, h + 1/3);\n          g = hueToRgb(p, q, h);\n          b = hueToRgb(p, q, h - 1/3);\n      }\n\n      _rgba = rgbaToInt(r, g, b, a);\n\n      return self;\n    },\n    hex24: function(hex24) {\n      self.convert.hex32(hex24 + 'FF');\n\n      return self;\n    },\n    hex32: function(hex32) {\n      _rgba = parseInt(hex32, 16) >>> 0; // `>>> 0` => unsigned 32-bit int\n\n      return self;\n    }\n  };\n  this.to = {\n    rgba: function() {\n      var r = (_rgba >> 24 & 0xFF) / 0xFF,\n        g = (_rgba >> 16 & 0xFF) / 0xFF,\n        b = (_rgba >> 8 & 0xFF) / 0xFF,\n        a = (_rgba & 0xFF) / 0xFF;\n\n      _rgba = 0;\n\n      return {r: r,g: g,b: b,a: a};\n    },\n    hsla: function() {\n      var _ref = self.to.rgba();\n      var r = _ref.r;\n      var g = _ref.g;\n      var b = _ref.b;\n      var a = _ref.a;\n\n      var max = Math.max(r, g, b), min = Math.min(r, g, b);\n      var h, s, l = (max + min) / 2;\n\n      if (max === min) {\n        h = s = 0; // achromatic\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n          case g: h = (b - r) / d + 2; break;\n          case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n      }\n\n      return {h: h, s: s, l: l, a: a};\n    },\n    hex24: function() {\n      return self.to.hex32().substring(0, 6);\n    },\n    hex32: function() {\n      var hex = _rgba.toString(16);\n      _rgba = 0;\n\n      return ('00000000' + hex).slice(-8); // Pad output with leading zero\n    }\n  };\n  \n  // HOTFIX until proper interface arrives\n  delete $localStorage.colors;\n  \n  $localStorage.$default({\n    colors: [{\n      name: 'Red',\n      label: 'Do not work either side',\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: 'Green',\n      label: 'Work ONLY the inner side',\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      name: 'Blue',\n      label: 'Work both sides',\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }],\n    activeColorIndex: 1\n  });\n  self.colors = $localStorage.colors;\n  self.activeColorIndex = function() {\n    return $localStorage.activeColorIndex;\n  };\n  self.setActiveColorIndex = function(index) {\n    $localStorage.activeColorIndex = index;\n  }\n  self.activeColor = function() {\n    return self.colors[self.activeColorIndex()];\n  };\n})\n  .controller('ColorCtrl', function($scope, $localStorage, ColorSvc) {\n    $scope.$storage = $localStorage;\n    \n    $scope.fillColor = function(index) {\n      if (index === undefined) {\n        index = ColorSvc.activeColorIndex();\n      }\n      var color = ColorSvc.colors[index];\n      return '#' + ColorSvc.convert.rgba(color).to.hex24();\n    };\n    $scope.activeColorIndex = ColorSvc.activeColorIndex;\n    $scope.setActiveColorIndex = ColorSvc.setActiveColorIndex;\n  });\n\n//# sourceMappingURL=../../sourcemaps/color/color.js.map","/* jshint camelcase: false */\n\nangular.module('bndry.drawing', ['ngStorage', 'bndry.map', 'bndry.color', 'bndry.shape', 'bndry.history'])\n.service('DirectionsSvc', function($rootScope, $q, MapSvc) {\n  var self = this;\n  var directions = new MapSvc.DirectionsService();\n\n  self.route = function(locations) {\n    if (locations.length !== 2) {\n      console.error('Requires exactly 2 locations.');\n      return false;\n    }\n\n    var request = {\n      origin: locations[0],\n      destination: locations[1],\n      travelMode: MapSvc.TravelMode.DRIVING\n    };\n\n    var deferred = $q.defer();\n\n    function processRequest(tries, request) {\n      directions.route(request,\n        // Success handler\n\n        function(request, result, status) {\n          if (status === MapSvc.DirectionsStatus.OK) {\n            var overviewPath = result.routes[0].overview_path;\n\n            // Resolve with path\n            deferred.resolve(overviewPath);\n          } else if (status ===\n            MapSvc.DirectionsStatus.UNKNOWN_ERROR && tries < 3) {\n            tries++;\n            // Try again\n            processRequest(tries);\n          } else {\n            $rootScope.$broadcast('load:error');\n            deferred.reject([request.origin, request.destination]);\n          }\n        }.bind(null, request),\n        // Error handler\n\n        function(request) {\n          if (tries < 3) {\n            // Try again\n            tries++;\n            processRequest(tries, request);\n          } else {\n            $rootScope.$broadcast('load:error');\n            deferred.reject();\n          }\n        }.bind(null, request));\n    }\n\n    processRequest(0, request);\n\n    $rootScope.$broadcast('load:start');\n    \n    return deferred.promise.then(function(result) {\n      $rootScope.$broadcast('load:done');\n      return result;\n    });\n  };\n})\n.service('DrawingSvc', function($rootScope, $q, $localStorage, DirectionsSvc, MapSvc, ColorSvc, ShapeSvc) {\n  var self = this;\n\n\n\n  function splice(itemArray, index, removeLength, newItems) {\n    if (newItems === undefined)\n      newItems = [];\n\n    if (removeLength === undefined)\n      removeLength = 0;\n\n    if (index === undefined)\n      index = 0;\n\n    var args = [index, removeLength].concat(newItems);\n\n    return Array.prototype.splice.apply(itemArray, args);\n  }\n  \n  function change(object, changes) {\n    for (var key in changes) {\n      if (changes.hasOwnProperty(key)) {\n        object[key] = changes[key];\n      }\n    }\n  }\n  \n  function arrayify(items) {\n    if (!Array.isArray(items)) {\n      return [items];\n    } else {\n      return items;\n    }\n  }\n  \n  \n  \n  /*\n  *** PRIVATE METHODS ***\n  */\n  // Path functions\n  function makePoint(latLng) {\n    console.assert(\n      'lat' in latLng &&\n      'lng' in latLng &&\n      typeof latLng.lat === 'number' &&\n      typeof latLng.lat === 'number',\n      \n      'latLng is not formatted properly'\n    );\n    return new MapSvc.LatLng(latLng.lat, latLng.lng);\n  }\n  \n  function addPoints(path, index, points) {\n    return splice(path, index, 0, points);\n  }\n  \n  function removePoints(path, index, removeLength) {\n    return splice(path, index, removeLength);\n  }\n\n\n\n  function makePaths(locations, rigid) {\n    if (rigid === undefined)\n      rigid = false;\n\n    console.assert(\n      Array.isArray(locations),\n      \n      'locations is not an Array'\n    );\n\n    var promises = [];\n    for (var i = 0; i < locations.length - 1; i++) {\n      var start = locations[i],\n        end = locations[i + 1],\n        promise;\n      \n      if (rigid) {\n        promise = start.equals(end) ?\n          $q.when([start]) :\n          $q.when([start, end]);\n      } else {\n        promise = DirectionsSvc.route([start, end])\n\t\t\t\t  .catch(function(start, end) {\n\t\t\t\t  \treturn start.equals(end) ?\n\t\t          $q.when([start]) :\n\t\t          $q.when([start, end]);\n\t\t\t\t  }.bind(null, start, end));\n      }\n      promises.push(promise);\n    }\n\n    return $q.all(promises);\n  }\n\n\n\n  // Node functions\n  function addNodes(nodes, index, nodesToAdd) {\n    nodesToAdd = arrayify(nodesToAdd);\n    var node;for(var _2eynikbuik9 = 0; _2eynikbuik9 < nodesToAdd.length; _2eynikbuik9++) { node = nodesToAdd[_2eynikbuik9]\n      node._marker.setMap(MapSvc.map);\n    }\n    \n    return splice(nodes, index, 0, nodesToAdd);\n  }\n  var addNode = addNodes;\n  \n  function removeNodes(nodes, index, removeLength) {\n    if (removeLength === undefined)\n      removeLength = 1;\n\n    var removed = splice(nodes, index, removeLength);\n    var node;for(var _zypfb4bzkt9 = 0; _zypfb4bzkt9 < removed.length; _zypfb4bzkt9++) { node = removed[_zypfb4bzkt9]\n        node._marker.setMap(null);\n      }\n\n    return removed;\n  }\n  var removeNode = removeNodes;\n  \n  function changeNode(node, changes) {\n    console.assert(\n      typeof node === 'object' &&\n      typeof changes === 'object',\n      \n      'Invalid parameters'\n    );\n    change(node, changes);\n    for (var key in changes) {\n      switch (key) {\n      case 'lat':\n      case 'lng':\n        node._marker.setPosition(makePoint(node));\n        break;\n      }\n    }\n  }\n  \n  function duplicateNode(drawing, node) {\n    return makeNode(drawing.colorIndex, makePoint(node), node.index);\n  }\n  \n  \n  \n  function shiftIndexOfNodes(nodes, index, shifts) {\n    var nodeArray = arrayify(nodes),\n      shift = 0,\n      i = 0;\n    \n    if (Array.isArray(shifts)) {\n      for (i = 0; (i + index) < nodeArray.length && i < shifts.length; i++) {\n        shift += shifts[i];\n        nodeArray[index + i].index += shift;\n      }\n    } else {\n      shift = shifts;\n    }\n    for (i += index; i < nodeArray.length; i++) {\n      nodeArray[i].index += shift;\n    }\n  }\n  \n  function setIndexOfNodes(nodes, index, value) {\n    var nodeArray = arrayify(nodes);\n    for (var i = index; i < nodeArray.length; i++) {\n      nodeArray[i].index = value;\n    }\n  }\n  \n  function setInitialIndexOfNodes(nodes, index, nodesToAdd) {\n    var nodeBefore = nodes[index - 1], indexForNode = 0;\n    \n    if (nodeBefore) {\n      indexForNode = nodeBefore.index;\n    }\n    setIndexOfNodes(nodesToAdd, 0, indexForNode);\n  }\n  \n  \n  \n  function rangeOfPathAroundNodes(nodes, start, end) {\n    var range = {\n      start: null,\n      end: null,\n      length: null,\n      nodeStart: null,\n      nodeEnd: null,\n      nodeLength: null,\n      lastNode: false,\n      firstNode: false\n    };\n    \n    var nodeRange = nodes.slice(start, end),\n      firstNodeInRange = nodeRange[0],\n      lastNodeInRange = nodeRange[nodeRange.length - 1],\n      nodeBeforeRange = nodes[start - 1],\n      nodeAfterRange = nodes[end];\n    \n    if (!nodeBeforeRange) {\n      range.firstNode = true;\n    }\n    if (nodeBeforeRange && nodeBeforeRange.index !== null) {\n      range.start = nodeBeforeRange.index;\n      range.nodeStart = start;\n    } else if (firstNodeInRange && firstNodeInRange.index !== null) {\n      range.start = firstNodeInRange.index;\n      range.nodeStart = start + 1;\n    } else {\n      range.start = 0;\n      range.nodeStart = 0;\n    }\n    \n    if (!nodeAfterRange) {\n      range.lastNode = true;\n    }\n    if (nodeAfterRange && nodeAfterRange.index !== null) {\n      range.end = nodeAfterRange.index;\n      range.nodeEnd = end;\n    } else if (lastNodeInRange && lastNodeInRange.index !== null) {\n      range.end = lastNodeInRange.index;\n      range.nodeEnd = end - 1;\n    } else {\n      range.end = range.start;\n      range.nodeEnd = range.nodeStart;\n    }\n    \n    range.nodeLength = range.nodeEnd - range.nodeStart;\n    range.length = range.end - range.start;\n    \n    return range;\n  }\n  \n  function rangeOfPathAroundNode(nodes, index) {\n    return rangeOfPathAroundNodes(nodes, index, index);\n  }\n  \n  \n  \n  function makePathsAroundNodes(nodes, start, end, rigid) {\n    var points = [],\n      nodeRange = nodes.slice(start, end),\n      nodeBefore = nodes[start - 1],\n      nodeAfter = nodes[end],\n      node;\n    \n    if (nodeBefore) {\n      points.push(makePoint(nodeBefore));\n    }\n    for(var _uoj44h1tt9 = 0; _uoj44h1tt9 < nodeRange.length; _uoj44h1tt9++) { node = nodeRange[_uoj44h1tt9]\n      points.push(makePoint(node));\n    }\n    if (nodeAfter) {\n      points.push(makePoint(nodeAfter));\n    }\n    \n    if (points.length < 2) {\n      points.push(points[0]); // Duplicate first point; makePaths needs at least two points\n    }\n    \n    return makePaths(points, rigid);\n  }\n  \n  function makePathsAroundNode(nodes, index, rigid) {\n    return makePathsAroundNodes(nodes, index, index, rigid);\n  }\n  \n\n  \n  function alignNodesWithPath(path, nodes) {\n    var latLng;\n    \n    var node;for(var _5df14gkqpvi = 0; _5df14gkqpvi < nodes.length; _5df14gkqpvi++) { node = nodes[_5df14gkqpvi]\n      latLng = path[node.index];\n      console.assert(\n        latLng,\n\n        'latLng is not defined'\n      );\n      changeNode(node, {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      });\n    }\n  }\n  \n  \n  \n  function removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength) {\n    var range = rangeOfPathAroundNodes(drawing.nodes, index, index + nodeRemoveLength);\n\n    if (nodeRemoveLength === 0 && range.firstNode && !range.lastNode) {\n      return;\n    }\n    var path = drawing._poly.getPath().getArray(),\n      pathRemoveLength = range.length;\n\n    // Special case to remove last point if lastNode\n    if (range.lastNode) {\n      pathRemoveLength++;\n    }\n\n    removePoints(path, range.start, pathRemoveLength);\n\n    shiftIndexOfNodes(drawing.nodes, range.nodeStart, -range.length);\n    var removedNodes = removeNodes(drawing.nodes, index, nodeRemoveLength);\n    \n    drawing._poly.setPath(path);\n\n    $rootScope.$broadcast('drawing:change');\n    \n    return removedNodes;\n  }\n  \n  function addNodesAndTheirPathsToDrawing(drawing, index, newNodes, newPaths) {\n    var polyPath = drawing._poly.getPath().getArray(),\n      nodes = drawing.nodes;\n      \n    var shifts = [];\n    var path, lastPoint, i,\n      pathRange = rangeOfPathAroundNodes(nodes, index, index + newNodes.length),\n      pathIndex = pathRange.start;\n      \n    for(var _trx0g96yldi = 0; _trx0g96yldi < newPaths.length; _trx0g96yldi++) { path = newPaths[_trx0g96yldi]\n      lastPoint = path.pop();\n      \n      // Adds new path\n      addPoints(polyPath, pathIndex, path);\n      \n      pathIndex += path.length;\n      shifts.push(path.length);\n    }\n    \n    var alignLength = newPaths.length;\n    shiftIndexOfNodes(nodes, pathRange.nodeStart, shifts);\n    \n    if (pathRange.lastNode && lastPoint) { // If lastNode is involved, put lastPoint back\n      polyPath.push(lastPoint);\n      alignLength++;\n    }\n    \n    var nodesToAlign = nodes.slice(index, index + alignLength);\n    alignNodesWithPath(polyPath, nodesToAlign);\n    \n    drawing._poly.setPath(polyPath);\n    \n    $rootScope.$broadcast('drawing:change');\n    \n    return polyPath;\n  }\n  \n  \n  \n  function spliceNodesIntoDrawing(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n    if (pathsToAdd === undefined)\n      pathsToAdd = null;\n\n    if (nodesToAdd === undefined)\n      nodesToAdd = [];\n\n    return queue(\n      function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n        var removedNodes = removeNodesAndTheirPathsFromDrawing(drawing, index, nodeRemoveLength);\n        \n        if (nodesToAdd === null) {\n          nodesToAdd = removedNodes;\n        } else {\n          nodesToAdd = arrayify(nodesToAdd);\n        }\n        \n        setInitialIndexOfNodes(drawing.nodes, index, nodesToAdd);\n        addNodes(drawing.nodes, index, nodesToAdd);\n      \n        var promise;\n        if (pathsToAdd) {\n          promise = $q.when(pathsToAdd);\n        } else {\n          promise = makePathsAroundNodes.bind(null, drawing.nodes, index, index + nodesToAdd.length, drawing.rigid)();\n        }\n        \n        return promise.then(\n          function(drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd) {\n            return addNodesAndTheirPathsToDrawing(drawing, index, nodesToAdd, pathsToAdd);\n          }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd)\n        );\n      }.bind(null, drawing, index, nodeRemoveLength, nodesToAdd, pathsToAdd)\n    );\n  }\n  \n  \n  \n  /*\n  *** PUBLIC API ***\n  */\n  var internalQueue = $q.when();\n  function queue(steps) // Keeps path operations in correct order\n  {\n    if (steps === undefined)\n      steps = [];\n\n    console.assert(\n      steps !== undefined,\n\n      'steps cannot be undefined'\n    );\n\n    steps = arrayify(steps);\n    var step;for(var _422z4sll3di = 0; _422z4sll3di < steps.length; _422z4sll3di++) { step = steps[_422z4sll3di]\n        internalQueue = internalQueue.then(step);\n      }\n\n    return internalQueue;\n  }\n  self.queue = queue;\n  \n  \n  \n  // Drawing functions\n  function makeDrawing(colorIndex, rigid, fill) {\n    if (fill === undefined)\n      fill = false;\n\n    var poly;\n\n    if (fill) {\n      poly = new MapSvc.Polygon(makePolyOptions(colorIndex, fill));\n    } else {\n      poly = new MapSvc.Polyline(makePolyOptions(colorIndex, fill));\n    }\n    return {\n      colorIndex: colorIndex,\n      rigid: rigid,\n      fill: fill,\n      _poly: poly,\n      nodes: []\n    };\n  }\n  self.makeDrawing = makeDrawing;\n  \n  function addDrawings(drawings, index, drawingsToAdd) {\n    return queue(\n      splice.bind(null, drawings, index, 0, drawingsToAdd)\n    );\n  }\n  self.addDrawings = self.addDrawing = addDrawings;\n  \n  function removeDrawings(drawings, index, removeLength) {\n    return queue(\n      function(drawings, index, removeLength) {\n        var removedDrawings = splice(drawings, index, removeLength);\n        for (var i = 0; i < removedDrawings.length; i++) {\n          var removedDrawing = removedDrawings[i];\n          removeNodesFromDrawing(removedDrawing, 0, removedDrawing.nodes.length);\n          removedDrawing._poly.setMap(null);\n        }\n      }.bind(null, drawings, index, removeLength)\n    );\n  }\n  self.removeDrawings = self.removeDrawing = removeDrawings;\n  \n  function changeDrawing(drawing, changes) {\n    change(drawing, changes);\n    \n    for (var key in changes) {\n      switch (key) {\n      case 'colorIndex':\n      case 'fill':\n        var options = makePolyOptions(drawing.colorIndex, drawing.fill);\n        drawing._poly.setOptions(options);\n        break;\n      case 'rigid':\n        \n        break;\n      }\n    }\n    \n    $rootScope.$broadcast('drawing:change');\n  }\n  \n  \n  \n  function makeNode(colorIndex, latLng, index) {\n    if (index === undefined)\n      index = null;\n\n    var marker = new MapSvc.Marker(makeMarkerOptions(colorIndex, latLng));\n\n    return {\n      lat: latLng.lat(),\n      lng: latLng.lng(),\n      index: index,\n      _marker: marker\n    };\n  }\n  self.makeNode = makeNode;\n  \n  function addNodesToDrawing(drawing, index, nodesToAdd, pathsToAdd) {\n    if (pathsToAdd === undefined)\n      pathsToAdd = null;\n\n    if (nodesToAdd === undefined)\n      nodesToAdd = [];\n\n    return spliceNodesIntoDrawing(drawing, index, 0, nodesToAdd, pathsToAdd);\n  }\n  self.addNodesToDrawing = self.addNodeToDrawing = addNodesToDrawing;\n  \n  function removeNodesFromDrawing(drawing, index, removeLength, pathsToAdd) {\n    if (pathsToAdd === undefined)\n      pathsToAdd = null;\n\n    return spliceNodesIntoDrawing(drawing, index, removeLength, [], pathsToAdd);\n  }\n  self.removeNodesFromDrawing = self.removeNodeFromDrawing = removeNodesFromDrawing;\n  \n  function changeNodeOfDrawing(drawing, index, changes, pathsToAdd) {\n    if (pathsToAdd === undefined)\n      pathsToAdd = null;\n\n    queue(\n      function(drawing, index, changes) {\n        changeNode(drawing.nodes[index], changes);\n      }.bind(null, drawing, index, changes)\n    );\n\n    return spliceNodesIntoDrawing.bind(null, drawing, index, 1, null, pathsToAdd)();\n  }\n  self.changeNodeOfDrawing = changeNodeOfDrawing;\n  \n\n\n  function makeIcon(colorIndex, options) {\n    var color = ColorSvc.colors[colorIndex];\n    var icon = {\n      path: MapSvc.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n    change(icon, options);\n    \n    return icon;\n  }\n  \n  function makeMarkerOptions(colorIndex, latLng, options) {\n    var markerOptions = {\n      clickable: true,\n      crossOnDrag: false,\n      cursor: 'pointer',\n      draggable: true,\n      flat: true,\n      icon: makeIcon(colorIndex),\n      map: MapSvc.map,\n      position: latLng\n    };\n    change(markerOptions, options);\n    \n    return markerOptions;\n  }\n  \n  function makePolyOptions(colorIndex, fill) {\n    var value = {\n      clickable: !fill,\n      draggable: false,\n      editable: false,\n      map: MapSvc.map\n    };\n\n    var color = angular.copy(ColorSvc.colors[colorIndex]);\n    color.a = 0.5;\n    \n    if (fill) {\n      value.fillColor = rgbaColorToString(color);\n      value.fillOpacity = 1;\n      value.strokeWeight = 0;\n    } else {\n      value.strokeColor = rgbaColorToString(color);\n      value.strokeWeight = color.weight;\n    }\n\n    return value;\n  }\n  \n  \n  \n  function drawingsToGeoJson(drawings) {\n    var geoJson = {\n      type: 'FeatureCollection'\n    };\n\n    geoJson.features = drawings.map(\n      function(drawing) {\n        var feature = {\n          type: 'Feature'\n        };\n\n        var polyPath = drawing._poly.getPath().getArray();\n        var coordinates = polyPath.map(\n          function(latLng) {\n            return [\n              latLng.lng(),\n              latLng.lat()\n            ];\n          }\n        );\n\n        feature.geometry = {\n          type: drawing.fill ? 'Polygon' : 'LineString',\n          coordinates: drawing.fill ? [coordinates] : coordinates\n        };\n\n        var colorIndex = drawing.colorIndex;\n        var rigid = drawing.rigid;\n        var fill = drawing.fill;\n        var nodes = drawing.nodes;\n        feature.properties = {colorIndex: colorIndex, rigid: rigid, fill: fill};\n        feature.properties.nodes = nodes.map(\n          function(node) {\n            var lat = node.lat;\n            var lng = node.lng;\n            var index = node.index;\n            return {lat: lat, lng: lng, index: index};\n          }\n        );\n        return feature;\n      }\n    );\n    \n    return JSON.stringify(geoJson);\n  }\n  self.drawingsToGeoJson = drawingsToGeoJson;\n  \n  function geoJsonToDrawings(geoJsonString) {\n    console.assert(\n      typeof geoJsonString === 'string',\n\n      'geoJson must be a string'\n    );\n    \n    var drawings = [];\n    var geoJson = JSON.parse(geoJsonString);\n    var drawings = geoJson.features.map(\n      function(feature, i) {\n        var colorIndex = feature.properties.colorIndex;\n        var rigid = feature.properties.rigid;\n        var fill = feature.properties.fill;\n        var nodes = feature.properties.nodes;\n        var drawing = makeDrawing(colorIndex, rigid, fill);\n        addDrawings(drawings, i, drawing);\n\n        var nodesToAdd = nodes.map(\n          function(node) {\n            var latLng = new MapSvc.LatLng(node.lat, node.lng);\n            return makeNode.bind(null, drawing.colorIndex, latLng, node.index)();\n          }\n        );\n\n        var coordinates;\n        if (fill) {\n          coordinates = feature.geometry.coordinates[0];\n        } else {\n          coordinates = feature.geometry.coordinates;\n        }\n        var polyPath = coordinates.map(\n          function(coordinate) {\n            return new MapSvc.LatLng(coordinate[1], coordinate[0]);\n          }\n        );\n\n        var pathsToAdd = [];\n        for (var i = 0; i < nodesToAdd.length - 1; i++) {\n          var nodeAt = nodesToAdd[i],\n            nodeAfter = nodesToAdd[i + 1],\n            pathChunk = polyPath.slice(nodeAt.index, nodeAfter.index + 1);\n          \n          pathsToAdd.push(pathChunk);\n        }\n\n        addNodesToDrawing.bind(null, drawing, 0, nodesToAdd, pathsToAdd)();\n\n        return drawing;\n      }\n    );\n    \n    return drawings;\n  }\n  self.geoJsonToDrawings = geoJsonToDrawings;\n  \n  \n  \n  function rgbaColorToString(rgba) {\n    return \"rgba(\" + Math.round(rgba.r*255) + \",\" + Math.round(rgba.g*255) + \",\" + Math.round(rgba.b*255) + \",\" + rgba.a + \")\";\n  }\n  \n  \n  \n  var activeMarker = new MapSvc.Marker();\n  function showActiveNode(colorIndex, node) {\n    var color = ColorSvc.colors[colorIndex];\n    activeMarker.setOptions(makeMarkerOptions(colorIndex, makePoint(node), {\n      clickable: false,\n      draggable: false,\n      icon: makeIcon(colorIndex, {\n        scale: 20,\n        strokeWeight: 2,\n        strokeOpacity: 0.5,\n        fillColor: '#' + ColorSvc.convert.rgba(color).to.hex24(),\n        fillOpacity: 0.125\n      })\n    }));\n  }\n  self.showActiveNode = showActiveNode;\n  \n  function hideActiveNode() {\n    activeMarker.setMap(null);\n  }\n  self.hideActiveNode = hideActiveNode;\n  \n  \n  \n  self.forceCreateNewDrawing = false;\n  \n  self.shouldCreateNewDrawing = function() {\n    if (self.drawings.length === 0 || self.forceCreateNewDrawing) {\n      return true;\n    }\n    var latestDrawing = self.drawings[self.drawings.length - 1];\n    var value = (latestDrawing &&\n      (latestDrawing.colorIndex !== ColorSvc.activeColorIndex() ||\n      latestDrawing.rigid !== ShapeSvc.rigid() ||\n      latestDrawing.fill !== ShapeSvc.fill()));\n    return value;\n  };\n  \n  self.drawings;\n  \n  self.activeDrawingIndex = -1;\n})\n// Controllers\n.controller('DrawingCtrl', function($scope, $localStorage, $timeout, DrawingSvc, ColorSvc, ShapeSvc, HistorySvc) {\n  $scope.$storage = $localStorage.$default({\n    drawings: [],\n    rigid: false,\n    colors: [{\n      r: 1,\n      g: 0,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 1,\n      b: 0,\n      a: 0.125,\n      weight: 10\n    }, {\n      r: 0,\n      g: 0,\n      b: 1,\n      a: 0.125,\n      weight: 10\n    }]\n  });\n  \n  var drawings = $scope.drawings = DrawingSvc.drawings = [];\n  \n  // Load last saved drawings from geoJson in localStorage\n  var storedDrawings = DrawingSvc.geoJsonToDrawings(\n    localStorage.geoJson || DrawingSvc.drawingsToGeoJson(drawings)\n  );\n  var storedDrawing;for(var _hiua49ggb9 = 0; _hiua49ggb9 < storedDrawings.length; _hiua49ggb9++) { storedDrawing = storedDrawings[_hiua49ggb9]\n    drawings.push(storedDrawing);\n  }\n  \n  function activeDrawingIndex(value) {\n    if (typeof value === 'number') {\n      DrawingSvc.activeDrawingIndex = value;\n    } else {\n      return DrawingSvc.activeDrawingIndex;\n    }\n  }\n  activeDrawingIndex(drawings.length - 1);\n  var queue = DrawingSvc.queue;\n  // $scope.$storage = DrawingSvc.loadDrawings();\n\n  function addNode(event, param) {\n    var colorIndex = ColorSvc.activeColorIndex();\n    \n    var rigid = ShapeSvc.rigid(),\n      fill = ShapeSvc.fill();\n\n    var createNewDrawing = DrawingSvc.shouldCreateNewDrawing();\n    if (createNewDrawing) {\n      var newDrawing = DrawingSvc.makeDrawing(colorIndex, rigid, fill);\n      activeDrawingIndex(activeDrawingIndex() + 1);\n      DrawingSvc.addDrawing(drawings, activeDrawingIndex(), newDrawing);\n      DrawingSvc.forceCreateNewDrawing = false;\n    }\n\n    queue(\n      function(drawingIndex, colorIndex, latLng, createNewDrawing) {\n        var drawing = drawings[drawingIndex];\n        var newNode = DrawingSvc.makeNode(colorIndex, latLng);\n        var nodeIndex = drawing.nodes.length;\n        \n        DrawingSvc.addNodeToDrawing(drawing, nodeIndex, newNode);\n        \n        HistorySvc.add({\n          undo: function(drawings, drawing, drawingIndex, nodeIndex, didCreateNewDrawing) {\n            DrawingSvc.removeNodeFromDrawing(drawing, nodeIndex, 1);\n            \n            if (didCreateNewDrawing) {\n              DrawingSvc.removeDrawing(drawings, drawingIndex, 1);\n              activeDrawingIndex(drawingIndex - 1);\n            }\n          }.bind(null, drawings, drawing, drawingIndex, nodeIndex, createNewDrawing),\n          \n          redo: function(drawings, drawing, drawingIndex, nodeIndex, newNode, didCreateNewDrawing) {\n            if (didCreateNewDrawing) {\n              DrawingSvc.addDrawing(drawings, drawingIndex, drawing);\n              activeDrawingIndex(drawingIndex + 1);\n            }\n            \n            DrawingSvc.addNodeToDrawing(drawing, nodeIndex, newNode);\n          }.bind(null, drawings, drawing, drawingIndex, nodeIndex, newNode, createNewDrawing)\n        });\n      }.bind(null, activeDrawingIndex(), colorIndex, param.latLng, createNewDrawing)\n    );\n  }\n  function changeNode($params, drawingIndex, nodeIndex) {\n    var event = $params[0],\n      drawing = drawings[drawingIndex],\n      latLng = event.latLng;\n    \n    queue(\n      function(drawing, nodeIndex, latLng) {\n        var originalNode = drawing.nodes[nodeIndex],\n          originalPosition = {\n            lat: originalNode.lat,\n            lng: originalNode.lng\n          },\n          newPosition = {\n            lat: latLng.lat(),\n            lng: latLng.lng()\n          };\n        DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, newPosition);\n        \n        HistorySvc.add({\n          undo: function(drawing, nodeIndex, originalPosition) {\n            DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, originalPosition);\n          }.bind(null, drawing, nodeIndex, originalPosition),\n          \n          redo: function(drawing, nodeIndex, newPosition) {\n            DrawingSvc.changeNodeOfDrawing(drawing, nodeIndex, newPosition);\n          }.bind(null, drawing, nodeIndex, newPosition)\n        });\n      }.bind(null, drawing, nodeIndex, latLng)\n    );\n  }\n  \n  $scope.$on('map:click', addNode);\n  $scope.$on('action:clear', function($params) {\n    DrawingSvc.removeDrawings(drawings, 0, drawings.length);\n    activeDrawingIndex(-1);\n  });\n  \n  $scope.$on('drawing:change', function() {\n    localStorage.geoJson = DrawingSvc.drawingsToGeoJson(drawings);\n    \n    if (drawings.length > 0 && drawings[drawings.length - 1].nodes.length > 0) {\n      var latestNodes = drawings[drawings.length - 1].nodes,\n        latestNode = latestNodes[latestNodes.length - 1];\n      \n      DrawingSvc.showActiveNode(ColorSvc.activeColorIndex(), latestNode);\n    } else {\n      DrawingSvc.hideActiveNode();\n    }\n  });\n  \n  $scope.marker = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    },\n    dragend: changeNode\n  };\n  $scope.poly = {\n    click: function($params) {\n      addNode(undefined, $params[0]);\n    }\n  };\n});\n\n//# sourceMappingURL=../../sourcemaps/drawing/drawing.js.map","angular.module('bndry.geo', ['bndry.map'])\n  .service('GeolocationSvc', function($q) {\n    this.getLocation = function() {\n      var deferred = $q.defer();\n\n      if ('geolocation' in navigator) {\n        navigator.geolocation.getCurrentPosition(function(position) {\n          deferred.resolve(position);\n        }, function(error) {\n          deferred.reject(error);\n        });\n      } else {\n        deferred.reject(false);\n      }\n\n      return deferred.promise;\n    };\n  })\n  .service('GeocodeSvc', function($q, MapSvc) {\n    this.geocode = function(location, bounds) {\n      var geocoder = new MapSvc.Geocoder();\n      var deferred = $q.defer();\n\t\t\t\n\t\t\tvar request = {};\n\t\t\t\n\t\t\tif (bounds) {\n\t\t\t\trequest.bounds = location;\n\t\t\t} else {\n\t\t\t\trequest.location = location;\n\t\t\t}\n\t\t\t\n\t\t\t\n      geocoder.geocode(request, function(results, status) {\n        if (status === MapSvc.GeocoderStatus.OK) {\n          deferred.resolve(results);\n        } else {\n          deferred.reject(status);\n        }\n      });\n\n      return deferred.promise;\n    };\n  });\n\n//# sourceMappingURL=../../sourcemaps/geo/geo.js.map","// istanbul ignore next\nangular.module('bndry.history', [])\n  .service('HistorySvc', function() {\n    /* jshint quotmark:true */\n    /* jshint camelcase:false */\n      /*\n      Simple Javascript undo and redo.\n      https://github.com/ArthurClemens/Javascript-Undo-Manager\n      */\n      \"use strict\";\n\n      var commands = [],\n        index = -1,\n        isExecuting = false,\n        callback,\n\n        // functions\n        execute;\n\n      execute = function(command, action) {\n        if (!command || typeof command[action] !== \"function\") {\n          return this;\n        }\n        isExecuting = true;\n\n        command[action]();\n\n        isExecuting = false;\n        return this;\n      };\n\n      return {\n\n        /*\n        Add a command to the queue.\n        */\n        add: function(command) {\n          if (isExecuting) {\n            return this;\n          }\n          // if we are here after having called undo,\n          // invalidate items higher on the stack\n          commands.splice(index + 1, commands.length - index);\n\n          commands.push(command);\n\n          // set the current index to the end\n          index = commands.length - 1;\n          if (callback) {\n            callback();\n          }\n          return this;\n        },\n\n        /*\n        Pass a function to be called on undo and redo actions.\n        */\n        setCallback: function(callbackFunc) {\n          callback = callbackFunc;\n        },\n\n        /*\n        Perform undo: call the undo function at the current index and decrease the index by 1.\n        */\n        undo: function() {\n          var command = commands[index];\n          if (!command) {\n            return this;\n          }\n          execute(command, \"undo\");\n          index -= 1;\n          if (callback) {\n            callback();\n          }\n          return this;\n        },\n\n        /*\n        Perform redo: call the redo function at the next index and increase the index by 1.\n        */\n        redo: function() {\n          var command = commands[index + 1];\n          if (!command) {\n            return this;\n          }\n          execute(command, \"redo\");\n          index += 1;\n          if (callback) {\n            callback();\n          }\n          return this;\n        },\n\n        /*\n        Clears the memory, losing all stored states. Reset the index.\n        */\n        clear: function() {\n          var prev_size = commands.length;\n\n          commands = [];\n          index = -1;\n\n          if (callback && (prev_size > 0)) {\n            callback();\n          }\n        },\n\n        hasUndo: function() {\n          return index !== -1;\n        },\n\n        hasRedo: function() {\n          return index < (commands.length - 1);\n        },\n\n        getCommands: function() {\n          return commands;\n        }\n      };\n    });\n\n      /*\nLICENSE\n\nThe MIT License\n\nCopyright (c) 2010-2014 Arthur Clemens, arthurclemens@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: \n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n\n//# sourceMappingURL=../../sourcemaps/history/history.js.map","angular.module('bndry.image', ['ngStorage', 'bndry.map', 'bndry.drawing', 'bndry.color'])\n  .service('ImageSvc', function($rootScope, $http, $document, $localStorage, MapSvc, DrawingSvc, ColorSvc) {\n    var self = this;\n    \n    self.pxSize = function(maxWidth, maxHeight, ratio) {\n      return {\n        ratio: ratio,\n        width: (ratio >= 1) ? maxWidth : Math.round(ratio * maxWidth),\n        height: (ratio < 1) ? maxHeight : Math.round(1 / ratio * maxHeight)\n      };\n    };\n    self.generateUrl = function() {\n      if (!DrawingSvc.drawings) {\n        return;\n      }\n\n      var path = 'https://maps.googleapis.com/maps/api/staticmap';\n\n      var params = [];\n\n      // Generate style from map styling and drawings\n      for (var rule in $localStorage.style) {\n        var urlRule = [];\n\n        // Add selectors to urlRule\n        if ('featureType' in rule && rule.featureType !== 'all') {\n          urlRule.push('feature:' + rule.featureType);\n        }\n        if ('elementType' in rule && rule.elementType !== 'all') {\n          urlRule.push('element:' + rule.elementType);\n        }\n\n        // Loop through every styler, add to urlRule\n        for (var styler in rule.stylers) {\n          for (var key in styler) {\n            var value = styler[key];\n\n            if (key === 'color') {\n              value = '0x' + value.substring(1);\n            }\n\n            urlRule.push(key + ':' + value);\n          }\n        }\n\n        var urlParamText = urlRule.join('|');\n\n        // Add urlParamText to params if not empty string\n        if (urlParamText !== '') {\n          params.push('style=' + urlParamText);\n        }\n      }\n\n      // Generate paths from drawings\n      var drawing, urlPath, polyPath, encodedPath, color, hex;\n      var bounds = new MapSvc.LatLngBounds();\n      for (i = 0; i < DrawingSvc.drawings.length; i++) {\n        urlPath = [];\n        drawing = DrawingSvc.drawings[i];\n        polyPath = drawing._poly.getPath().getArray();\n\n        for (j = 0; j < polyPath.length; j++) {\n          bounds.extend(polyPath[j]);\n        }\n\n        encodedPath = MapSvc.geometry.encoding.encodePath(polyPath);\n        color = $localStorage.colors[drawing.colorIndex];\n        hex = '0x' + ColorSvc.convert.rgba(color).to.hex32();\n\n        // If drawing is polygon, use 'fillcolor'\n        if (drawing.fill) {\n          urlPath.push('fillcolor:' + hex);\n          urlPath.push('weight:0');\n        } else {\n          urlPath.push('color:' + hex);\n          urlPath.push('weight:' + color.weight);\n        }\n        urlPath.push('enc:' + encodedPath);\n\n        urlPath = urlPath.join('|');\n\n        // Add urlPath to params if not empty string\n        if (urlPath) {\n          params.push('path=' + urlPath);\n        }\n      }\n\n      var northEast = bounds.getNorthEast();\n      var southWest = bounds.getSouthWest();\n      var computeHeading = MapSvc.geometry.spherical.computeHeading;\n      var heading = Math.abs(computeHeading(northEast, southWest) + computeHeading(southWest, northEast)) / 2;\n\n\t\t\tvar ratio = (45 <= heading && heading < 135) ? 3.5/5 : 5/3.5;\n\t\t\tvar pxSize = self.pxSize(640, 640, ratio);\n\t\t\t\n      // Landscape\n      params.push('size=' + pxSize.height + 'x' + pxSize.width);\n\n      params.push('format=jpg');\n      params.push('scale=2');\n      params.push('sensor=true');\n\n      return encodeURI(path + '?' + params.join('&'));\n    };\n    self.generatePdf = function(locality, number, imageUrl) {\n      if (!imageUrl) {\n        imageUrl = self.generateUrl();\n      }\n      \n      var legend = [];\n      var color;for(var _euydyj5rk9 = 0; _euydyj5rk9 < ColorSvc.colors.length; _euydyj5rk9++) { color = ColorSvc.colors[_euydyj5rk9]\n        var entry = {\n          name: color.name,\n          label: color.label,\n          color: \"#\" + ColorSvc.convert.rgba(color).to.hex24()\n        };\n        legend.push(entry);\n      }\n      var data = {\n        serif: true,\n        locality: locality,\n        notes: \"See attached form for Do Not Calls.\\nAdd new Do Not Calls as you find them.\",\n        legend: legend,\n        number: number,\n        image: imageUrl\n      }\n      \n      // Ugly hack to force browser to download file\n      var form = document.createElement('form');\n      form.style = 'display: none;'\n      form.enctype = 'x-www-form-urlencoded';\n      form.action = 'http://boundariesapp.herokuapp.com/pdf';\n      form.method = 'POST';\n      \n      var input = document.createElement('input');\n      input.name = 'json';\n      input.type = 'text';\n      input.value = angular.toJson(data);\n      \n      form.appendChild(input);\n      \n      document.body.appendChild(form);\n      form.submit();\n      document.body.removeChild(form);\n\t\t\t\n\t\t\t$rootScope.$emit('territory:save', {\n\t\t\t\tlocality: locality,\n\t\t\t\tnumber: number,\n\t\t\t\tdrawings: DrawingSvc.drawingsToGeoJson(DrawingSvc.drawings)\n\t\t\t});\n    }\n  })\n  .controller('ImageCtrl', function($scope, ImageSvc) {\n    $scope.data = {\n\t\t\tlocality: '',\n\t\t\tnumber: ''\n\t\t};\n    \n    $scope.downloadPdf = function() {\n      var locality = prompt('Locality (for example, the name of the city)', '');\n      if (locality === null) {\n        return;\n      }\n      var number = prompt('Territory number (for example, MR-1056)', '');\n      if (number === null) {\n        return;\n      }\n\n\t\t\tImageSvc.generatePdf(locality, number, ImageSvc.generateUrl());\n    };\n  });\n\n//# sourceMappingURL=../../sourcemaps/image/image.js.map","/* global google */\n\nangular.module('bndry.map', ['ngStorage'])\n\n// MapSvc encapsulates google.maps, making it easier to mock for tests.\n.service('MapSvc', function($rootScope) {\n  function makeIcon(color) {\n    return {\n      path: self.SymbolPath.CIRCLE,\n      scale: 10,\n      strokeColor: color,\n      strokeOpacity: 1,\n      strokeWeight: 2.5\n    };\n  }\n\n  function makeMarkerOptions(lat, lng, color) {\n    var clickable = false,\n      cursor = 'pointer',\n      draggable = false;\n    return {\n      clickable: clickable,\n      crossOnDrag: false,\n      cursor: cursor,\n      draggable: draggable,\n      flat: true,\n      icon: makeIcon(color),\n      map: self.map,\n      position: new self.LatLng(lat, lng)\n    };\n  }\n\n  function addListener(eventName) {\n    self.map.addListener(eventName, function(mouseEvent) {\n      $rootScope.$broadcast('map:' + eventName, mouseEvent);\n    });\n  }\n\n  var self = this;\n\n  angular.extend(self, google.maps);\n  self.map = new self.Map(document.getElementById('map_canvas'));\n  self.placesSvc = new self.places.PlacesService(self.map);\n  self.autocompleteSvc = new self.places.AutocompleteService();\n\n  var events = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle', 'maptypeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick', 'tilesloaded', 'tilt_changed', 'zoom_changed'];\n\n  events.forEach(addListener);\n})\n\n// Map controller, mainly for event handling\n.controller('MapCtrl', function($scope, $rootScope, $localStorage, MapSvc) {\n  // Default values for lat, lng, zoom\n  $localStorage.$default({\n    lat: 0,\n    lng: 0,\n    zoom: 10,\n    mapTypeId: MapSvc.MapTypeId.ROADMAP,\n    style: [{\n      'stylers': [{\n        'visibility': 'off'\n      }]\n    }, {\n      'featureType': 'landscape',\n      'stylers': [{\n        'visibility': 'on'\n      }, {\n        'color': '#ffffff'\n      }]\n    }, {\n      'featureType': 'road',\n      'stylers': [{\n        'visibility': 'on'\n      }]\n    }, {\n      'elementType': 'geometry.fill',\n      'stylers': [{\n        'color': '#ffffff'\n      }]\n    }, {\n      'featureType': 'road',\n      'elementType': 'geometry.stroke',\n      'stylers': [{\n        'color': '#808080'\n      }]\n    }, {\n      'elementType': 'labels.text.stroke',\n      'stylers': [{\n        'color': '#ffffff'\n      }]\n    }, {\n      'elementType': 'labels.text.fill',\n      'stylers': [{\n        'color': '#000000'\n      }]\n    }, {\n      'featureType': 'water',\n      'stylers': [{\n        'visibility': 'on'\n      }, {\n        'color': '#40bfbf'\n      }]\n    }, {\n      'featureType': 'water',\n      'elementType': 'labels.text.stroke',\n      'stylers': [{\n        'color': '#ffffff'\n      }]\n    }, {\n      'featureType': 'road.local',\n      'elementType': 'geometry',\n      'stylers': [{\n        'color': '#dfdfdf'\n      }]\n    }, {\n      'featureType': 'road.local',\n      'elementType': 'geometry.stroke',\n      'stylers': [{\n        'visibility': 'off'\n      }]\n    }, {\n      'featureType': 'landscape.man_made',\n      'stylers': [{\n        'visibility': 'off'\n      }]\n    }]\n  });\n  \n  $scope.$on('map:idle', function() {\n    var center = MapSvc.map.getCenter();\n    var zoom = MapSvc.map.getZoom();\n\n    $localStorage.lat = center.lat();\n    $localStorage.lng = center.lng();\n    $localStorage.zoom = zoom;\n  });\n  $scope.$on('map:maptypeid_changed', function() {\n    var mapTypeId = MapSvc.map.getMapTypeId();\n\n    $localStorage.mapTypeId = mapTypeId;\n  });\n\n  // Initialize map\n  var options = {\n    center: new MapSvc.LatLng($localStorage.lat, $localStorage.lng),\n    disableDefaultUI: true,\n    disableDoubleClickZoom: true,\n    draggableCursor: 'crosshair',\n    draggingCursor: 'move',\n    mapTypeId: $localStorage.mapTypeId,\n    zoomControl: true,\n    zoomControlOptions: {\n      position: MapSvc.ControlPosition.LEFT_CENTER\n    },\n    scaleControl: true,\n    zoom: $localStorage.zoom\n  };\n\n  MapSvc.map.setOptions(options);\n  \n  var customMapStyle = new MapSvc.StyledMapType($localStorage.style, {\n    name: 'Custom'\n  });\n  MapSvc.map.mapTypes.set('custom', customMapStyle);\n})\n.controller('MapActionCtrl', function($scope, MapSvc) {\n\t$scope.mapTypeId = MapSvc.MapTypeId;\n  $scope.setMapTypeId = function(mapTypeId) {\n    // if (mapTypeId in MapSvc.MapTypeId) {\n    //   console.log(mapTypeId, 'in MapSvc.mapTypeId');\n    //   mapTypeId = MapSvc.MapTypeId[mapTypeId];\n    // }\n    \n    MapSvc.map.setMapTypeId(mapTypeId);\n  };\n\t$scope.getMapTypeId = function() {\n\t\treturn MapSvc.map.getMapTypeId();\n\t};\n});\n\n//# sourceMappingURL=../../sourcemaps/map/map.js.map","/* jslint camelcase: false */\n\nangular.module('bndry.search', ['ngSanitize', 'bndry.map'])\n  .directive('focusOn', function($parse, $timeout) {\n    return {\n      restrict: 'A',\n      link: function(scope, elem, attr) {\n\t\t\t\tvar value = $parse(attr.focusOn);\n\t\t\t\t\n\t\t\t\tscope.$watch(value.bind(null, scope), function(newVal) {\n          if (newVal === undefined) {\n            return;\n          }\n\t\t\t\t\t\t\t\t\t\t\n          if (newVal) {\n            elem[0].focus();\n          } else {\n            elem[0].blur();\n          }\n\t\t\t\t});\n\t\t\t\t// attr.$observe('focusOn', function(newVal) {\n\t\t\t\t//           if (newVal === undefined) {\n\t\t\t\t//             return;\n\t\t\t\t//           }\n\t\t\t\t//\n\t\t\t\t// \telem = elem[0];\n\t\t\t\t//\n\t\t\t\t// \tconsole.log(newVal ? 'Focus!' : 'Blur!');\n\t\t\t\t//           if (newVal) {\n\t\t\t\t//             $timeout(elem.focus.bind(elem), 10);\n\t\t\t\t//           } else {\n\t\t\t\t//             $timeout(elem.blur.bind(elem), 10);\n\t\t\t\t//           }\n\t\t\t\t// });\n      }\n    };\n  })\n  .service('SearchSvc', function($q, MapSvc) {\n    this.search = function(input) {\n      var deferred = $q.defer();\n\n      if (input.length <= 0) {\n        deferred.resolve([]);\n      } else {\n        var request = {\n          input: input\n        };\n\n        request.bounds = MapSvc.map.getBounds();\n\n        MapSvc.autocompleteSvc.getPlacePredictions(request, function(suggestions, status) {\n          if (status === MapSvc.places.PlacesServiceStatus.OK) {\n            deferred.resolve(suggestions);\n          } else if (status === MapSvc.places.PlacesServiceStatus.ZERO_RESULTS) {\n            deferred.reject('No Results');\n          } else {\n            deferred.reject('An Error Occurred');\n          }\n        });\n      }\n\n      return deferred.promise;\n    };\n\n    this.loadPlaceFromReference = function(reference) {\n      if (!reference) {\n        return;\n      }\n\n      if (reference) {\n        MapSvc.placesSvc.getDetails({\n          reference: reference\n        }, function(place, status) {\n          if (status === MapSvc.places.PlacesServiceStatus.OK) {\n            if (place.geometry.viewport) {\n              // fitBounds because panToBounds does not zoom out to show entire bounding box\n              MapSvc.map.fitBounds(place.geometry.viewport);\n            } else if (place.geometry.location) {\n              MapSvc.map.panTo(place.geometry.location);\n            }\n          }\n        });\n      }\n    };\n  })\n  .controller('SearchCtrl', function($scope, $sce, $sessionStorage, SearchSvc) {\n    function throttledSearch(newVal) {\n\t\t\t// console.log('newVal:', newVal, 'queue:', queue, 'resolved:', resolved, 'last:', last);\n\t\t\tif (!resolved) {\n\t\t\t\t// console.log('Queueing newVal because not resolved. Exiting.', newVal);\n        queue = newVal;\n        return;\n      }\n\n      last = newVal;\n      resolved = false;\n\n      SearchSvc.search(newVal)\n        .then(formatSuggestions, errorMessage)\n        .then(function() {\n          resolved = true;\n\n          if (typeof queue === 'string' && queue !== last) {\n\t\t\t\t\t\t// console.log('Searching with queued value.', queue);\n            throttledSearch(queue);\n            queue = false;\n          }\n        });\n    }\n\n    function formatSuggestions(suggestions) {\n      for (var i = 0; i < suggestions.length; i++) {\n        var desc = suggestions[i].description;\n        suggestions[i].description = '';\n        var index = 0;\n\n        for (var j = 0; j < suggestions[i].matched_substrings.length; j++) {\n          var offset = suggestions[i].matched_substrings[j].offset;\n          var length = suggestions[i].matched_substrings[j].length;\n\n          suggestions[i].description += desc.slice(index, offset) + '<b>' + desc.substr(offset, length) + '</b>';\n\n          index = offset + length;\n        }\n        suggestions[i].description += desc.slice(index);\n        suggestions[i].description = '<span>' + suggestions[i].description + '</span>';\n        suggestions[i].description = $sce.trustAsHtml(suggestions[i].description);\n      }\n\n      $scope.suggestions = suggestions;\n    }\n    // Notifies user that no results were found\n\n    function errorMessage(message) {\n      if (typeof message === 'string') {\n\n        $scope.suggestions = [{\n          description: $sce.trustAsHtml('<i>' + message + '</i>'),\n          error: true\n        }];\n      }\n    }\n\n    var resolved = true,\n      queue = false,\n      last = '',\n\t\t\tfocus = false;\n\n    $scope.query = '';\n\t\t$scope.active = -1;\n        \n    $scope.keydown = function(e) {\n      var enter = (e.which === 13),\n        up = (e.which === 38),\n        down = (e.which === 40);\n\n      if (enter || up || down) {\n        e.preventDefault();\n      } else {\n        $scope.active = 0;\n        return;\n      }\n\n      if ($scope.suggestions[$scope.active]) {\n        if (enter) {\n          $scope.loadOnMap($scope.suggestions[$scope.active].reference);\n          $scope.focus(false);\n        } else if (up && $scope.active > -1) {\n          $scope.active--;\n        } else if (down && $scope.active < $scope.suggestions.length - 1) {\n          $scope.active++;\n        }\n      }\n    };\n\n\t\t$scope.focus = function(value) {\n\t\t\tif (value !== undefined) {\n\t\t\t\tfocus = Boolean(value);\n\t\t\t}\n\t\t\t\n\t\t\treturn focus;\n\t\t};\n    $scope.loadOnMap = function(reference) {\n\t\t\tSearchSvc.loadPlaceFromReference(reference);\n\t\t\t$scope.focus = false;\n\t\t};\n\n    $scope.$watch('query', throttledSearch);\n  });\n\n//# sourceMappingURL=../../sourcemaps/search/search.js.map","angular.module('bndry.shape', ['ngStorage'])\n.service('ShapeSvc', function($localStorage) {\n  this.rigid = function(value) {\n    if (value) {\n      $localStorage.rigid = value;\n    } else {\n      return $localStorage.rigid;\n    }\n  };\n  this.fill = function(value) {\n    if (value) {\n      $localStorage.fill = value;\n    } else {\n      return $localStorage.fill;\n    }\n  };\n})\n.controller('ShapeCtrl', function($scope, $localStorage) {\n  $scope.$storage = $localStorage;\n})\n.run(function($localStorage) {\n  $localStorage.$default({\n    rigid: false,\n    fill: false\n  });\n});\n//# sourceMappingURL=../../sourcemaps/shape/shape.js.map","/* jshint camelcase: false */\n\nangular.module('bndry.status', ['bndry.map', 'bndry.geo'])\n  .directive('statusBar', function($interval) {\n    return {\n      restrict: 'E',\n      scope: {\n        hide: '@',\n        value: '@'\n      },\n      template: '<div ng-style=\"{width: percentage()}\" style=\"height: 100%; position: absolute;\" ng-hide=\"hide\"></div>',\n      link: function(scope) {\n        var pending = 0,\n          finished = 0;\n        \n        scope.$on('load:start', function() {\n          pending++;\n        });\n        scope.$on('load:done', function() {\n          finished++;\n          if (finished >= pending) {\n            pending = 0;\n            finished = 0;\n          }\n        });\n        scope.$on('load:error', function() {\n          pending = 0;\n          finished = 0;\n\t\t\t\t\talert('Directions are not available for this location.');\n        });\n        \n        scope.percentage = function() {\n          return \"\" + (finished + 1) / (pending + 1) * 100 + \"%\";\n        }\n      }\n    };\n  })\n  .controller('StatusCtrl', function($scope, $timeout, MapSvc, GeocodeSvc) {\n    var locality = '';\n\t\tvar lastBounds;\n    \n    $scope.locality = function() {\n      return locality;\n    };\n\n    $scope.$on('map:idle', function() {\n\t\t\tif (lastBounds && MapSvc.map.getBounds().equals(lastBounds)) {\n\t\t\t\treturn;\n\t\t\t}\n      GeocodeSvc.geocode(MapSvc.map.getCenter())\n        .then(function(results) {          \n          var localityTypes = [\n\t\t\t\t\t\t'locality',\n\t\t\t\t\t\t'administrative_area_level_1',\n\t\t\t\t\t\t'country'\n\t\t\t\t\t];\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// [\n\t\t\t\t\t\t// \t'locality'\n\t\t\t\t\t\t// ],\n\t\t\t\t\t\t// [\n\t\t\t\t\t\t// \t'administrative_area_level_1',\n\t\t\t\t\t\t// \t'administrative_area_level_2',\n\t\t\t\t\t\t// \t'administrative_area_level_3'\n\t\t\t\t\t\t// ],\n\t\t\t\t\t\t// [\n\t\t\t\t\t\t// \t'country'\n\t\t\t\t\t\t// ]\n\t\t\t\t\t\t//             'administrative_area_level_3',\n\t\t\t\t\t\t//             'administrative_area_level_2',\n\t\t\t\t\t\t//             'administrative_area_level_1',\n\t\t\t\t\t\t//             'country'\n\t\t\t\t\t\t//           ];\n          \n          locality = '';\n\t\t\t\t\t\n\t\t\t\t\tif (results.length < 1) {\n\t\t\t\t\t\tlocality = 'Unknown Locality';\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar type;for(var _i0di5c7syvi = 0; _i0di5c7syvi < localityTypes.length; _i0di5c7syvi++) { type = localityTypes[_i0di5c7syvi]\n\t\t\t\t\t\tvar result;for(var _iddfy5019k9 = 0; _iddfy5019k9 < results.length; _iddfy5019k9++) { result = results[_iddfy5019k9]\n\t\t\t\t\t\t\tif (result.types.indexOf(type) > -1) {\n\t\t\t\t\t\t\t\tlocality = result.formatted_address;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n        //   results.forEach(function(result) {\n        //     if (locality) {\n        //       return;\n        //     }\n        //\n        //     for (var i = 0; i < localityOptions.length; i++) {\n        //       if (result.types.indexOf(localityOptions[i]) > -1) {\n        //         locality = result.formatted_address;\n        //       }\n        //\n        //       if (locality) {\n        //         return false;\n        //       }\n        //     }\n        //   });\n        // },\n        // function() {\n        //   locality = 'Unknown Locality';\n        // });\n\t\t\t});\n    });\n  });\n\n//# sourceMappingURL=../../sourcemaps/status/status.js.map"],"sourceRoot":"/source/"}